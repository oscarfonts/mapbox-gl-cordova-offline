{"version":3,"file":"mapbox-gl-cordova-offline.js","sources":["../node_modules/pbf/index.js","../node_modules/mapbox-gl/src/style/parse_glyph_pbf.js","../node_modules/mapbox-gl/src/util/actor.js","../node_modules/@mapbox/whoots-js/index.mjs","../node_modules/mapbox-gl/src/geo/lng_lat_bounds.js","../node_modules/mapbox-gl/src/geo/lng_lat.js","../node_modules/mapbox-gl/src/geo/mercator_coordinate.js","../node_modules/mapbox-gl/src/source/tile_id.js","../node_modules/mapbox-gl/src/data/dem_data.js","../node_modules/mapbox-gl/src/util/dictionary_coder.js","../node_modules/mapbox-gl/src/util/vectortile_to_geojson.js","../node_modules/mapbox-gl/src/source/source_state.js","../node_modules/mapbox-gl/src/data/feature_index.js","../node_modules/mapbox-gl/src/util/util.js","../node_modules/mapbox-gl/src/source/tile.js","../node_modules/mapbox-gl/src/data/bucket.js","../node_modules/mapbox-gl/src/style-spec/util/ref_properties.js","../node_modules/mapbox-gl/src/symbol/shaping.js","../node_modules/mapbox-gl/src/util/verticalize_punctuation.js","../node_modules/mapbox-gl/src/style-spec/group_by_layout.js","../node_modules/mapbox-gl/src/style/style_layer_index.js","../node_modules/mapbox-gl/src/symbol/check_max_angle.js","../node_modules/mapbox-gl/src/symbol/get_anchors.js","../node_modules/mapbox-gl/src/symbol/collision_feature.js","../node_modules/tinyqueue/index.js","../node_modules/mapbox-gl/src/util/find_pole_of_inaccessibility.js","../node_modules/murmurhash-js/murmurhash3_gc.js","../node_modules/murmurhash-js/murmurhash2_gc.js","../node_modules/murmurhash-js/index.js","../node_modules/mapbox-gl/src/symbol/symbol_layout.js","../node_modules/mapbox-gl/src/symbol/quads.js","../node_modules/mapbox-gl/src/symbol/clip_line.js","../node_modules/mapbox-gl/src/render/glyph_atlas.js","../node_modules/mapbox-gl/src/source/worker_tile.js","../node_modules/mapbox-gl/src/util/performance.js","../node_modules/mapbox-gl/src/source/vector_tile_worker_source.js","../node_modules/mapbox-gl/src/source/raster_dem_tile_worker_source.js","../node_modules/wgs84/index.js","../node_modules/@mapbox/geojson-area/index.js","../node_modules/@mapbox/geojson-rewind/index.js","../node_modules/mapbox-gl/src/source/geojson_wrapper.js","../node_modules/vt-pbf/lib/geojson_wrapper.js","../node_modules/vt-pbf/index.js","../node_modules/mapbox-gl/src/render/draw_debug.js","../node_modules/mapbox-gl/src/render/painter.js","../node_modules/mapbox-gl/src/render/draw_symbol.js","../node_modules/mapbox-gl/src/render/draw_collision_debug.js","../node_modules/mapbox-gl/src/render/draw_circle.js","../node_modules/mapbox-gl/src/render/draw_heatmap.js","../node_modules/mapbox-gl/src/ui/map.js","../node_modules/pako/lib/inflate.js","../node_modules/base64-js/index.js","../src/mbtiles_source.js","../src/offline_map.js","../rollup/mapboxgl.js"],"sourcesContent":["'use strict';\n\nmodule.exports = Pbf;\n\nvar ieee754 = require('ieee754');\n\nfunction Pbf(buf) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n    this.pos = 0;\n    this.type = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = readUInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = readInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function(isSigned) {\n        var buf = this.buf,\n            val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    },\n\n    readVarint64: function() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos,\n            str = readUtf8(this.buf, this.pos, end);\n        this.pos = end;\n        return str;\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function(arr, isSigned) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readVarint(isSigned));\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    },\n    readPackedSVarint: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSVarint());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readBoolean());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFloat());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readDouble());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed32());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed32());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readFixed64());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function(arr) {\n        if (this.type !== Pbf.Bytes) return arr.push(this.readSFixed64());\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        var startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        ieee754.write(this.buf, val, this.pos, true, 23, 4);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        ieee754.write(this.buf, val, this.pos, true, 52, 8);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { if (arr.length) this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction readVarintRemainder(l, s, p) {\n    var buf = p.buf,\n        h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\nfunction readPackedEnd(pbf) {\n    return pbf.type === Pbf.Bytes ?\n        pbf.readVarint() + pbf.pos : pbf.pos + 1;\n}\n\nfunction toNum(low, high, isSigned) {\n    if (isSigned) {\n        return high * 0x100000000 + (low >>> 0);\n    }\n\n    return ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\nfunction writeBigVarint(val, pbf) {\n    var low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\nfunction writeBigVarintHigh(high, pbf) {\n    var lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    var extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\nfunction readUInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] * 0x1000000);\n}\n\nfunction writeInt32(buf, val, pos) {\n    buf[pos] = val;\n    buf[pos + 1] = (val >>> 8);\n    buf[pos + 2] = (val >>> 16);\n    buf[pos + 3] = (val >>> 24);\n}\n\nfunction readInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] << 24);\n}\n\nfunction readUtf8(buf, pos, end) {\n    var str = '';\n    var i = pos;\n\n    while (i < end) {\n        var b0 = buf[i];\n        var c = null; // codepoint\n        var bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        var b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nfunction writeUtf8(buf, str, pos) {\n    for (var i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n","// @flow\n\nimport { AlphaImage } from '../util/image';\n\nimport Protobuf from 'pbf';\nconst border = 3;\n\nimport type {StyleGlyph} from './style_glyph';\n\nfunction readFontstacks(tag: number, glyphs: Array<StyleGlyph>, pbf: Protobuf) {\n    if (tag === 1) {\n        pbf.readMessage(readFontstack, glyphs);\n    }\n}\n\nfunction readFontstack(tag: number, glyphs: Array<StyleGlyph>, pbf: Protobuf) {\n    if (tag === 3) {\n        const {id, bitmap, width, height, left, top, advance} = pbf.readMessage(readGlyph, {});\n        glyphs.push({\n            id,\n            bitmap: new AlphaImage({\n                width: width + 2 * border,\n                height: height + 2 * border\n            }, bitmap),\n            metrics: {width, height, left, top, advance}\n        });\n    }\n}\n\nfunction readGlyph(tag: number, glyph: Object, pbf: Protobuf) {\n    if (tag === 1) glyph.id = pbf.readVarint();\n    else if (tag === 2) glyph.bitmap = pbf.readBytes();\n    else if (tag === 3) glyph.width = pbf.readVarint();\n    else if (tag === 4) glyph.height = pbf.readVarint();\n    else if (tag === 5) glyph.left = pbf.readSVarint();\n    else if (tag === 6) glyph.top = pbf.readSVarint();\n    else if (tag === 7) glyph.advance = pbf.readVarint();\n}\n\nexport default function (data: ArrayBuffer | Uint8Array): Array<StyleGlyph> {\n    return new Protobuf(data).readFields(readFontstacks, []);\n}\n\nexport const GLYPH_PBF_BORDER = border;\n","// @flow\n\nimport { bindAll } from './util';\nimport { serialize, deserialize } from './web_worker_transfer';\n\nimport type {Transferable} from '../types/transferable';\nimport type {Cancelable} from '../types/cancelable';\n\n/**\n * An implementation of the [Actor design pattern](http://en.wikipedia.org/wiki/Actor_model)\n * that maintains the relationship between asynchronous tasks and the objects\n * that spin them off - in this case, tasks like parsing parts of styles,\n * owned by the styles\n *\n * @param {WebWorker} target\n * @param {WebWorker} parent\n * @param {string|number} mapId A unique identifier for the Map instance using this Actor.\n * @private\n */\nclass Actor {\n    target: any;\n    parent: any;\n    mapId: string;\n    callbacks: any;\n    callbackID: number;\n    name: string;\n\n    constructor(target: any, parent: any, mapId: any) {\n        this.target = target;\n        this.parent = parent;\n        this.mapId = mapId;\n        this.callbacks = {};\n        this.callbackID = 0;\n        bindAll(['receive'], this);\n        this.target.addEventListener('message', this.receive, false);\n    }\n\n    /**\n     * Sends a message from a main-thread map to a Worker or from a Worker back to\n     * a main-thread map instance.\n     *\n     * @param type The name of the target method to invoke or '[source-type].[source-name].name' for a method on a WorkerSource.\n     * @param targetMapId A particular mapId to which to send this message.\n     * @private\n     */\n    send(type: string, data: mixed, callback: ?Function, targetMapId: ?string): ?Cancelable {\n        const id = callback ? `${this.mapId}:${this.callbackID++}` : null;\n        if (callback) this.callbacks[id] = callback;\n        const buffers: Array<Transferable> = [];\n        this.target.postMessage({\n            targetMapId,\n            sourceMapId: this.mapId,\n            type,\n            id: String(id),\n            data: serialize(data, buffers)\n        }, buffers);\n        if (callback) {\n            return {\n                cancel: () => this.target.postMessage({\n                    targetMapId,\n                    sourceMapId: this.mapId,\n                    type: '<cancel>',\n                    id: String(id)\n                })\n            };\n        }\n    }\n\n    receive(message: Object) {\n        const data = message.data,\n            id = data.id;\n        let callback;\n\n        if (data.targetMapId && this.mapId !== data.targetMapId)\n            return;\n\n        const done = (err, data) => {\n            delete this.callbacks[id];\n            const buffers: Array<Transferable> = [];\n            this.target.postMessage({\n                sourceMapId: this.mapId,\n                type: '<response>',\n                id: String(id),\n                error: err ? serialize(err) : null,\n                data: serialize(data, buffers)\n            }, buffers);\n        };\n\n        if (data.type === '<response>' || data.type === '<cancel>') {\n            callback = this.callbacks[data.id];\n            delete this.callbacks[data.id];\n            if (callback && data.error) {\n                callback(deserialize(data.error));\n            } else if (callback) {\n                callback(null, deserialize(data.data));\n            }\n        } else if (typeof data.id !== 'undefined' && this.parent[data.type]) {\n            // data.type == 'loadTile', 'removeTile', etc.\n            // Add a placeholder so that we can discover when the done callback was called already.\n            this.callbacks[data.id] = null;\n            const cancelable = this.parent[data.type](data.sourceMapId, deserialize(data.data), done);\n            if (cancelable && this.callbacks[data.id] === null) {\n                // Only add the cancelable callback if the done callback wasn't already called.\n                // Otherwise we will never be able to delete it.\n                this.callbacks[data.id]  = cancelable;\n            }\n        } else if (typeof data.id !== 'undefined' && this.parent.getWorkerSource) {\n            // data.type == sourcetype.method\n            const keys = data.type.split('.');\n            const params = (deserialize(data.data): any);\n            const workerSource = (this.parent: any).getWorkerSource(data.sourceMapId, keys[0], params.source);\n            workerSource[keys[1]](params, done);\n        } else {\n            this.parent[data.type](deserialize(data.data));\n        }\n    }\n\n    remove() {\n        this.target.removeEventListener('message', this.receive, false);\n    }\n}\n\nexport default Actor;\n","export { getURL, getTileBBox, getMercCoords };\n\n\n/**\n * getURL\n *\n * @param    {String}  baseUrl  Base url of the WMS server\n * @param    {String}  layer    Layer name\n * @param    {Number}  x        Tile coordinate x\n * @param    {Number}  y        Tile coordinate y\n * @param    {Number}  z        Tile zoom\n * @param    {Object}  [options]\n * @param    {String}  [options.format='image/png']\n * @param    {String}  [options.service='WMS']\n * @param    {String}  [options.version='1.1.1']\n * @param    {String}  [options.request='GetMap']\n * @param    {String}  [options.srs='EPSG:3857']\n * @param    {Number}  [options.width='256']\n * @param    {Number}  [options.height='256']\n * @returns  {String}  url\n * @example\n * var baseUrl = 'http://geodata.state.nj.us/imagerywms/Natural2015';\n * var layer = 'Natural2015';\n * var url = whoots.getURL(baseUrl, layer, 154308, 197167, 19);\n */\nfunction getURL(baseUrl, layer, x, y, z, options) {\n    options = options || {};\n\n    var url = baseUrl + '?' + [\n        'bbox='    + getTileBBox(x, y, z),\n        'format='  + (options.format || 'image/png'),\n        'service=' + (options.service || 'WMS'),\n        'version=' + (options.version || '1.1.1'),\n        'request=' + (options.request || 'GetMap'),\n        'srs='     + (options.srs || 'EPSG:3857'),\n        'width='   + (options.width || 256),\n        'height='  + (options.height || 256),\n        'layers='  + layer\n    ].join('&');\n\n    return url;\n}\n\n\n/**\n * getTileBBox\n *\n * @param    {Number}  x  Tile coordinate x\n * @param    {Number}  y  Tile coordinate y\n * @param    {Number}  z  Tile zoom\n * @returns  {String}  String of the bounding box\n */\nfunction getTileBBox(x, y, z) {\n    // for Google/OSM tile scheme we need to alter the y\n    y = (Math.pow(2, z) - y - 1);\n\n    var min = getMercCoords(x * 256, y * 256, z),\n        max = getMercCoords((x + 1) * 256, (y + 1) * 256, z);\n\n    return min[0] + ',' + min[1] + ',' + max[0] + ',' + max[1];\n}\n\n\n/**\n * getMercCoords\n *\n * @param    {Number}  x  Pixel coordinate x\n * @param    {Number}  y  Pixel coordinate y\n * @param    {Number}  z  Tile zoom\n * @returns  {Array}   [x, y]\n */\nfunction getMercCoords(x, y, z) {\n    var resolution = (2 * Math.PI * 6378137 / 256) / Math.pow(2, z),\n        merc_x = (x * resolution - 2 * Math.PI  * 6378137 / 2.0),\n        merc_y = (y * resolution - 2 * Math.PI  * 6378137 / 2.0);\n\n    return [merc_x, merc_y];\n}\n","// @flow\n\nimport LngLat from './lng_lat';\n\nimport type {LngLatLike} from './lng_lat';\n\n/**\n * A `LngLatBounds` object represents a geographical bounding box,\n * defined by its southwest and northeast points in longitude and latitude.\n *\n * If no arguments are provided to the constructor, a `null` bounding box is created.\n *\n * Note that any Mapbox GL method that accepts a `LngLatBounds` object as an argument or option\n * can also accept an `Array` of two {@link LngLatLike} constructs and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatBoundsLike}.\n *\n * @param {LngLatLike} [sw] The southwest corner of the bounding box.\n * @param {LngLatLike} [ne] The northeast corner of the bounding box.\n * @example\n * var sw = new mapboxgl.LngLat(-73.9876, 40.7661);\n * var ne = new mapboxgl.LngLat(-73.9397, 40.8002);\n * var llb = new mapboxgl.LngLatBounds(sw, ne);\n */\nclass LngLatBounds {\n    _ne: LngLat;\n    _sw: LngLat;\n\n    // This constructor is too flexible to type. It should not be so flexible.\n    constructor(sw: any, ne: any) {\n        if (!sw) {\n            // noop\n        } else if (ne) {\n            this.setSouthWest(sw).setNorthEast(ne);\n        } else if (sw.length === 4) {\n            this.setSouthWest([sw[0], sw[1]]).setNorthEast([sw[2], sw[3]]);\n        } else {\n            this.setSouthWest(sw[0]).setNorthEast(sw[1]);\n        }\n    }\n\n    /**\n     * Set the northeast corner of the bounding box\n     *\n     * @param {LngLatLike} ne\n     * @returns {LngLatBounds} `this`\n     */\n    setNorthEast(ne: LngLatLike) {\n        this._ne = ne instanceof LngLat ? new LngLat(ne.lng, ne.lat) : LngLat.convert(ne);\n        return this;\n    }\n\n    /**\n     * Set the southwest corner of the bounding box\n     *\n     * @param {LngLatLike} sw\n     * @returns {LngLatBounds} `this`\n     */\n    setSouthWest(sw: LngLatLike) {\n        this._sw = sw instanceof LngLat ? new LngLat(sw.lng, sw.lat) : LngLat.convert(sw);\n        return this;\n    }\n\n    /**\n     * Extend the bounds to include a given LngLat or LngLatBounds.\n     *\n     * @param {LngLat|LngLatBounds} obj object to extend to\n     * @returns {LngLatBounds} `this`\n     */\n    extend(obj: LngLat | LngLatBounds) {\n        const sw = this._sw,\n            ne = this._ne;\n        let sw2, ne2;\n\n        if (obj instanceof LngLat) {\n            sw2 = obj;\n            ne2 = obj;\n\n        } else if (obj instanceof LngLatBounds) {\n            sw2 = obj._sw;\n            ne2 = obj._ne;\n\n            if (!sw2 || !ne2) return this;\n\n        } else {\n            if (Array.isArray(obj)) {\n                if (obj.every(Array.isArray)) {\n                    return this.extend(LngLatBounds.convert(obj));\n                } else {\n                    return this.extend(LngLat.convert(obj));\n                }\n            }\n            return this;\n        }\n\n        if (!sw && !ne) {\n            this._sw = new LngLat(sw2.lng, sw2.lat);\n            this._ne = new LngLat(ne2.lng, ne2.lat);\n\n        } else {\n            sw.lng = Math.min(sw2.lng, sw.lng);\n            sw.lat = Math.min(sw2.lat, sw.lat);\n            ne.lng = Math.max(ne2.lng, ne.lng);\n            ne.lat = Math.max(ne2.lat, ne.lat);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the geographical coordinate equidistant from the bounding box's corners.\n     *\n     * @returns {LngLat} The bounding box's center.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}\n     */\n    getCenter(): LngLat {\n        return new LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);\n    }\n\n    /**\n     * Returns the southwest corner of the bounding box.\n     *\n     * @returns {LngLat} The southwest corner of the bounding box.\n     */\n    getSouthWest(): LngLat { return this._sw; }\n\n    /**\n    * Returns the northeast corner of the bounding box.\n    *\n    * @returns {LngLat} The northeast corner of the bounding box.\n     */\n    getNorthEast(): LngLat { return this._ne; }\n\n    /**\n    * Returns the northwest corner of the bounding box.\n    *\n    * @returns {LngLat} The northwest corner of the bounding box.\n     */\n    getNorthWest(): LngLat { return new LngLat(this.getWest(), this.getNorth()); }\n\n    /**\n    * Returns the southeast corner of the bounding box.\n    *\n    * @returns {LngLat} The southeast corner of the bounding box.\n     */\n    getSouthEast(): LngLat { return new LngLat(this.getEast(), this.getSouth()); }\n\n    /**\n    * Returns the west edge of the bounding box.\n    *\n    * @returns {number} The west edge of the bounding box.\n     */\n    getWest(): number { return this._sw.lng; }\n\n    /**\n    * Returns the south edge of the bounding box.\n    *\n    * @returns {number} The south edge of the bounding box.\n     */\n    getSouth(): number { return this._sw.lat; }\n\n    /**\n    * Returns the east edge of the bounding box.\n    *\n    * @returns {number} The east edge of the bounding box.\n     */\n    getEast(): number { return this._ne.lng; }\n\n    /**\n    * Returns the north edge of the bounding box.\n    *\n    * @returns {number} The north edge of the bounding box.\n     */\n    getNorth(): number { return this._ne.lat; }\n\n    /**\n     * Returns the bounding box represented as an array.\n     *\n     * @returns {Array<Array<number>>} The bounding box represented as an array, consisting of the\n     *   southwest and northeast coordinates of the bounding represented as arrays of numbers.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]\n     */\n    toArray() {\n        return [this._sw.toArray(), this._ne.toArray()];\n    }\n\n    /**\n     * Return the bounding box represented as a string.\n     *\n     * @returns {string} The bounding box represents as a string of the format\n     *   `'LngLatBounds(LngLat(lng, lat), LngLat(lng, lat))'`.\n     * @example\n     * var llb = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);\n     * llb.toString(); // = \"LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))\"\n     */\n    toString() {\n        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;\n    }\n\n    /**\n     * Check if the bounding box is an empty/`null`-type box.\n     *\n     * @returns {boolean} True if bounds have been defined, otherwise false.\n     */\n    isEmpty() {\n        return !(this._sw && this._ne);\n    }\n\n    /**\n     * Converts an array to a `LngLatBounds` object.\n     *\n     * If a `LngLatBounds` object is passed in, the function returns it unchanged.\n     *\n     * Internally, the function calls `LngLat#convert` to convert arrays to `LngLat` values.\n     *\n     * @param {LngLatBoundsLike} input An array of two coordinates to convert, or a `LngLatBounds` object to return.\n     * @returns {LngLatBounds} A new `LngLatBounds` object, if a conversion occurred, or the original `LngLatBounds` object.\n     * @example\n     * var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n     * var llb = mapboxgl.LngLatBounds.convert(arr);\n     * llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}\n     */\n    static convert(input: LngLatBoundsLike): LngLatBounds {\n        if (!input || input instanceof LngLatBounds) return input;\n        return new LngLatBounds(input);\n    }\n}\n\n/**\n * A {@link LngLatBounds} object, an array of {@link LngLatLike} objects in [sw, ne] order,\n * or an array of numbers in [west, south, east, north] order.\n *\n * @typedef {LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number]} LngLatBoundsLike\n * @example\n * var v1 = new mapboxgl.LngLatBounds(\n *   new mapboxgl.LngLat(-73.9876, 40.7661),\n *   new mapboxgl.LngLat(-73.9397, 40.8002)\n * );\n * var v2 = new mapboxgl.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002])\n * var v3 = [[-73.9876, 40.7661], [-73.9397, 40.8002]];\n */\nexport type LngLatBoundsLike = LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number];\n\nexport default LngLatBounds;\n","// @flow\n\nimport { wrap } from '../util/util';\nimport LngLatBounds from './lng_lat_bounds';\n\n/**\n * A `LngLat` object represents a given longitude and latitude coordinate, measured in degrees.\n *\n * Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.\n *\n * Note that any Mapbox GL method that accepts a `LngLat` object as an argument or option\n * can also accept an `Array` of two numbers and will perform an implicit conversion.\n * This flexible type is documented as {@link LngLatLike}.\n *\n * @param {number} lng Longitude, measured in degrees.\n * @param {number} lat Latitude, measured in degrees.\n * @example\n * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n * @see [Get coordinates of the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/mouse-position/)\n * @see [Display a popup](https://www.mapbox.com/mapbox-gl-js/example/popup/)\n * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)\n */\nclass LngLat {\n    lng: number;\n    lat: number;\n\n    constructor(lng: number, lat: number) {\n        if (isNaN(lng) || isNaN(lat)) {\n            throw new Error(`Invalid LngLat object: (${lng}, ${lat})`);\n        }\n        this.lng = +lng;\n        this.lat = +lat;\n        if (this.lat > 90 || this.lat < -90) {\n            throw new Error('Invalid LngLat latitude value: must be between -90 and 90');\n        }\n    }\n\n    /**\n     * Returns a new `LngLat` object whose longitude is wrapped to the range (-180, 180).\n     *\n     * @returns {LngLat} The wrapped `LngLat` object.\n     * @example\n     * var ll = new mapboxgl.LngLat(286.0251, 40.7736);\n     * var wrapped = ll.wrap();\n     * wrapped.lng; // = -73.9749\n     */\n    wrap() {\n        return new LngLat(wrap(this.lng, -180, 180), this.lat);\n    }\n\n    /**\n     * Returns the coordinates represented as an array of two numbers.\n     *\n     * @returns {Array<number>} The coordinates represeted as an array of longitude and latitude.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toArray(); // = [-73.9749, 40.7736]\n     */\n    toArray() {\n        return [this.lng, this.lat];\n    }\n\n    /**\n     * Returns the coordinates represent as a string.\n     *\n     * @returns {string} The coordinates represented as a string of the format `'LngLat(lng, lat)'`.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toString(); // = \"LngLat(-73.9749, 40.7736)\"\n     */\n    toString() {\n        return `LngLat(${this.lng}, ${this.lat})`;\n    }\n\n    /**\n     * Returns a `LngLatBounds` from the coordinates extended by a given `radius`.\n     *\n     * @param {number} [radius=0] Distance in meters from the coordinates to extend the bounds.\n     * @returns {LngLatBounds} A new `LngLatBounds` object representing the coordinates extended by the `radius`.\n     * @example\n     * var ll = new mapboxgl.LngLat(-73.9749, 40.7736);\n     * ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]\n     */\n    toBounds(radius?: number = 0) {\n        const earthCircumferenceInMetersAtEquator = 40075017;\n        const latAccuracy = 360 * radius / earthCircumferenceInMetersAtEquator,\n            lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);\n\n        return new LngLatBounds(new LngLat(this.lng - lngAccuracy, this.lat - latAccuracy),\n            new LngLat(this.lng + lngAccuracy, this.lat + latAccuracy));\n    }\n\n    /**\n     * Converts an array of two numbers or an object with `lng` and `lat` or `lon` and `lat` properties\n     * to a `LngLat` object.\n     *\n     * If a `LngLat` object is passed in, the function returns it unchanged.\n     *\n     * @param {LngLatLike} input An array of two numbers or object to convert, or a `LngLat` object to return.\n     * @returns {LngLat} A new `LngLat` object, if a conversion occurred, or the original `LngLat` object.\n     * @example\n     * var arr = [-73.9749, 40.7736];\n     * var ll = mapboxgl.LngLat.convert(arr);\n     * ll;   // = LngLat {lng: -73.9749, lat: 40.7736}\n     */\n    static convert(input: LngLatLike): LngLat {\n        if (input instanceof LngLat) {\n            return input;\n        }\n        if (Array.isArray(input) && (input.length === 2 || input.length === 3)) {\n            return new LngLat(Number(input[0]), Number(input[1]));\n        }\n        if (!Array.isArray(input) && typeof input === 'object' && input !== null) {\n            return new LngLat(\n                // flow can't refine this to have one of lng or lat, so we have to cast to any\n                Number('lng' in input ? (input: any).lng : (input: any).lon),\n                Number(input.lat)\n            );\n        }\n        throw new Error(\"`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]\");\n    }\n}\n\n/**\n * A {@link LngLat} object, an array of two numbers representing longitude and latitude,\n * or an object with `lng` and `lat` or `lon` and `lat` properties.\n *\n * @typedef {LngLat | {lng: number, lat: number} | {lon: number, lat: number} | [number, number]} LngLatLike\n * @example\n * var v1 = new mapboxgl.LngLat(-122.420679, 37.772537);\n * var v2 = [-122.420679, 37.772537];\n * var v3 = {lon: -122.420679, lat: 37.772537};\n */\nexport type LngLatLike = LngLat | {lng: number, lat: number} | {lon: number, lat: number} | [number, number];\n\nexport default LngLat;\n","// @flow\n\nimport LngLat from '../geo/lng_lat';\nimport type {LngLatLike} from '../geo/lng_lat';\n\n/*\n * The circumference of the world in meters at the given latitude.\n */\nfunction circumferenceAtLatitude(latitude: number) {\n    const circumference = 2 * Math.PI * 6378137;\n    return circumference * Math.cos(latitude * Math.PI / 180);\n}\n\nexport function mercatorXfromLng(lng: number) {\n    return (180 + lng) / 360;\n}\n\nexport function mercatorYfromLat(lat: number) {\n    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;\n}\n\nexport function mercatorZfromAltitude(altitude: number, lat: number) {\n    return altitude / circumferenceAtLatitude(lat);\n}\n\nexport function lngFromMercatorX(x: number) {\n    return x * 360 - 180;\n}\n\nexport function latFromMercatorY(y: number) {\n    const y2 = 180 - y * 360;\n    return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\n\nexport function altitudeFromMercatorZ(z: number, y: number) {\n    return z * circumferenceAtLatitude(latFromMercatorY(y));\n}\n\n/**\n * A `MercatorCoordinate` object represents a projected three dimensional position.\n *\n * `MercatorCoordinate` uses the web mercator projection ([EPSG:3857](https://epsg.io/3857)) with slightly different units:\n * - the size of 1 unit is the width of the projected world instead of the \"mercator meter\"\n * - the origin of the coordinate space is at the north-west corner instead of the middle\n *\n * For example, `MercatorCoordinate(0, 0, 0)` is the north-west corner of the mercator world and\n * `MercatorCoordinate(1, 1, 0)` is the south-east corner. If you are familiar with\n * [vector tiles](https://github.com/mapbox/vector-tile-spec) it may be helpful to think\n * of the coordinate space as the `0/0/0` tile with an extent of `1`.\n *\n * The `z` dimension of `MercatorCoordinate` is conformal. A cube in the mercator coordinate space would be rendered as a cube.\n *\n * @param {number} x The x component of the position.\n * @param {number} y The y component of the position.\n * @param {number} z The z component of the position.\n * @example\n * var nullIsland = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0);\n *\n * @see [Add a custom style layer](https://www.mapbox.com/mapbox-gl-js/example/custom-style-layer/)\n */\nclass MercatorCoordinate {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number = 0) {\n        this.x = +x;\n        this.y = +y;\n        this.z = +z;\n    }\n\n    /**\n     * Project a `LngLat` to a `MercatorCoordinate`.\n     *\n     * @param {LngLatLike} lngLatLike The location to project.\n     * @param {number} altitude The altitude in meters of the position.\n     * @returns {MercatorCoordinate} The projected mercator coordinate.\n     * @example\n     * var coord = mapboxgl.MercatorCoordinate.fromLngLat({ lng: 0, lat: 0}, 0);\n     * coord; // MercatorCoordinate(0.5, 0.5, 0)\n     */\n    static fromLngLat(lngLatLike: LngLatLike, altitude: number = 0) {\n        const lngLat = LngLat.convert(lngLatLike);\n\n        return new MercatorCoordinate(\n                mercatorXfromLng(lngLat.lng),\n                mercatorYfromLat(lngLat.lat),\n                mercatorZfromAltitude(altitude, lngLat.lat));\n    }\n\n    /**\n     * Returns the `LngLat` for the coordinate.\n     *\n     * @returns {LngLat} The `LngLat` object.\n     * @example\n     * var coord = new mapboxgl.MercatorCoordinate(0.5, 0.5, 0);\n     * var latLng = coord.toLngLat(); // LngLat(0, 0)\n     */\n    toLngLat() {\n        return new LngLat(\n                lngFromMercatorX(this.x),\n                latFromMercatorY(this.y));\n    }\n\n    /**\n     * Returns the altitude in meters of the coordinate.\n     *\n     * @returns {number} The altitude in meters.\n     * @example\n     * var coord = new mapboxgl.MercatorCoordinate(0, 0, 0.02);\n     * coord.toAltitude(); // 6914.281956295339\n     */\n    toAltitude() {\n        return altitudeFromMercatorZ(this.z, this.y);\n    }\n}\n\nexport default MercatorCoordinate;\n","// @flow\n\nimport {getTileBBox} from '@mapbox/whoots-js';\nimport EXTENT from '../data/extent';\nimport Point from '@mapbox/point-geometry';\nimport MercatorCoordinate from '../geo/mercator_coordinate';\n\nimport assert from 'assert';\nimport { register } from '../util/web_worker_transfer';\n\nexport class CanonicalTileID {\n    z: number;\n    x: number;\n    y: number;\n    key: number;\n\n    constructor(z: number, x: number, y: number) {\n        assert(z >= 0 && z <= 25);\n        assert(x >= 0 && x < Math.pow(2, z));\n        assert(y >= 0 && y < Math.pow(2, z));\n        this.z = z;\n        this.x = x;\n        this.y = y;\n        this.key = calculateKey(0, z, x, y);\n    }\n\n    equals(id: CanonicalTileID) {\n        return this.z === id.z && this.x === id.x && this.y === id.y;\n    }\n\n    // given a list of urls, choose a url template and return a tile URL\n    url(urls: Array<string>, scheme: ?string) {\n        const bbox = getTileBBox(this.x, this.y, this.z);\n        const quadkey = getQuadkey(this.z, this.x, this.y);\n\n        return urls[(this.x + this.y) % urls.length]\n            .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))\n            .replace('{z}', String(this.z))\n            .replace('{x}', String(this.x))\n            .replace('{y}', String(scheme === 'tms' ? (Math.pow(2, this.z) - this.y - 1) : this.y))\n            .replace('{quadkey}', quadkey)\n            .replace('{bbox-epsg-3857}', bbox);\n    }\n\n    getTilePoint(coord: MercatorCoordinate) {\n        const tilesAtZoom = Math.pow(2, this.z);\n        return new Point(\n            (coord.x * tilesAtZoom - this.x) * EXTENT,\n            (coord.y * tilesAtZoom - this.y) * EXTENT);\n    }\n}\n\nexport class UnwrappedTileID {\n    wrap: number;\n    canonical: CanonicalTileID;\n    key: number;\n\n    constructor(wrap: number, canonical: CanonicalTileID) {\n        this.wrap = wrap;\n        this.canonical = canonical;\n        this.key = calculateKey(wrap, canonical.z, canonical.x, canonical.y);\n    }\n}\n\nexport class OverscaledTileID {\n    overscaledZ: number;\n    wrap: number;\n    canonical: CanonicalTileID;\n    key: number;\n    posMatrix: Float32Array;\n\n    constructor(overscaledZ: number, wrap: number, z: number, x: number, y: number) {\n        assert(overscaledZ >= z);\n        this.overscaledZ = overscaledZ;\n        this.wrap = wrap;\n        this.canonical = new CanonicalTileID(z, +x, +y);\n        this.key = calculateKey(wrap, overscaledZ, x, y);\n    }\n\n    equals(id: OverscaledTileID) {\n        return this.overscaledZ === id.overscaledZ && this.wrap === id.wrap && this.canonical.equals(id.canonical);\n    }\n\n    scaledTo(targetZ: number) {\n        assert(targetZ <= this.overscaledZ);\n        const zDifference = this.canonical.z - targetZ;\n        if (targetZ > this.canonical.z) {\n            return new OverscaledTileID(targetZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n        } else {\n            return new OverscaledTileID(targetZ, this.wrap, targetZ, this.canonical.x >> zDifference, this.canonical.y >> zDifference);\n        }\n    }\n\n    isChildOf(parent: OverscaledTileID) {\n        if (parent.wrap !== this.wrap) {\n            // We can't be a child if we're in a different world copy\n            return false;\n        }\n        const zDifference = this.canonical.z - parent.canonical.z;\n        // We're first testing for z == 0, to avoid a 32 bit shift, which is undefined.\n        return parent.overscaledZ === 0 || (\n            parent.overscaledZ < this.overscaledZ &&\n                parent.canonical.x === (this.canonical.x >> zDifference) &&\n                parent.canonical.y === (this.canonical.y >> zDifference));\n    }\n\n    children(sourceMaxZoom: number) {\n        if (this.overscaledZ >= sourceMaxZoom) {\n            // return a single tile coord representing a an overscaled tile\n            return [new OverscaledTileID(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];\n        }\n\n        const z = this.canonical.z + 1;\n        const x = this.canonical.x * 2;\n        const y = this.canonical.y * 2;\n        return [\n            new OverscaledTileID(z, this.wrap, z, x, y),\n            new OverscaledTileID(z, this.wrap, z, x + 1, y),\n            new OverscaledTileID(z, this.wrap, z, x, y + 1),\n            new OverscaledTileID(z, this.wrap, z, x + 1, y + 1)\n        ];\n    }\n\n    isLessThan(rhs: OverscaledTileID) {\n        if (this.wrap < rhs.wrap) return true;\n        if (this.wrap > rhs.wrap) return false;\n\n        if (this.overscaledZ < rhs.overscaledZ) return true;\n        if (this.overscaledZ > rhs.overscaledZ) return false;\n\n        if (this.canonical.x < rhs.canonical.x) return true;\n        if (this.canonical.x > rhs.canonical.x) return false;\n\n        if (this.canonical.y < rhs.canonical.y) return true;\n        return false;\n    }\n\n    wrapped() {\n        return new OverscaledTileID(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    unwrapTo(wrap: number) {\n        return new OverscaledTileID(this.overscaledZ, wrap, this.canonical.z, this.canonical.x, this.canonical.y);\n    }\n\n    overscaleFactor() {\n        return Math.pow(2, this.overscaledZ - this.canonical.z);\n    }\n\n    toUnwrapped() {\n        return new UnwrappedTileID(this.wrap, this.canonical);\n    }\n\n    toString() {\n        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;\n    }\n\n    getTilePoint(coord: MercatorCoordinate) {\n        return this.canonical.getTilePoint(new MercatorCoordinate(coord.x - this.wrap, coord.y));\n    }\n}\n\nfunction calculateKey(wrap: number, z: number, x: number, y: number) {\n    wrap *= 2;\n    if (wrap < 0) wrap = wrap * -1 - 1;\n    const dim = 1 << z;\n    return ((dim * dim * wrap + dim * y + x) * 32) + z;\n}\n\n\nfunction getQuadkey(z, x, y) {\n    let quadkey = '', mask;\n    for (let i = z; i > 0; i--) {\n        mask = 1 << (i - 1);\n        quadkey += ((x & mask ? 1 : 0) + (y & mask ? 2 : 0));\n    }\n    return quadkey;\n}\n\nregister('CanonicalTileID', CanonicalTileID);\nregister('OverscaledTileID', OverscaledTileID, {omit: ['posMatrix']});\n","// @flow\nimport { RGBAImage } from '../util/image';\n\nimport { warnOnce } from '../util/util';\nimport { register } from '../util/web_worker_transfer';\n\n// DEMData is a data structure for decoding, backfilling, and storing elevation data for processing in the hillshade shaders\n// data can be populated either from a pngraw image tile or from serliazed data sent back from a worker. When data is initially\n// loaded from a image tile, we decode the pixel values using the appropriate decoding formula, but we store the\n// elevation data as an Int32 value. we add 65536 (2^16) to eliminate negative values and enable the use of\n// integer overflow when creating the texture used in the hillshadePrepare step.\n\n// DEMData also handles the backfilling of data from a tile's neighboring tiles. This is necessary because we use a pixel's 8\n// surrounding pixel values to compute the slope at that pixel, and we cannot accurately calculate the slope at pixels on a\n// tile's edge without backfilling from neighboring tiles.\n\nexport default class DEMData {\n    uid: string;\n    data: Int32Array;\n    stride: number;\n    dim: number;\n\n    constructor(uid: string, data: RGBAImage, encoding: \"mapbox\" | \"terrarium\") {\n        this.uid = uid;\n        if (data.height !== data.width) throw new RangeError('DEM tiles must be square');\n        if (encoding && encoding !== \"mapbox\" && encoding !== \"terrarium\") return warnOnce(\n            `\"${encoding}\" is not a valid encoding type. Valid types include \"mapbox\" and \"terrarium\".`\n        );\n        const dim = this.dim = data.height;\n        this.stride = this.dim + 2;\n        this.data = new Int32Array(this.stride * this.stride);\n\n        const pixels = data.data;\n        const unpack = encoding === \"terrarium\" ? this._unpackTerrarium : this._unpackMapbox;\n        for (let y = 0; y < dim; y++) {\n            for (let x = 0; x < dim; x++) {\n                const i = y * dim + x;\n                const j = i * 4;\n                this.set(x, y, unpack(pixels[j], pixels[j + 1], pixels[j + 2]));\n            }\n        }\n\n        // in order to avoid flashing seams between tiles, here we are initially populating a 1px border of pixels around the image\n        // with the data of the nearest pixel from the image. this data is eventually replaced when the tile's neighboring\n        // tiles are loaded and the accurate data can be backfilled using DEMData#backfillBorder\n        for (let x = 0; x < dim; x++) {\n            // left vertical border\n            this.set(-1, x, this.get(0, x));\n            // right vertical border\n            this.set(dim, x, this.get(dim - 1, x));\n            // left horizontal border\n            this.set(x, -1, this.get(x, 0));\n            // right horizontal border\n            this.set(x, dim, this.get(x, dim - 1));\n        }\n        // corners\n        this.set(-1, -1, this.get(0, 0));\n        this.set(dim, -1, this.get(dim - 1, 0));\n        this.set(-1, dim, this.get(0, dim - 1));\n        this.set(dim, dim, this.get(dim - 1, dim - 1));\n    }\n\n    set(x: number, y: number, value: number) {\n        this.data[this._idx(x, y)] = value + 65536;\n    }\n\n    get(x: number, y: number) {\n        return this.data[this._idx(x, y)] - 65536;\n    }\n\n    _idx(x: number, y: number) {\n        if (x < -1 || x >= this.dim + 1 ||  y < -1 || y >= this.dim + 1) throw new RangeError('out of range source coordinates for DEM data');\n        return (y + 1) * this.stride + (x + 1);\n    }\n\n    _unpackMapbox(r: number, g: number, b: number) {\n        // unpacking formula for mapbox.terrain-rgb:\n        // https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb\n        return ((r * 256 * 256 + g * 256.0 + b) / 10.0 - 10000.0);\n    }\n\n    _unpackTerrarium(r: number, g: number, b: number) {\n        // unpacking formula for mapzen terrarium:\n        // https://aws.amazon.com/public-datasets/terrain/\n        return ((r * 256 + g + b / 256) - 32768.0);\n    }\n\n    getPixels() {\n        return new RGBAImage({width: this.stride, height: this.stride}, new Uint8Array(this.data.buffer));\n    }\n\n    backfillBorder(borderTile: DEMData, dx: number, dy: number) {\n        if (this.dim !== borderTile.dim) throw new Error('dem dimension mismatch');\n\n        let xMin = dx * this.dim,\n            xMax = dx * this.dim + this.dim,\n            yMin = dy * this.dim,\n            yMax = dy * this.dim + this.dim;\n\n        switch (dx) {\n        case -1:\n            xMin = xMax - 1;\n            break;\n        case 1:\n            xMax = xMin + 1;\n            break;\n        }\n\n        switch (dy) {\n        case -1:\n            yMin = yMax - 1;\n            break;\n        case 1:\n            yMax = yMin + 1;\n            break;\n        }\n\n        const ox = -dx * this.dim;\n        const oy = -dy * this.dim;\n        for (let y = yMin; y < yMax; y++) {\n            for (let x = xMin; x < xMax; x++) {\n                this.set(x, y, borderTile.get(x + ox, y + oy));\n            }\n        }\n    }\n}\n\nregister('DEMData', DEMData);\n","// @flow\n\nimport assert from 'assert';\n\nclass DictionaryCoder {\n    _stringToNumber: { [string]: number };\n    _numberToString: Array<string>;\n\n    constructor(strings: Array<string>) {\n        this._stringToNumber = {};\n        this._numberToString = [];\n        for (let i = 0; i < strings.length; i++) {\n            const string = strings[i];\n            this._stringToNumber[string] = i;\n            this._numberToString[i] = string;\n        }\n    }\n\n    encode(string: string) {\n        assert(string in this._stringToNumber);\n        return this._stringToNumber[string];\n    }\n\n    decode(n: number) {\n        assert(n < this._numberToString.length);\n        return this._numberToString[n];\n    }\n}\n\nexport default DictionaryCoder;\n","// @flow\nimport type {GeoJSONGeometry} from '@mapbox/geojson-types';\n\nclass Feature {\n    type: 'Feature';\n    _geometry: ?GeoJSONGeometry;\n    properties: {};\n    id: number | string | void;\n\n    _vectorTileFeature: VectorTileFeature;\n\n    constructor(vectorTileFeature: VectorTileFeature, z: number, x: number, y: number) {\n        this.type = 'Feature';\n\n        this._vectorTileFeature = vectorTileFeature;\n        (vectorTileFeature: any)._z = z;\n        (vectorTileFeature: any)._x = x;\n        (vectorTileFeature: any)._y = y;\n\n        this.properties = vectorTileFeature.properties;\n\n        if (vectorTileFeature.id != null) {\n            this.id = vectorTileFeature.id;\n        }\n    }\n\n    get geometry(): ?GeoJSONGeometry {\n        if (this._geometry === undefined) {\n            this._geometry = this._vectorTileFeature.toGeoJSON(\n                (this._vectorTileFeature: any)._x,\n                (this._vectorTileFeature: any)._y,\n                (this._vectorTileFeature: any)._z).geometry;\n        }\n        return this._geometry;\n    }\n\n    set geometry(g: ?GeoJSONGeometry) {\n        this._geometry = g;\n    }\n\n    toJSON() {\n        const json = {\n            geometry: this.geometry\n        };\n        for (const i in this) {\n            if (i === '_geometry' || i === '_vectorTileFeature') continue;\n            json[i] = (this: any)[i];\n        }\n        return json;\n    }\n}\n\nexport default Feature;\n","// @flow\n\nimport { extend } from '../util/util';\nimport Tile from './tile';\nimport type {FeatureState} from '../style-spec/expression';\n\nexport type FeatureStates = {[feature_id: string]: FeatureState};\nexport type LayerFeatureStates = {[layer: string]: FeatureStates};\n\n/**\n * SourceFeatureState manages the state and pending changes\n * to features in a source, separated by source layer.\n * stateChanges and deletedStates batch all changes to the tile (updates and removes, respectively)\n * between coalesce() events. addFeatureState() and removeFeatureState() also update their counterpart's\n * list of changes, such that coalesce() can apply the proper state changes while agnostic to the order of operations.\n * In deletedStates, all null's denote complete removal of state at that scope\n * @private\n*/\nclass SourceFeatureState {\n    state: LayerFeatureStates;\n    stateChanges: LayerFeatureStates;\n    deletedStates: {};\n\n    constructor() {\n        this.state = {};\n        this.stateChanges = {};\n        this.deletedStates = {};\n    }\n\n    updateState(sourceLayer: string, featureId: number, newState: Object) {\n        const feature = String(featureId);\n        this.stateChanges[sourceLayer] = this.stateChanges[sourceLayer] || {};\n        this.stateChanges[sourceLayer][feature] = this.stateChanges[sourceLayer][feature] || {};\n        extend(this.stateChanges[sourceLayer][feature], newState);\n\n        if (this.deletedStates[sourceLayer] === null) {\n            this.deletedStates[sourceLayer] = {};\n            for (const ft in this.state[sourceLayer]) {\n                if (ft !== feature) this.deletedStates[sourceLayer][ft] = null;\n            }\n        } else {\n            const featureDeletionQueued = this.deletedStates[sourceLayer] && this.deletedStates[sourceLayer][feature] === null;\n            if (featureDeletionQueued) {\n                this.deletedStates[sourceLayer][feature] = {};\n                for (const prop in this.state[sourceLayer][feature]) {\n                    if (!newState[prop]) this.deletedStates[sourceLayer][feature][prop] = null;\n                }\n            } else {\n                for (const key in newState) {\n                    const deletionInQueue = this.deletedStates[sourceLayer] && this.deletedStates[sourceLayer][feature] && this.deletedStates[sourceLayer][feature][key] === null;\n                    if (deletionInQueue) delete this.deletedStates[sourceLayer][feature][key];\n                }\n            }\n        }\n    }\n\n    removeFeatureState(sourceLayer: string, featureId?: number, key?: string) {\n        const sourceLayerDeleted = this.deletedStates[sourceLayer] === null;\n        if (sourceLayerDeleted) return;\n\n        const feature = String(featureId);\n\n        this.deletedStates[sourceLayer] = this.deletedStates[sourceLayer] || {};\n\n        if (key && featureId) {\n            if (this.deletedStates[sourceLayer][feature] !== null) {\n                this.deletedStates[sourceLayer][feature] = this.deletedStates[sourceLayer][feature] || {};\n                this.deletedStates[sourceLayer][feature][key] = null;\n            }\n        } else if (featureId) {\n            const updateInQueue = this.stateChanges[sourceLayer] && this.stateChanges[sourceLayer][feature];\n            if (updateInQueue) {\n                this.deletedStates[sourceLayer][feature] = {};\n                for (key in this.stateChanges[sourceLayer][feature]) this.deletedStates[sourceLayer][feature][key] = null;\n\n            } else {\n                this.deletedStates[sourceLayer][feature] = null;\n            }\n        } else {\n            this.deletedStates[sourceLayer] = null;\n        }\n\n    }\n\n    getState(sourceLayer: string, featureId: number) {\n        const feature = String(featureId);\n        const base = this.state[sourceLayer] || {};\n        const changes = this.stateChanges[sourceLayer] || {};\n\n        const reconciledState = extend({}, base[feature], changes[feature]);\n\n        //return empty object if the whole source layer is awaiting deletion\n        if (this.deletedStates[sourceLayer] === null) return {};\n        else if (this.deletedStates[sourceLayer]) {\n            const featureDeletions = this.deletedStates[sourceLayer][featureId];\n            if (featureDeletions === null) return {};\n            for (const prop in featureDeletions) delete reconciledState[prop];\n        }\n        return reconciledState;\n    }\n\n    initializeTileState(tile: Tile, painter: any) {\n        tile.setFeatureState(this.state, painter);\n    }\n\n    coalesceChanges(tiles: {[any]: Tile}, painter: any) {\n        //track changes with full state objects, but only for features that got modified\n        const featuresChanged: LayerFeatureStates = {};\n\n        for (const sourceLayer in this.stateChanges) {\n            this.state[sourceLayer]  = this.state[sourceLayer] || {};\n            const layerStates = {};\n            for (const feature in this.stateChanges[sourceLayer]) {\n                if (!this.state[sourceLayer][feature]) this.state[sourceLayer][feature] = {};\n                extend(this.state[sourceLayer][feature], this.stateChanges[sourceLayer][feature]);\n                layerStates[feature] = this.state[sourceLayer][feature];\n            }\n            featuresChanged[sourceLayer] = layerStates;\n        }\n\n        for (const sourceLayer in this.deletedStates) {\n            this.state[sourceLayer]  = this.state[sourceLayer] || {};\n            const layerStates = {};\n\n            if (this.deletedStates[sourceLayer] === null) {\n                for (const ft in this.state[sourceLayer]) layerStates[ft] = {};\n                this.state[sourceLayer] = {};\n            } else {\n                for (const feature in this.deletedStates[sourceLayer]) {\n                    const deleteWholeFeatureState = this.deletedStates[sourceLayer][feature] === null;\n                    if (deleteWholeFeatureState) this.state[sourceLayer][feature] = {};\n                    else {\n                        for (const key of Object.keys(this.deletedStates[sourceLayer][feature])) {\n                            delete this.state[sourceLayer][feature][key];\n                        }\n                    }\n                    layerStates[feature] = this.state[sourceLayer][feature];\n                }\n            }\n\n            featuresChanged[sourceLayer] = featuresChanged[sourceLayer] || {};\n            extend(featuresChanged[sourceLayer], layerStates);\n        }\n\n        this.stateChanges = {};\n        this.deletedStates = {};\n\n        if (Object.keys(featuresChanged).length === 0) return;\n\n        for (const id in tiles) {\n            const tile = tiles[id];\n            tile.setFeatureState(featuresChanged, painter);\n        }\n    }\n}\n\nexport default SourceFeatureState;\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport loadGeometry from './load_geometry';\nimport EXTENT from './extent';\nimport featureFilter from '../style-spec/feature_filter';\nimport Grid from 'grid-index';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport vt from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport GeoJSONFeature from '../util/vectortile_to_geojson';\nimport { arraysIntersect } from '../util/util';\nimport { OverscaledTileID } from '../source/tile_id';\nimport { register } from '../util/web_worker_transfer';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport SourceFeatureState from '../source/source_state';\nimport {polygonIntersectsBox} from '../util/intersection_tests';\n\nimport type StyleLayer from '../style/style_layer';\nimport type {FeatureFilter} from '../style-spec/feature_filter';\nimport type Transform from '../geo/transform';\nimport type {FilterSpecification} from '../style-spec/types';\n\nimport { FeatureIndexArray } from './array_types';\n\ntype QueryParameters = {\n    scale: number,\n    pixelPosMatrix: Float32Array,\n    transform: Transform,\n    tileSize: number,\n    queryGeometry: Array<Point>,\n    cameraQueryGeometry: Array<Point>,\n    queryPadding: number,\n    params: {\n        filter: FilterSpecification,\n        layers: Array<string>,\n    }\n}\n\nclass FeatureIndex {\n    tileID: OverscaledTileID;\n    x: number;\n    y: number;\n    z: number;\n    grid: Grid;\n    grid3D: Grid;\n    featureIndexArray: FeatureIndexArray;\n\n    rawTileData: ArrayBuffer;\n    bucketLayerIDs: Array<Array<string>>;\n\n    vtLayers: {[string]: VectorTileLayer};\n    sourceLayerCoder: DictionaryCoder;\n\n    constructor(tileID: OverscaledTileID,\n                grid?: Grid,\n                featureIndexArray?: FeatureIndexArray) {\n        this.tileID = tileID;\n        this.x = tileID.canonical.x;\n        this.y = tileID.canonical.y;\n        this.z = tileID.canonical.z;\n        this.grid = grid || new Grid(EXTENT, 16, 0);\n        this.grid3D = new Grid(EXTENT, 16, 0);\n        this.featureIndexArray = featureIndexArray || new FeatureIndexArray();\n    }\n\n    insert(feature: VectorTileFeature, geometry: Array<Array<Point>>, featureIndex: number, sourceLayerIndex: number, bucketIndex: number, is3D?: boolean) {\n        const key = this.featureIndexArray.length;\n        this.featureIndexArray.emplaceBack(featureIndex, sourceLayerIndex, bucketIndex);\n\n        const grid = is3D ? this.grid3D : this.grid;\n\n        for (let r = 0; r < geometry.length; r++) {\n            const ring = geometry[r];\n\n            const bbox = [Infinity, Infinity, -Infinity, -Infinity];\n            for (let i = 0; i < ring.length; i++) {\n                const p = ring[i];\n                bbox[0] = Math.min(bbox[0], p.x);\n                bbox[1] = Math.min(bbox[1], p.y);\n                bbox[2] = Math.max(bbox[2], p.x);\n                bbox[3] = Math.max(bbox[3], p.y);\n            }\n\n            if (bbox[0] < EXTENT &&\n                bbox[1] < EXTENT &&\n                bbox[2] >= 0 &&\n                bbox[3] >= 0) {\n                grid.insert(key, bbox[0], bbox[1], bbox[2], bbox[3]);\n            }\n        }\n    }\n\n    loadVTLayers(): {[string]: VectorTileLayer} {\n        if (!this.vtLayers) {\n            this.vtLayers = new vt.VectorTile(new Protobuf(this.rawTileData)).layers;\n            this.sourceLayerCoder = new DictionaryCoder(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer']);\n        }\n        return this.vtLayers;\n    }\n\n    // Finds non-symbol features in this tile at a particular position.\n    query(args: QueryParameters, styleLayers: {[string]: StyleLayer}, sourceFeatureState: SourceFeatureState): {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>} {\n        this.loadVTLayers();\n\n        const params = args.params || {},\n            pixelsToTileUnits = EXTENT / args.tileSize / args.scale,\n            filter = featureFilter(params.filter);\n\n        const queryGeometry = args.queryGeometry;\n        const queryPadding = args.queryPadding * pixelsToTileUnits;\n\n        const bounds = getBounds(queryGeometry);\n        const matching = this.grid.query(bounds.minX - queryPadding, bounds.minY - queryPadding, bounds.maxX + queryPadding, bounds.maxY + queryPadding);\n\n        const cameraBounds = getBounds(args.cameraQueryGeometry);\n        const matching3D = this.grid3D.query(\n                cameraBounds.minX - queryPadding, cameraBounds.minY - queryPadding, cameraBounds.maxX + queryPadding, cameraBounds.maxY + queryPadding,\n                (bx1, by1, bx2, by2) => {\n                    return polygonIntersectsBox(args.cameraQueryGeometry, bx1 - queryPadding, by1 - queryPadding, bx2 + queryPadding, by2 + queryPadding);\n                });\n\n        for (const key of matching3D) {\n            matching.push(key);\n        }\n\n        matching.sort(topDownFeatureComparator);\n\n        const result = {};\n        let previousIndex;\n        for (let k = 0; k < matching.length; k++) {\n            const index = matching[k];\n\n            // don't check the same feature more than once\n            if (index === previousIndex) continue;\n            previousIndex = index;\n\n            const match = this.featureIndexArray.get(index);\n            let featureGeometry = null;\n            this.loadMatchingFeature(\n                result,\n                match.bucketIndex,\n                match.sourceLayerIndex,\n                match.featureIndex,\n                filter,\n                params.layers,\n                styleLayers,\n                (feature: VectorTileFeature, styleLayer: StyleLayer) => {\n                    if (!featureGeometry) {\n                        featureGeometry = loadGeometry(feature);\n                    }\n                    let featureState = {};\n                    if (feature.id) {\n                        // `feature-state` expression evaluation requires feature state to be available\n                        featureState = sourceFeatureState.getState(styleLayer.sourceLayer || '_geojsonTileLayer', feature.id);\n                    }\n                    return styleLayer.queryIntersectsFeature(queryGeometry, feature, featureState, featureGeometry, this.z, args.transform, pixelsToTileUnits, args.pixelPosMatrix);\n                }\n            );\n        }\n\n        return result;\n    }\n\n    loadMatchingFeature(\n        result: {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>},\n        bucketIndex: number,\n        sourceLayerIndex: number,\n        featureIndex: number,\n        filter: FeatureFilter,\n        filterLayerIDs: Array<string>,\n        styleLayers: {[string]: StyleLayer},\n        intersectionTest?: (feature: VectorTileFeature, styleLayer: StyleLayer) => boolean | number) {\n\n        const layerIDs = this.bucketLayerIDs[bucketIndex];\n        if (filterLayerIDs && !arraysIntersect(filterLayerIDs, layerIDs))\n            return;\n\n        const sourceLayerName = this.sourceLayerCoder.decode(sourceLayerIndex);\n        const sourceLayer = this.vtLayers[sourceLayerName];\n        const feature = sourceLayer.feature(featureIndex);\n\n        if (!filter(new EvaluationParameters(this.tileID.overscaledZ), feature))\n            return;\n\n        for (let l = 0; l < layerIDs.length; l++) {\n            const layerID = layerIDs[l];\n\n            if (filterLayerIDs && filterLayerIDs.indexOf(layerID) < 0) {\n                continue;\n            }\n\n            const styleLayer = styleLayers[layerID];\n            if (!styleLayer) continue;\n\n            const intersectionZ = !intersectionTest || intersectionTest(feature, styleLayer);\n            if (!intersectionZ) {\n                // Only applied for non-symbol features\n                continue;\n            }\n\n            const geojsonFeature = new GeoJSONFeature(feature, this.z, this.x, this.y);\n            (geojsonFeature: any).layer = styleLayer.serialize();\n            let layerResult = result[layerID];\n            if (layerResult === undefined) {\n                layerResult = result[layerID] = [];\n            }\n            layerResult.push({ featureIndex, feature: geojsonFeature, intersectionZ });\n        }\n    }\n\n    // Given a set of symbol indexes that have already been looked up,\n    // return a matching set of GeoJSONFeatures\n    lookupSymbolFeatures(symbolFeatureIndexes: Array<number>,\n                         bucketIndex: number,\n                         sourceLayerIndex: number,\n                         filterSpec: FilterSpecification,\n                         filterLayerIDs: Array<string>,\n                         styleLayers: {[string]: StyleLayer}) {\n        const result = {};\n        this.loadVTLayers();\n\n        const filter = featureFilter(filterSpec);\n\n        for (const symbolFeatureIndex of symbolFeatureIndexes) {\n            this.loadMatchingFeature(\n                result,\n                bucketIndex,\n                sourceLayerIndex,\n                symbolFeatureIndex,\n                filter,\n                filterLayerIDs,\n                styleLayers\n            );\n\n        }\n        return result;\n    }\n\n    hasLayer(id: string) {\n        for (const layerIDs of this.bucketLayerIDs) {\n            for (const layerID of layerIDs) {\n                if (id === layerID) return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nregister(\n    'FeatureIndex',\n    FeatureIndex,\n    { omit: ['rawTileData', 'sourceLayerCoder'] }\n);\n\nexport default FeatureIndex;\n\nfunction getBounds(geometry: Array<Point>) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (const p of geometry) {\n        minX = Math.min(minX, p.x);\n        minY = Math.min(minY, p.y);\n        maxX = Math.max(maxX, p.x);\n        maxY = Math.max(maxY, p.y);\n    }\n    return { minX, minY, maxX, maxY };\n}\n\nfunction topDownFeatureComparator(a, b) {\n    return b - a;\n}\n","// @flow\n\nimport UnitBezier from '@mapbox/unitbezier';\n\nimport Point from '@mapbox/point-geometry';\nimport window from './window';\n\nimport type {Callback} from '../types/callback';\n\n/**\n * @module util\n * @private\n */\n\n/**\n * Given a value `t` that varies between 0 and 1, return\n * an interpolation function that eases between 0 and 1 in a pleasing\n * cubic in-out fashion.\n *\n * @private\n */\nexport function easeCubicInOut(t: number): number {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    const t2 = t * t,\n        t3 = t2 * t;\n    return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);\n}\n\n/**\n * Given given (x, y), (x1, y1) control points for a bezier curve,\n * return a function that interpolates along that curve.\n *\n * @param p1x control point 1 x coordinate\n * @param p1y control point 1 y coordinate\n * @param p2x control point 2 x coordinate\n * @param p2y control point 2 y coordinate\n * @private\n */\nexport function bezier(p1x: number, p1y: number, p2x: number, p2y: number): (t: number) => number {\n    const bezier = new UnitBezier(p1x, p1y, p2x, p2y);\n    return function(t: number) {\n        return bezier.solve(t);\n    };\n}\n\n/**\n * A default bezier-curve powered easing function with\n * control points (0.25, 0.1) and (0.25, 1)\n *\n * @private\n */\nexport const ease = bezier(0.25, 0.1, 0.25, 1);\n\n/**\n * constrain n to the given range via min + max\n *\n * @param n value\n * @param min the minimum value to be returned\n * @param max the maximum value to be returned\n * @returns the clamped value\n * @private\n */\nexport function clamp(n: number, min: number, max: number): number {\n    return Math.min(max, Math.max(min, n));\n}\n\n/**\n * constrain n to the given range, excluding the minimum, via modular arithmetic\n *\n * @param n value\n * @param min the minimum value to be returned, exclusive\n * @param max the maximum value to be returned, inclusive\n * @returns constrained number\n * @private\n */\nexport function wrap(n: number, min: number, max: number): number {\n    const d = max - min;\n    const w = ((n - min) % d + d) % d + min;\n    return (w === min) ? max : w;\n}\n\n/*\n * Call an asynchronous function on an array of arguments,\n * calling `callback` with the completed results of all calls.\n *\n * @param array input to each call of the async function.\n * @param fn an async function with signature (data, callback)\n * @param callback a callback run after all async work is done.\n * called with an array, containing the results of each async call.\n * @private\n */\nexport function asyncAll<Item, Result>(\n    array: Array<Item>,\n    fn: (item: Item, fnCallback: Callback<Result>) => void,\n    callback: Callback<Array<Result>>\n) {\n    if (!array.length) { return callback(null, []); }\n    let remaining = array.length;\n    const results = new Array(array.length);\n    let error = null;\n    array.forEach((item, i) => {\n        fn(item, (err, result) => {\n            if (err) error = err;\n            results[i] = ((result: any): Result); // https://github.com/facebook/flow/issues/2123\n            if (--remaining === 0) callback(error, results);\n        });\n    });\n}\n\n/*\n * Polyfill for Object.values. Not fully spec compliant, but we don't\n * need it to be.\n *\n * @private\n */\nexport function values<T>(obj: {[key: string]: T}): Array<T> {\n    const result = [];\n    for (const k in obj) {\n        result.push(obj[k]);\n    }\n    return result;\n}\n\n/*\n * Compute the difference between the keys in one object and the keys\n * in another object.\n *\n * @returns keys difference\n * @private\n */\nexport function keysDifference<S, T>(obj: {[key: string]: S}, other: {[key: string]: T}): Array<string> {\n    const difference = [];\n    for (const i in obj) {\n        if (!(i in other)) {\n            difference.push(i);\n        }\n    }\n    return difference;\n}\n\n/**\n * Given a destination object and optionally many source objects,\n * copy all properties from the source objects into the destination.\n * The last source object given overrides properties from previous\n * source objects.\n *\n * @param dest destination object\n * @param sources sources from which properties are pulled\n * @private\n */\nexport function extend(dest: Object, ...sources: Array<?Object>): Object {\n    for (const src of sources) {\n        for (const k in src) {\n            dest[k] = src[k];\n        }\n    }\n    return dest;\n}\n\n/**\n * Given an object and a number of properties as strings, return version\n * of that object with only those properties.\n *\n * @param src the object\n * @param properties an array of property names chosen\n * to appear on the resulting object.\n * @returns object with limited properties.\n * @example\n * var foo = { name: 'Charlie', age: 10 };\n * var justName = pick(foo, ['name']);\n * // justName = { name: 'Charlie' }\n * @private\n */\nexport function pick(src: Object, properties: Array<string>): Object {\n    const result = {};\n    for (let i = 0; i < properties.length; i++) {\n        const k = properties[i];\n        if (k in src) {\n            result[k] = src[k];\n        }\n    }\n    return result;\n}\n\nlet id = 1;\n\n/**\n * Return a unique numeric id, starting at 1 and incrementing with\n * each call.\n *\n * @returns unique numeric id.\n * @private\n */\nexport function uniqueId(): number {\n    return id++;\n}\n\n/**\n * Return a random UUID (v4). Taken from: https://gist.github.com/jed/982883\n * @private\n */\nexport function uuid(): string {\n    function b(a) {\n        return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) :\n        //$FlowFixMe: Flow doesn't like the implied array literal conversion here\n            ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, b);\n    }\n    return b();\n}\n\n/**\n * Validate a string to match UUID(v4) of the\n * form: xxxxxxxx-xxxx-4xxx-[89ab]xxx-xxxxxxxxxxxx\n * @param str string to validate.\n * @private\n */\nexport function validateUuid(str: ?string): boolean {\n    return str ? /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(str) : false;\n}\n\n/**\n * Given an array of member function names as strings, replace all of them\n * with bound versions that will always refer to `context` as `this`. This\n * is useful for classes where otherwise event bindings would reassign\n * `this` to the evented object or some other value: this lets you ensure\n * the `this` value always.\n *\n * @param fns list of member function names\n * @param context the context value\n * @example\n * function MyClass() {\n *   bindAll(['ontimer'], this);\n *   this.name = 'Tom';\n * }\n * MyClass.prototype.ontimer = function() {\n *   alert(this.name);\n * };\n * var myClass = new MyClass();\n * setTimeout(myClass.ontimer, 100);\n * @private\n */\nexport function bindAll(fns: Array<string>, context: Object): void {\n    fns.forEach((fn) => {\n        if (!context[fn]) { return; }\n        context[fn] = context[fn].bind(context);\n    });\n}\n\n/**\n * Determine if a string ends with a particular substring\n *\n * @private\n */\nexport function endsWith(string: string, suffix: string): boolean {\n    return string.indexOf(suffix, string.length - suffix.length) !== -1;\n}\n\n/**\n * Create an object by mapping all the values of an existing object while\n * preserving their keys.\n *\n * @private\n */\nexport function mapObject(input: Object, iterator: Function, context?: Object): Object {\n    const output = {};\n    for (const key in input) {\n        output[key] = iterator.call(context || this, input[key], key, input);\n    }\n    return output;\n}\n\n/**\n * Create an object by filtering out values of an existing object.\n *\n * @private\n */\nexport function filterObject(input: Object, iterator: Function, context?: Object): Object {\n    const output = {};\n    for (const key in input) {\n        if (iterator.call(context || this, input[key], key, input)) {\n            output[key] = input[key];\n        }\n    }\n    return output;\n}\n\nimport deepEqual from '../style-spec/util/deep_equal';\nexport { deepEqual };\n\n/**\n * Deeply clones two objects.\n *\n * @private\n */\nexport function clone<T>(input: T): T {\n    if (Array.isArray(input)) {\n        return input.map(clone);\n    } else if (typeof input === 'object' && input) {\n        return ((mapObject(input, clone): any): T);\n    } else {\n        return input;\n    }\n}\n\n/**\n * Check if two arrays have at least one common element.\n *\n * @private\n */\nexport function arraysIntersect<T>(a: Array<T>, b: Array<T>): boolean {\n    for (let l = 0; l < a.length; l++) {\n        if (b.indexOf(a[l]) >= 0) return true;\n    }\n    return false;\n}\n\n/**\n * Print a warning message to the console and ensure duplicate warning messages\n * are not printed.\n *\n * @private\n */\nconst warnOnceHistory: {[key: string]: boolean} = {};\n\nexport function warnOnce(message: string): void {\n    if (!warnOnceHistory[message]) {\n        // console isn't defined in some WebWorkers, see #2558\n        if (typeof console !== \"undefined\") console.warn(message);\n        warnOnceHistory[message] = true;\n    }\n}\n\n/**\n * Indicates if the provided Points are in a counter clockwise (true) or clockwise (false) order\n *\n * @private\n * @returns true for a counter clockwise set of points\n */\n// http://bryceboe.com/2006/10/23/line-segment-intersection-algorithm/\nexport function isCounterClockwise(a: Point, b: Point, c: Point): boolean {\n    return (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);\n}\n\n/**\n * Returns the signed area for the polygon ring.  Postive areas are exterior rings and\n * have a clockwise winding.  Negative areas are interior rings and have a counter clockwise\n * ordering.\n *\n * @private\n * @param ring Exterior or interior ring\n */\nexport function calculateSignedArea(ring: Array<Point>): number {\n    let sum = 0;\n    for (let i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n\n/**\n * Detects closed polygons, first + last point are equal\n *\n * @private\n * @param points array of points\n * @return true if the points are a closed polygon\n */\nexport function isClosedPolygon(points: Array<Point>): boolean {\n    // If it is 2 points that are the same then it is a point\n    // If it is 3 points with start and end the same then it is a line\n    if (points.length < 4)\n        return false;\n\n    const p1 = points[0];\n    const p2 = points[points.length - 1];\n\n    if (Math.abs(p1.x - p2.x) > 0 ||\n        Math.abs(p1.y - p2.y) > 0) {\n        return false;\n    }\n\n    // polygon simplification can produce polygons with zero area and more than 3 points\n    return Math.abs(calculateSignedArea(points)) > 0.01;\n}\n\n/**\n * Converts spherical coordinates to cartesian coordinates.\n *\n * @private\n * @param spherical Spherical coordinates, in [radial, azimuthal, polar]\n * @return cartesian coordinates in [x, y, z]\n */\n\nexport function sphericalToCartesian([r, azimuthal, polar]: [number, number, number]): {x: number, y: number, z: number} {\n    // We abstract \"north\"/\"up\" (compass-wise) to be 0 when really this is 90 (/2):\n    // correct for that here\n    azimuthal += 90;\n\n    // Convert azimuthal and polar angles to radians\n    azimuthal *= Math.PI / 180;\n    polar *= Math.PI / 180;\n\n    return {\n        x: r * Math.cos(azimuthal) * Math.sin(polar),\n        y: r * Math.sin(azimuthal) * Math.sin(polar),\n        z: r * Math.cos(polar)\n    };\n}\n\n/**\n * Parses data from 'Cache-Control' headers.\n *\n * @private\n * @param cacheControl Value of 'Cache-Control' header\n * @return object containing parsed header info.\n */\n\nexport function parseCacheControl(cacheControl: string): Object {\n    // Taken from [Wreck](https://github.com/hapijs/wreck)\n    const re = /(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g;\n\n    const header = {};\n    cacheControl.replace(re, ($0, $1, $2, $3) => {\n        const value = $2 || $3;\n        header[$1] = value ? value.toLowerCase() : true;\n        return '';\n    });\n\n    if (header['max-age']) {\n        const maxAge = parseInt(header['max-age'], 10);\n        if (isNaN(maxAge)) delete header['max-age'];\n        else header['max-age'] = maxAge;\n    }\n\n    return header;\n}\n\nexport function storageAvailable(type: string): boolean {\n    try {\n        const storage = window[type];\n        storage.setItem('_mapbox_test_', 1);\n        storage.removeItem('_mapbox_test_');\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\n// The following methods are from https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n//Unicode compliant base64 encoder for strings\nexport function b64EncodeUnicode(str: string) {\n    return window.btoa(\n        encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,\n            (match, p1) => {\n                return String.fromCharCode(Number('0x' + p1)); //eslint-disable-line\n            }\n        )\n    );\n}\n\n\n// Unicode compliant decoder for base64-encoded strings\nexport function b64DecodeUnicode(str: string) {\n    return decodeURIComponent(window.atob(str).split('').map((c) => {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); //eslint-disable-line\n    }).join(''));\n}\n","// @flow\n\nimport { uniqueId, deepEqual, parseCacheControl } from '../util/util';\nimport { deserialize as deserializeBucket } from '../data/bucket';\nimport FeatureIndex from '../data/feature_index';\nimport GeoJSONFeature from '../util/vectortile_to_geojson';\nimport featureFilter from '../style-spec/feature_filter';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport { RasterBoundsArray, CollisionBoxArray } from '../data/array_types';\nimport rasterBoundsAttributes from '../data/raster_bounds_attributes';\nimport EXTENT from '../data/extent';\nimport Point from '@mapbox/point-geometry';\nimport Texture from '../render/texture';\nimport SegmentVector from '../data/segment';\nimport { TriangleIndexArray } from '../data/index_array_type';\nimport browser from '../util/browser';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport SourceFeatureState from '../source/source_state';\n\nconst CLOCK_SKEW_RETRY_TIMEOUT = 30000;\n\nimport type {Bucket} from '../data/bucket';\nimport type StyleLayer from '../style/style_layer';\nimport type {WorkerTileResult} from './worker_source';\nimport type DEMData from '../data/dem_data';\nimport type {AlphaImage} from '../util/image';\nimport type ImageAtlas from '../render/image_atlas';\nimport type Mask from '../render/tile_mask';\nimport type Context from '../gl/context';\nimport type IndexBuffer from '../gl/index_buffer';\nimport type VertexBuffer from '../gl/vertex_buffer';\nimport type {OverscaledTileID} from './tile_id';\nimport type Framebuffer from '../gl/framebuffer';\nimport type {PerformanceResourceTiming} from '../types/performance_resource_timing';\nimport type Transform from '../geo/transform';\nimport type {LayerFeatureStates} from './source_state';\nimport type {Cancelable} from '../types/cancelable';\nimport type {FilterSpecification} from '../style-spec/types';\n\nexport type TileState =\n    | 'loading'   // Tile data is in the process of loading.\n    | 'loaded'    // Tile data has been loaded. Tile can be rendered.\n    | 'reloading' // Tile data has been loaded and is being updated. Tile can be rendered.\n    | 'unloaded'  // Tile data has been deleted.\n    | 'errored'   // Tile data was not loaded because of an error.\n    | 'expired';  /* Tile data was previously loaded, but has expired per its\n                   * HTTP headers and is in the process of refreshing. */\n\n/**\n * A tile object is the combination of a Coordinate, which defines\n * its place, as well as a unique ID and data tracking for its content\n *\n * @private\n */\nclass Tile {\n    tileID: OverscaledTileID;\n    uid: number;\n    uses: number;\n    tileSize: number;\n    buckets: {[string]: Bucket};\n    latestFeatureIndex: ?FeatureIndex;\n    latestRawTileData: ?ArrayBuffer;\n    imageAtlas: ?ImageAtlas;\n    imageAtlasTexture: Texture;\n    glyphAtlasImage: ?AlphaImage;\n    glyphAtlasTexture: Texture;\n    expirationTime: any;\n    expiredRequestCount: number;\n    state: TileState;\n    timeAdded: any;\n    fadeEndTime: any;\n    collisionBoxArray: ?CollisionBoxArray;\n    redoWhenDone: boolean;\n    showCollisionBoxes: boolean;\n    placementSource: any;\n    workerID: number | void;\n    vtLayers: {[string]: VectorTileLayer};\n    mask: Mask;\n\n    neighboringTiles: ?Object;\n    dem: ?DEMData;\n    aborted: ?boolean;\n    maskedBoundsBuffer: ?VertexBuffer;\n    maskedIndexBuffer: ?IndexBuffer;\n    segments: ?SegmentVector;\n    needsHillshadePrepare: ?boolean;\n    request: ?Cancelable;\n    texture: any;\n    fbo: ?Framebuffer;\n    demTexture: ?Texture;\n    refreshedUponExpiration: boolean;\n    reloadCallback: any;\n    resourceTiming: ?Array<PerformanceResourceTiming>;\n    queryPadding: number;\n\n    symbolFadeHoldUntil: ?number;\n    hasSymbolBuckets: boolean;\n\n    /**\n     * @param {OverscaledTileID} tileID\n     * @param size\n     */\n    constructor(tileID: OverscaledTileID, size: number) {\n        this.tileID = tileID;\n        this.uid = uniqueId();\n        this.uses = 0;\n        this.tileSize = size;\n        this.buckets = {};\n        this.expirationTime = null;\n        this.queryPadding = 0;\n        this.hasSymbolBuckets = false;\n\n        // Counts the number of times a response was already expired when\n        // received. We're using this to add a delay when making a new request\n        // so we don't have to keep retrying immediately in case of a server\n        // serving expired tiles.\n        this.expiredRequestCount = 0;\n\n        this.state = 'loading';\n    }\n\n    registerFadeDuration(duration: number) {\n        const fadeEndTime = duration + this.timeAdded;\n        if (fadeEndTime < browser.now()) return;\n        if (this.fadeEndTime && fadeEndTime < this.fadeEndTime) return;\n\n        this.fadeEndTime = fadeEndTime;\n    }\n\n    wasRequested() {\n        return this.state === 'errored' || this.state === 'loaded' || this.state === 'reloading';\n    }\n\n    /**\n     * Given a data object with a 'buffers' property, load it into\n     * this tile's elementGroups and buffers properties and set loaded\n     * to true. If the data is null, like in the case of an empty\n     * GeoJSON tile, no-op but still set loaded to true.\n     * @param {Object} data\n     * @param painter\n     * @returns {undefined}\n     * @private\n     */\n    loadVectorData(data: WorkerTileResult, painter: any, justReloaded: ?boolean) {\n        if (this.hasData()) {\n            this.unloadVectorData();\n        }\n\n        this.state = 'loaded';\n\n        // empty GeoJSON tile\n        if (!data) {\n            this.collisionBoxArray = new CollisionBoxArray();\n            return;\n        }\n\n        if (data.featureIndex) {\n            this.latestFeatureIndex = data.featureIndex;\n            if (data.rawTileData) {\n                // Only vector tiles have rawTileData, and they won't update it for\n                // 'reloadTile'\n                this.latestRawTileData = data.rawTileData;\n                this.latestFeatureIndex.rawTileData = data.rawTileData;\n            } else if (this.latestRawTileData) {\n                // If rawTileData hasn't updated, hold onto a pointer to the last\n                // one we received\n                this.latestFeatureIndex.rawTileData = this.latestRawTileData;\n            }\n        }\n        this.collisionBoxArray = data.collisionBoxArray;\n        this.buckets = deserializeBucket(data.buckets, painter.style);\n\n        this.hasSymbolBuckets = false;\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            if (bucket instanceof SymbolBucket) {\n                this.hasSymbolBuckets = true;\n                if (justReloaded) {\n                    bucket.justReloaded = true;\n                } else {\n                    break;\n                }\n            }\n        }\n\n        this.queryPadding = 0;\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));\n        }\n\n        if (data.imageAtlas) {\n            this.imageAtlas = data.imageAtlas;\n        }\n        if (data.glyphAtlasImage) {\n            this.glyphAtlasImage = data.glyphAtlasImage;\n        }\n    }\n\n    /**\n     * Release any data or WebGL resources referenced by this tile.\n     * @returns {undefined}\n     * @private\n     */\n    unloadVectorData() {\n        for (const id in this.buckets) {\n            this.buckets[id].destroy();\n        }\n        this.buckets = {};\n\n        if (this.imageAtlasTexture) {\n            this.imageAtlasTexture.destroy();\n        }\n\n        if (this.imageAtlas) {\n            this.imageAtlas = null;\n        }\n\n        if (this.glyphAtlasTexture) {\n            this.glyphAtlasTexture.destroy();\n        }\n\n        this.latestFeatureIndex = null;\n        this.state = 'unloaded';\n    }\n\n    unloadDEMData() {\n        this.dem = null;\n        this.neighboringTiles = null;\n        this.state = 'unloaded';\n    }\n\n    getBucket(layer: StyleLayer) {\n        return this.buckets[layer.id];\n    }\n\n    upload(context: Context) {\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            if (bucket.uploadPending()) {\n                bucket.upload(context);\n            }\n        }\n\n        const gl = context.gl;\n        if (this.imageAtlas && !this.imageAtlas.uploaded) {\n            this.imageAtlasTexture = new Texture(context, this.imageAtlas.image, gl.RGBA);\n            this.imageAtlas.uploaded = true;\n        }\n\n        if (this.glyphAtlasImage) {\n            this.glyphAtlasTexture = new Texture(context, this.glyphAtlasImage, gl.ALPHA);\n            this.glyphAtlasImage = null;\n        }\n    }\n\n    // Queries non-symbol features rendered for this tile.\n    // Symbol features are queried globally\n    queryRenderedFeatures(layers: {[string]: StyleLayer},\n                          sourceFeatureState: SourceFeatureState,\n                          queryGeometry: Array<Point>,\n                          cameraQueryGeometry: Array<Point>,\n                          scale: number,\n                          params: { filter: FilterSpecification, layers: Array<string> },\n                          transform: Transform,\n                          maxPitchScaleFactor: number,\n                          pixelPosMatrix: Float32Array): {[string]: Array<{ featureIndex: number, feature: GeoJSONFeature }>} {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)\n            return {};\n\n        return this.latestFeatureIndex.query({\n            queryGeometry,\n            cameraQueryGeometry,\n            scale,\n            tileSize: this.tileSize,\n            pixelPosMatrix,\n            transform,\n            params,\n            queryPadding: this.queryPadding * maxPitchScaleFactor\n        }, layers, sourceFeatureState);\n    }\n\n    querySourceFeatures(result: Array<GeoJSONFeature>, params: any) {\n        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;\n\n        const vtLayers = this.latestFeatureIndex.loadVTLayers();\n\n        const sourceLayer = params ? params.sourceLayer : '';\n        const layer = vtLayers._geojsonTileLayer || vtLayers[sourceLayer];\n\n        if (!layer) return;\n\n        const filter = featureFilter(params && params.filter);\n        const {z, x, y} = this.tileID.canonical;\n        const coord = {z, x, y};\n\n        for (let i = 0; i < layer.length; i++) {\n            const feature = layer.feature(i);\n            if (filter(new EvaluationParameters(this.tileID.overscaledZ), feature)) {\n                const geojsonFeature = new GeoJSONFeature(feature, z, x, y);\n                (geojsonFeature: any).tile = coord;\n                result.push(geojsonFeature);\n            }\n        }\n    }\n\n    clearMask() {\n        if (this.segments) {\n            this.segments.destroy();\n            delete this.segments;\n        }\n        if (this.maskedBoundsBuffer) {\n            this.maskedBoundsBuffer.destroy();\n            delete this.maskedBoundsBuffer;\n        }\n        if (this.maskedIndexBuffer) {\n            this.maskedIndexBuffer.destroy();\n            delete this.maskedIndexBuffer;\n        }\n    }\n\n    setMask(mask: Mask, context: Context) {\n\n        // don't redo buffer work if the mask is the same;\n        if (deepEqual(this.mask, mask)) return;\n\n        this.mask = mask;\n        this.clearMask();\n\n        // We want to render the full tile, and keeping the segments/vertices/indices empty means\n        // using the global shared buffers for covering the entire tile.\n        if (deepEqual(mask, {'0': true})) return;\n\n        const maskedBoundsArray = new RasterBoundsArray();\n        const indexArray = new TriangleIndexArray();\n\n        this.segments = new SegmentVector();\n        // Create a new segment so that we will upload (empty) buffers even when there is nothing to\n        // draw for this tile.\n        this.segments.prepareSegment(0, maskedBoundsArray, indexArray);\n\n        const maskArray = Object.keys(mask);\n        for (let i = 0; i < maskArray.length; i++) {\n            const maskCoord = mask[maskArray[i]];\n            const vertexExtent = EXTENT >> maskCoord.z;\n            const tlVertex = new Point(maskCoord.x * vertexExtent, maskCoord.y * vertexExtent);\n            const brVertex = new Point(tlVertex.x + vertexExtent, tlVertex.y + vertexExtent);\n\n            // not sure why flow is complaining here because it doesn't complain at L401\n            const segment = (this.segments: any).prepareSegment(4, maskedBoundsArray, indexArray);\n\n            maskedBoundsArray.emplaceBack(tlVertex.x, tlVertex.y, tlVertex.x, tlVertex.y);\n            maskedBoundsArray.emplaceBack(brVertex.x, tlVertex.y, brVertex.x, tlVertex.y);\n            maskedBoundsArray.emplaceBack(tlVertex.x, brVertex.y, tlVertex.x, brVertex.y);\n            maskedBoundsArray.emplaceBack(brVertex.x, brVertex.y, brVertex.x, brVertex.y);\n\n            const offset = segment.vertexLength;\n            // 0, 1, 2\n            // 1, 2, 3\n            indexArray.emplaceBack(offset, offset + 1, offset + 2);\n            indexArray.emplaceBack(offset + 1, offset + 2, offset + 3);\n\n            segment.vertexLength += 4;\n            segment.primitiveLength += 2;\n        }\n\n        this.maskedBoundsBuffer = context.createVertexBuffer(maskedBoundsArray, rasterBoundsAttributes.members);\n        this.maskedIndexBuffer = context.createIndexBuffer(indexArray);\n    }\n\n    hasData() {\n        return this.state === 'loaded' || this.state === 'reloading' || this.state === 'expired';\n    }\n\n    patternsLoaded() {\n        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;\n    }\n\n    setExpiryData(data: any) {\n        const prior = this.expirationTime;\n\n        if (data.cacheControl) {\n            const parsedCC = parseCacheControl(data.cacheControl);\n            if (parsedCC['max-age']) this.expirationTime = Date.now() + parsedCC['max-age'] * 1000;\n        } else if (data.expires) {\n            this.expirationTime = new Date(data.expires).getTime();\n        }\n\n        if (this.expirationTime) {\n            const now = Date.now();\n            let isExpired = false;\n\n            if (this.expirationTime > now) {\n                isExpired = false;\n            } else if (!prior) {\n                isExpired = true;\n            } else if (this.expirationTime < prior) {\n                // Expiring date is going backwards:\n                // fall back to exponential backoff\n                isExpired = true;\n\n            } else {\n                const delta = this.expirationTime - prior;\n\n                if (!delta) {\n                    // Server is serving the same expired resource over and over: fall\n                    // back to exponential backoff.\n                    isExpired = true;\n\n                } else {\n                    // Assume that either the client or the server clock is wrong and\n                    // try to interpolate a valid expiration date (from the client POV)\n                    // observing a minimum timeout.\n                    this.expirationTime = now + Math.max(delta, CLOCK_SKEW_RETRY_TIMEOUT);\n\n                }\n            }\n\n            if (isExpired) {\n                this.expiredRequestCount++;\n                this.state = 'expired';\n            } else {\n                this.expiredRequestCount = 0;\n            }\n        }\n    }\n\n    getExpiryTimeout() {\n        if (this.expirationTime) {\n            if (this.expiredRequestCount) {\n                return 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31));\n            } else {\n                // Max value for `setTimeout` implementations is a 32 bit integer; cap this accordingly\n                return Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);\n            }\n        }\n    }\n\n    setFeatureState(states: LayerFeatureStates, painter: any) {\n        if (!this.latestFeatureIndex ||\n            !this.latestFeatureIndex.rawTileData ||\n            Object.keys(states).length === 0) {\n            return;\n        }\n\n        const vtLayers = this.latestFeatureIndex.loadVTLayers();\n\n        for (const id in this.buckets) {\n            const bucket = this.buckets[id];\n            // Buckets are grouped by common source-layer\n            const sourceLayerId = bucket.layers[0]['sourceLayer'] || '_geojsonTileLayer';\n            const sourceLayer = vtLayers[sourceLayerId];\n            const sourceLayerStates = states[sourceLayerId];\n            if (!sourceLayer || !sourceLayerStates || Object.keys(sourceLayerStates).length === 0) continue;\n\n            bucket.update(sourceLayerStates, sourceLayer, this.imageAtlas && this.imageAtlas.patternPositions || {});\n            if (painter && painter.style) {\n                this.queryPadding = Math.max(this.queryPadding, painter.style.getLayer(id).queryRadius(bucket));\n            }\n        }\n    }\n\n    holdingForFade(): boolean {\n        return this.symbolFadeHoldUntil !== undefined;\n    }\n\n    symbolFadeFinished(): boolean {\n        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < browser.now();\n    }\n\n    clearFadeHold() {\n        this.symbolFadeHoldUntil = undefined;\n    }\n\n    setHoldDuration(duration: number) {\n        this.symbolFadeHoldUntil = browser.now() + duration;\n    }\n}\n\nexport default Tile;\n","// @flow\n\nimport type {CollisionBoxArray} from './array_types';\nimport type Style from '../style/style';\nimport type {TypedStyleLayer} from '../style/style_layer/typed_style_layer';\nimport type FeatureIndex from './feature_index';\nimport type Context from '../gl/context';\nimport type {FeatureStates} from '../source/source_state';\nimport type {ImagePosition} from '../render/image_atlas';\n\nexport type BucketParameters<Layer: TypedStyleLayer> = {\n    index: number,\n    layers: Array<Layer>,\n    zoom: number,\n    pixelRatio: number,\n    overscaling: number,\n    collisionBoxArray: CollisionBoxArray,\n    sourceLayerIndex: number,\n    sourceID: string\n}\n\nexport type PopulateParameters = {\n    featureIndex: FeatureIndex,\n    iconDependencies: {},\n    patternDependencies: {},\n    glyphDependencies: {}\n}\n\nexport type IndexedFeature = {\n    feature: VectorTileFeature,\n    index: number,\n    sourceLayerIndex: number,\n}\n\nexport type BucketFeature = {|\n    index: number,\n    sourceLayerIndex: number,\n    geometry: Array<Array<Point>>,\n    properties: Object,\n    type: 1 | 2 | 3,\n    id?: any,\n    +patterns: {[string]: {\"min\": string, \"mid\": string, \"max\": string}}\n|};\n\n/**\n * The `Bucket` interface is the single point of knowledge about turning vector\n * tiles into WebGL buffers.\n *\n * `Bucket` is an abstract interface. An implementation exists for each style layer type.\n * Create a bucket via the `StyleLayer#createBucket` method.\n *\n * The concrete bucket types, using layout options from the style layer,\n * transform feature geometries into vertex and index data for use by the\n * vertex shader.  They also (via `ProgramConfiguration`) use feature\n * properties and the zoom level to populate the attributes needed for\n * data-driven styling.\n *\n * Buckets are designed to be built on a worker thread and then serialized and\n * transferred back to the main thread for rendering.  On the worker side, a\n * bucket's vertex, index, and attribute data is stored in `bucket.arrays:\n * ArrayGroup`.  When a bucket's data is serialized and sent back to the main\n * thread, is gets deserialized (using `new Bucket(serializedBucketData)`, with\n * the array data now stored in `bucket.buffers: BufferGroup`.  BufferGroups\n * hold the same data as ArrayGroups, but are tuned for consumption by WebGL.\n *\n * @private\n */\nexport interface Bucket {\n    layerIds: Array<string>;\n    hasPattern: boolean;\n    +layers: Array<any>;\n    +stateDependentLayers: Array<any>;\n    +stateDependentLayerIds: Array<string>;\n    populate(features: Array<IndexedFeature>, options: PopulateParameters): void;\n    update(states: FeatureStates, vtLayer: VectorTileLayer, imagePositions: {[string]: ImagePosition}): void;\n    isEmpty(): boolean;\n\n    upload(context: Context): void;\n    uploadPending(): boolean;\n\n    /**\n     * Release the WebGL resources associated with the buffers. Note that because\n     * buckets are shared between layers having the same layout properties, they\n     * must be destroyed in groups (all buckets for a tile, or all symbol buckets).\n     *\n     * @private\n     */\n    destroy(): void;\n}\n\nexport function deserialize(input: Array<Bucket>, style: Style): {[string]: Bucket} {\n    const output = {};\n\n    // Guard against the case where the map's style has been set to null while\n    // this bucket has been parsing.\n    if (!style) return output;\n\n    for (const bucket of input) {\n        const layers = bucket.layerIds\n            .map((id) => style.getLayer(id))\n            .filter(Boolean);\n\n        if (layers.length === 0) {\n            continue;\n        }\n\n        // look up StyleLayer objects from layer ids (since we don't\n        // want to waste time serializing/copying them from the worker)\n        (bucket: any).layers = layers;\n        if ((bucket: any).stateDependentLayerIds) {\n            (bucket: any).stateDependentLayers = (bucket: any).stateDependentLayerIds.map((lId) => layers.filter((l) => l.id === lId)[0]);\n        }\n        for (const layer of layers) {\n            output[layer.id] = bucket;\n        }\n    }\n\n    return output;\n}\n","\nexport default ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n","// @flow\n\nimport {\n    charHasUprightVerticalOrientation,\n    charAllowsIdeographicBreaking\n} from '../util/script_detection';\nimport verticalizePunctuation from '../util/verticalize_punctuation';\nimport { plugin as rtlTextPlugin } from '../source/rtl_text_plugin';\n\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {ImagePosition} from '../render/image_atlas';\nimport Formatted from '../style-spec/expression/types/formatted';\n\nconst WritingMode = {\n    horizontal: 1,\n    vertical: 2,\n    horizontalOnly: 3\n};\n\nexport { shapeText, shapeIcon, WritingMode };\n\n// The position of a glyph relative to the text's anchor point.\nexport type PositionedGlyph = {\n    glyph: number,\n    x: number,\n    y: number,\n    vertical: boolean,\n    scale: number,\n    fontStack: string\n};\n\n// A collection of positioned glyphs and some metadata\nexport type Shaping = {\n    positionedGlyphs: Array<PositionedGlyph>,\n    top: number,\n    bottom: number,\n    left: number,\n    right: number,\n    writingMode: 1 | 2\n};\n\ntype SymbolAnchor = 'center' | 'left' | 'right' | 'top' | 'bottom' | 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\ntype TextJustify = 'left' | 'center' | 'right';\n\nclass TaggedString {\n    text: string;\n    sectionIndex: Array<number> // maps each character in 'text' to its corresponding entry in 'sections'\n    sections: Array<{ scale: number, fontStack: string }>\n\n    constructor() {\n        this.text = \"\";\n        this.sectionIndex = [];\n        this.sections = [];\n    }\n\n    static fromFeature(text: Formatted, defaultFontStack: string) {\n        const result = new TaggedString();\n        for (let i = 0; i < text.sections.length; i++) {\n            const section = text.sections[i];\n            result.sections.push({\n                scale: section.scale || 1,\n                fontStack: section.fontStack || defaultFontStack\n            });\n            result.text += section.text;\n            for (let j = 0; j < section.text.length; j++) {\n                result.sectionIndex.push(i);\n            }\n        }\n        return result;\n    }\n\n    length(): number {\n        return this.text.length;\n    }\n\n    getSection(index: number): { scale: number, fontStack: string } {\n        return this.sections[this.sectionIndex[index]];\n    }\n\n    getCharCode(index: number): number {\n        return this.text.charCodeAt(index);\n    }\n\n    verticalizePunctuation() {\n        this.text = verticalizePunctuation(this.text);\n    }\n\n    trim() {\n        let beginningWhitespace = 0;\n        for (let i = 0;\n            i < this.text.length && whitespace[this.text.charCodeAt(i)];\n            i++) {\n            beginningWhitespace++;\n        }\n        let trailingWhitespace = this.text.length;\n        for (let i = this.text.length - 1;\n            i >= 0 && i >= beginningWhitespace && whitespace[this.text.charCodeAt(i)];\n            i--) {\n            trailingWhitespace--;\n        }\n        this.text = this.text.substring(beginningWhitespace, trailingWhitespace);\n        this.sectionIndex = this.sectionIndex.slice(beginningWhitespace, trailingWhitespace);\n    }\n\n    substring(start: number, end: number): TaggedString {\n        const substring = new TaggedString();\n        substring.text = this.text.substring(start, end);\n        substring.sectionIndex = this.sectionIndex.slice(start, end);\n        substring.sections = this.sections;\n        return substring;\n    }\n\n    toString(): string {\n        return this.text;\n    }\n\n    getMaxScale() {\n        return this.sectionIndex.reduce((max, index) => Math.max(max, this.sections[index].scale), 0);\n    }\n}\n\nfunction breakLines(input: TaggedString, lineBreakPoints: Array<number>): Array<TaggedString> {\n    const lines = [];\n    const text = input.text;\n    let start = 0;\n    for (const lineBreak of lineBreakPoints) {\n        lines.push(input.substring(start, lineBreak));\n        start = lineBreak;\n    }\n\n    if (start < text.length) {\n        lines.push(input.substring(start, text.length));\n    }\n    return lines;\n}\n\nfunction shapeText(text: Formatted,\n                   glyphs: {[string]: {[number]: ?StyleGlyph}},\n                   defaultFontStack: string,\n                   maxWidth: number,\n                   lineHeight: number,\n                   textAnchor: SymbolAnchor,\n                   textJustify: TextJustify,\n                   spacing: number,\n                   translate: [number, number],\n                   verticalHeight: number,\n                   writingMode: 1 | 2): Shaping | false {\n    const logicalInput = TaggedString.fromFeature(text, defaultFontStack);\n\n    if (writingMode === WritingMode.vertical) {\n        logicalInput.verticalizePunctuation();\n    }\n\n    const positionedGlyphs = [];\n    const shaping = {\n        positionedGlyphs,\n        text: logicalInput,\n        top: translate[1],\n        bottom: translate[1],\n        left: translate[0],\n        right: translate[0],\n        writingMode\n    };\n\n    let lines: Array<TaggedString>;\n\n    const {processBidirectionalText, processStyledBidirectionalText} = rtlTextPlugin;\n    if (processBidirectionalText && logicalInput.sections.length === 1) {\n        // Bidi doesn't have to be style-aware\n        lines = [];\n        const untaggedLines =\n            processBidirectionalText(logicalInput.toString(),\n                                     determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n        for (const line of untaggedLines) {\n            const taggedLine = new TaggedString();\n            taggedLine.text = line;\n            taggedLine.sections = logicalInput.sections;\n            for (let i = 0; i < line.length; i++) {\n                taggedLine.sectionIndex.push(0);\n            }\n            lines.push(taggedLine);\n        }\n    } else if (processStyledBidirectionalText) {\n        // Need version of mapbox-gl-rtl-text with style support for combining RTL text\n        // with formatting\n        lines = [];\n        const processedLines =\n            processStyledBidirectionalText(logicalInput.text,\n                                           logicalInput.sectionIndex,\n                                           determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n        for (const line of processedLines) {\n            const taggedLine = new TaggedString();\n            taggedLine.text = line[0];\n            taggedLine.sectionIndex = line[1];\n            taggedLine.sections = logicalInput.sections;\n            lines.push(taggedLine);\n        }\n    } else {\n        lines = breakLines(logicalInput, determineLineBreaks(logicalInput, spacing, maxWidth, glyphs));\n    }\n\n    shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, writingMode, spacing, verticalHeight);\n\n    if (!positionedGlyphs.length)\n        return false;\n\n    shaping.text = shaping.text.toString();\n    return shaping;\n}\n\n// using computed properties due to https://github.com/facebook/flow/issues/380\n/* eslint no-useless-computed-key: 0 */\n\nconst whitespace: {[number]: boolean} = {\n    [0x09]: true, // tab\n    [0x0a]: true, // newline\n    [0x0b]: true, // vertical tab\n    [0x0c]: true, // form feed\n    [0x0d]: true, // carriage return\n    [0x20]: true, // space\n};\n\nconst breakable: {[number]: boolean} = {\n    [0x0a]:   true, // newline\n    [0x20]:   true, // space\n    [0x26]:   true, // ampersand\n    [0x28]:   true, // left parenthesis\n    [0x29]:   true, // right parenthesis\n    [0x2b]:   true, // plus sign\n    [0x2d]:   true, // hyphen-minus\n    [0x2f]:   true, // solidus\n    [0xad]:   true, // soft hyphen\n    [0xb7]:   true, // middle dot\n    [0x200b]: true, // zero-width space\n    [0x2010]: true, // hyphen\n    [0x2013]: true, // en dash\n    [0x2027]: true  // interpunct\n    // Many other characters may be reasonable breakpoints\n    // Consider \"neutral orientation\" characters at scriptDetection.charHasNeutralVerticalOrientation\n    // See https://github.com/mapbox/mapbox-gl-js/issues/3658\n};\n\nfunction determineAverageLineWidth(logicalInput: TaggedString,\n                                   spacing: number,\n                                   maxWidth: number,\n                                   glyphMap: {[string]: {[number]: ?StyleGlyph}}) {\n    let totalWidth = 0;\n\n    for (let index = 0; index < logicalInput.length(); index++) {\n        const section = logicalInput.getSection(index);\n        const positions = glyphMap[section.fontStack];\n        const glyph = positions && positions[logicalInput.getCharCode(index)];\n        if (!glyph)\n            continue;\n        totalWidth += glyph.metrics.advance * section.scale + spacing;\n    }\n\n    const lineCount = Math.max(1, Math.ceil(totalWidth / maxWidth));\n    return totalWidth / lineCount;\n}\n\nfunction calculateBadness(lineWidth: number,\n                          targetWidth: number,\n                          penalty: number,\n                          isLastBreak: boolean) {\n    const raggedness = Math.pow(lineWidth - targetWidth, 2);\n    if (isLastBreak) {\n        // Favor finals lines shorter than average over longer than average\n        if (lineWidth < targetWidth) {\n            return raggedness / 2;\n        } else {\n            return raggedness * 2;\n        }\n    }\n\n    return raggedness + Math.abs(penalty) * penalty;\n}\n\nfunction calculatePenalty(codePoint: number, nextCodePoint: number) {\n    let penalty = 0;\n    // Force break on newline\n    if (codePoint === 0x0a) {\n        penalty -= 10000;\n    }\n    // Penalize open parenthesis at end of line\n    if (codePoint === 0x28 || codePoint === 0xff08) {\n        penalty += 50;\n    }\n\n    // Penalize close parenthesis at beginning of line\n    if (nextCodePoint === 0x29 || nextCodePoint === 0xff09) {\n        penalty += 50;\n    }\n    return penalty;\n}\n\ntype Break = {\n    index: number,\n    x: number,\n    priorBreak: ?Break,\n    badness: number\n};\n\nfunction evaluateBreak(breakIndex: number,\n                       breakX: number,\n                       targetWidth: number,\n                       potentialBreaks: Array<Break>,\n                       penalty: number,\n                       isLastBreak: boolean): Break {\n    // We could skip evaluating breaks where the line length (breakX - priorBreak.x) > maxWidth\n    //  ...but in fact we allow lines longer than maxWidth (if there's no break points)\n    //  ...and when targetWidth and maxWidth are close, strictly enforcing maxWidth can give\n    //     more lopsided results.\n\n    let bestPriorBreak: ?Break = null;\n    let bestBreakBadness = calculateBadness(breakX, targetWidth, penalty, isLastBreak);\n\n    for (const potentialBreak of potentialBreaks) {\n        const lineWidth = breakX - potentialBreak.x;\n        const breakBadness =\n            calculateBadness(lineWidth, targetWidth, penalty, isLastBreak) + potentialBreak.badness;\n        if (breakBadness <= bestBreakBadness) {\n            bestPriorBreak = potentialBreak;\n            bestBreakBadness = breakBadness;\n        }\n    }\n\n    return {\n        index: breakIndex,\n        x: breakX,\n        priorBreak: bestPriorBreak,\n        badness: bestBreakBadness\n    };\n}\n\nfunction leastBadBreaks(lastLineBreak: ?Break): Array<number> {\n    if (!lastLineBreak) {\n        return [];\n    }\n    return leastBadBreaks(lastLineBreak.priorBreak).concat(lastLineBreak.index);\n}\n\nfunction determineLineBreaks(logicalInput: TaggedString,\n                             spacing: number,\n                             maxWidth: number,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}}): Array<number> {\n    if (!maxWidth)\n        return [];\n\n    if (!logicalInput)\n        return [];\n\n    const potentialLineBreaks = [];\n    const targetWidth = determineAverageLineWidth(logicalInput, spacing, maxWidth, glyphMap);\n\n    let currentX = 0;\n\n    for (let i = 0; i < logicalInput.length(); i++) {\n        const section = logicalInput.getSection(i);\n        const codePoint = logicalInput.getCharCode(i);\n        const positions = glyphMap[section.fontStack];\n        const glyph = positions && positions[codePoint];\n\n        if (glyph && !whitespace[codePoint])\n            currentX += glyph.metrics.advance * section.scale + spacing;\n\n        // Ideographic characters, spaces, and word-breaking punctuation that often appear without\n        // surrounding spaces.\n        if ((i < logicalInput.length() - 1) &&\n            (breakable[codePoint] ||\n                charAllowsIdeographicBreaking(codePoint))) {\n\n            potentialLineBreaks.push(\n                evaluateBreak(\n                    i + 1,\n                    currentX,\n                    targetWidth,\n                    potentialLineBreaks,\n                    calculatePenalty(codePoint, logicalInput.getCharCode(i + 1)),\n                    false));\n        }\n    }\n\n    return leastBadBreaks(\n        evaluateBreak(\n            logicalInput.length(),\n            currentX,\n            targetWidth,\n            potentialLineBreaks,\n            0,\n            true));\n}\n\nfunction getAnchorAlignment(anchor: SymbolAnchor) {\n    let horizontalAlign = 0.5, verticalAlign = 0.5;\n\n    switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n        horizontalAlign = 1;\n        break;\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n        horizontalAlign = 0;\n        break;\n    }\n\n    switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n        verticalAlign = 1;\n        break;\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n        verticalAlign = 0;\n        break;\n    }\n\n    return { horizontalAlign, verticalAlign };\n}\n\nfunction shapeLines(shaping: Shaping,\n                    glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                    lines: Array<TaggedString>,\n                    lineHeight: number,\n                    textAnchor: SymbolAnchor,\n                    textJustify: TextJustify,\n                    writingMode: 1 | 2,\n                    spacing: number,\n                    verticalHeight: number) {\n    // the y offset *should* be part of the font metadata\n    const yOffset = -17;\n\n    let x = 0;\n    let y = yOffset;\n\n    let maxLineLength = 0;\n    const positionedGlyphs = shaping.positionedGlyphs;\n\n    const justify =\n        textJustify === 'right' ? 1 :\n        textJustify === 'left' ? 0 : 0.5;\n\n    for (const line of lines) {\n        line.trim();\n\n        const lineMaxScale = line.getMaxScale();\n\n        if (!line.length()) {\n            y += lineHeight; // Still need a line feed after empty line\n            continue;\n        }\n\n        const lineStartIndex = positionedGlyphs.length;\n        for (let i = 0; i < line.length(); i++) {\n            const section = line.getSection(i);\n            const codePoint = line.getCharCode(i);\n            // We don't know the baseline, but since we're laying out\n            // at 24 points, we can calculate how much it will move when\n            // we scale up or down.\n            const baselineOffset = (lineMaxScale - section.scale) * 24;\n            const positions = glyphMap[section.fontStack];\n            const glyph = positions && positions[codePoint];\n\n            if (!glyph) continue;\n\n            if (!charHasUprightVerticalOrientation(codePoint) || writingMode === WritingMode.horizontal) {\n                positionedGlyphs.push({glyph: codePoint, x, y: y + baselineOffset, vertical: false, scale: section.scale, fontStack: section.fontStack});\n                x += glyph.metrics.advance * section.scale + spacing;\n            } else {\n                positionedGlyphs.push({glyph: codePoint, x, y: baselineOffset, vertical: true, scale: section.scale, fontStack: section.fontStack});\n                x += verticalHeight * section.scale + spacing;\n            }\n        }\n\n        // Only justify if we placed at least one glyph\n        if (positionedGlyphs.length !== lineStartIndex) {\n            const lineLength = x - spacing;\n            maxLineLength = Math.max(lineLength, maxLineLength);\n\n            justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n        }\n\n        x = 0;\n        y += lineHeight * lineMaxScale;\n    }\n\n    const {horizontalAlign, verticalAlign} = getAnchorAlignment(textAnchor);\n    align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);\n\n    // Calculate the bounding box\n    const height = y - yOffset;\n\n    shaping.top += -verticalAlign * height;\n    shaping.bottom = shaping.top + height;\n    shaping.left += -horizontalAlign * maxLineLength;\n    shaping.right = shaping.left + maxLineLength;\n}\n\n// justify right = 1, left = 0, center = 0.5\nfunction justifyLine(positionedGlyphs: Array<PositionedGlyph>,\n                     glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                     start: number,\n                     end: number,\n                     justify: 1 | 0 | 0.5) {\n    if (!justify)\n        return;\n\n    const lastPositionedGlyph = positionedGlyphs[end];\n    const positions = glyphMap[lastPositionedGlyph.fontStack];\n    const glyph = positions && positions[lastPositionedGlyph.glyph];\n    if (glyph) {\n        const lastAdvance = glyph.metrics.advance * lastPositionedGlyph.scale;\n        const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n\n        for (let j = start; j <= end; j++) {\n            positionedGlyphs[j].x -= lineIndent;\n        }\n    }\n}\n\nfunction align(positionedGlyphs: Array<PositionedGlyph>,\n               justify: number,\n               horizontalAlign: number,\n               verticalAlign: number,\n               maxLineLength: number,\n               lineHeight: number,\n               lineCount: number) {\n    const shiftX = (justify - horizontalAlign) * maxLineLength;\n    const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n\n    for (let j = 0; j < positionedGlyphs.length; j++) {\n        positionedGlyphs[j].x += shiftX;\n        positionedGlyphs[j].y += shiftY;\n    }\n}\n\nexport type PositionedIcon = {\n    image: ImagePosition,\n    top: number,\n    bottom: number,\n    left: number,\n    right: number\n};\n\nfunction shapeIcon(image: ImagePosition, iconOffset: [number, number], iconAnchor: SymbolAnchor): PositionedIcon {\n    const {horizontalAlign, verticalAlign} = getAnchorAlignment(iconAnchor);\n    const dx = iconOffset[0];\n    const dy = iconOffset[1];\n    const x1 = dx - image.displaySize[0] * horizontalAlign;\n    const x2 = x1 + image.displaySize[0];\n    const y1 = dy - image.displaySize[1] * verticalAlign;\n    const y2 = y1 + image.displaySize[1];\n    return {image, top: y1, bottom: y2, left: x1, right: x2};\n}\n","// @flow\n\nimport {\n    charHasRotatedVerticalOrientation,\n} from './script_detection';\n\nexport const verticalizedCharacterMap = {\n    '!': '',\n    '#': '',\n    '$': '',\n    '%': '',\n    '&': '',\n    '(': '',\n    ')': '',\n    '*': '',\n    '+': '',\n    ',': '',\n    '-': '',\n    '.': '',\n    '/': '',\n    ':': '',\n    ';': '',\n    '<': '',\n    '=': '',\n    '>': '',\n    '?': '',\n    '@': '',\n    '[': '',\n    '\\\\': '',\n    ']': '',\n    '^': '',\n    '_': '',\n    '`': '',\n    '{': '',\n    '|': '',\n    '}': '',\n    '~': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': '',\n    '': ''\n};\n\nexport default function verticalizePunctuation(input: string) {\n    let output = '';\n\n    for (let i = 0; i < input.length; i++) {\n        const nextCharCode = input.charCodeAt(i + 1) || null;\n        const prevCharCode = input.charCodeAt(i - 1) || null;\n\n        const canReplacePunctuation = (\n            (!nextCharCode || !charHasRotatedVerticalOrientation(nextCharCode) || verticalizedCharacterMap[input[i + 1]]) &&\n            (!prevCharCode || !charHasRotatedVerticalOrientation(prevCharCode) || verticalizedCharacterMap[input[i - 1]])\n        );\n\n        if (canReplacePunctuation && verticalizedCharacterMap[input[i]]) {\n            output += verticalizedCharacterMap[input[i]];\n        } else {\n            output += input[i];\n        }\n    }\n\n    return output;\n}\n\n","\nimport refProperties from './util/ref_properties';\n\nfunction stringify(obj) {\n    const type = typeof obj;\n    if (type === 'number' || type === 'boolean' || type === 'string' || obj === undefined || obj === null)\n        return JSON.stringify(obj);\n\n    if (Array.isArray(obj)) {\n        let str = '[';\n        for (const val of obj) {\n            str += `${stringify(val)},`;\n        }\n        return `${str}]`;\n    }\n\n    const keys = Object.keys(obj).sort();\n\n    let str = '{';\n    for (let i = 0; i < keys.length; i++) {\n        str += `${JSON.stringify(keys[i])}:${stringify(obj[keys[i]])},`;\n    }\n    return `${str}}`;\n}\n\nfunction getKey(layer) {\n    let key = '';\n    for (const k of refProperties) {\n        key += `/${stringify(layer[k])}`;\n    }\n    return key;\n}\n\nexport default groupByLayout;\n\n/**\n * Given an array of layers, return an array of arrays of layers where all\n * layers in each group have identical layout-affecting properties. These\n * are the properties that were formerly used by explicit `ref` mechanism\n * for layers: 'type', 'source', 'source-layer', 'minzoom', 'maxzoom',\n * 'filter', and 'layout'.\n *\n * The input is not modified. The output layers are references to the\n * input layers.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Array<Layer>>}\n */\nfunction groupByLayout(layers) {\n    const groups = {};\n\n    for (let i = 0; i < layers.length; i++) {\n        const k = getKey(layers[i]);\n        let group = groups[k];\n        if (!group) {\n            group = groups[k] = [];\n        }\n        group.push(layers[i]);\n    }\n\n    const result = [];\n\n    for (const k in groups) {\n        result.push(groups[k]);\n    }\n\n    return result;\n}\n","// @flow\n\nimport StyleLayer from './style_layer';\nimport createStyleLayer from './create_style_layer';\n\nimport { values } from '../util/util';\nimport featureFilter from '../style-spec/feature_filter';\nimport groupByLayout from '../style-spec/group_by_layout';\n\nimport type {TypedStyleLayer} from './style_layer/typed_style_layer';\nimport type {LayerSpecification} from '../style-spec/types';\n\nexport type LayerConfigs = { [string]: LayerSpecification };\nexport type Family<Layer: TypedStyleLayer> = Array<Layer>;\n\nclass StyleLayerIndex {\n    familiesBySource: { [source: string]: { [sourceLayer: string]: Array<Family<*>> } };\n\n    _layerConfigs: LayerConfigs;\n    _layers: { [string]: StyleLayer };\n\n    constructor(layerConfigs: ?Array<LayerSpecification>) {\n        if (layerConfigs) {\n            this.replace(layerConfigs);\n        }\n    }\n\n    replace(layerConfigs: Array<LayerSpecification>) {\n        this._layerConfigs = {};\n        this._layers = {};\n        this.update(layerConfigs, []);\n    }\n\n    update(layerConfigs: Array<LayerSpecification>, removedIds: Array<string>) {\n        for (const layerConfig of layerConfigs) {\n            this._layerConfigs[layerConfig.id] = layerConfig;\n\n            const layer = this._layers[layerConfig.id] = createStyleLayer(layerConfig);\n            layer._featureFilter = featureFilter(layer.filter);\n        }\n        for (const id of removedIds) {\n            delete this._layerConfigs[id];\n            delete this._layers[id];\n        }\n\n        this.familiesBySource = {};\n\n        const groups = groupByLayout(values(this._layerConfigs));\n\n        for (const layerConfigs of groups) {\n            const layers = layerConfigs.map((layerConfig) => this._layers[layerConfig.id]);\n\n            const layer = layers[0];\n            if (layer.visibility === 'none') {\n                continue;\n            }\n\n            const sourceId = layer.source || '';\n            let sourceGroup = this.familiesBySource[sourceId];\n            if (!sourceGroup) {\n                sourceGroup = this.familiesBySource[sourceId] = {};\n            }\n\n            const sourceLayerId = layer.sourceLayer || '_geojsonTileLayer';\n            let sourceLayerFamilies = sourceGroup[sourceLayerId];\n            if (!sourceLayerFamilies) {\n                sourceLayerFamilies = sourceGroup[sourceLayerId] = [];\n            }\n\n            sourceLayerFamilies.push(layers);\n        }\n    }\n}\n\nexport default StyleLayerIndex;\n","// @flow\n\nexport default checkMaxAngle;\n\nimport type Point from '@mapbox/point-geometry';\nimport type Anchor from './anchor';\n\n/**\n * Labels placed around really sharp angles aren't readable. Check if any\n * part of the potential label has a combined angle that is too big.\n *\n * @param line\n * @param anchor The point on the line around which the label is anchored.\n * @param labelLength The length of the label in geometry units.\n * @param windowSize The check fails if the combined angles within a part of the line that is `windowSize` long is too big.\n * @param maxAngle The maximum combined angle that any window along the label is allowed to have.\n *\n * @returns {boolean} whether the label should be placed\n * @private\n */\nfunction checkMaxAngle(line: Array<Point>, anchor: Anchor, labelLength: number, windowSize: number, maxAngle: number) {\n\n    // horizontal labels always pass\n    if (anchor.segment === undefined) return true;\n\n    let p = anchor;\n    let index = anchor.segment + 1;\n    let anchorDistance = 0;\n\n    // move backwards along the line to the first segment the label appears on\n    while (anchorDistance > -labelLength / 2) {\n        index--;\n\n        // there isn't enough room for the label after the beginning of the line\n        if (index < 0) return false;\n\n        anchorDistance -= line[index].dist(p);\n        p = line[index];\n    }\n\n    anchorDistance += line[index].dist(line[index + 1]);\n    index++;\n\n    // store recent corners and their total angle difference\n    const recentCorners = [];\n    let recentAngleDelta = 0;\n\n    // move forwards by the length of the label and check angles along the way\n    while (anchorDistance < labelLength / 2) {\n        const prev = line[index - 1];\n        const current = line[index];\n        const next = line[index + 1];\n\n        // there isn't enough room for the label before the end of the line\n        if (!next) return false;\n\n        let angleDelta = prev.angleTo(current) - current.angleTo(next);\n        // restrict angle to -pi..pi range\n        angleDelta = Math.abs(((angleDelta + 3 * Math.PI) % (Math.PI * 2)) - Math.PI);\n\n        recentCorners.push({\n            distance: anchorDistance,\n            angleDelta\n        });\n        recentAngleDelta += angleDelta;\n\n        // remove corners that are far enough away from the list of recent anchors\n        while (anchorDistance - recentCorners[0].distance > windowSize) {\n            recentAngleDelta -= recentCorners.shift().angleDelta;\n        }\n\n        // the sum of angles within the window area exceeds the maximum allowed value. check fails.\n        if (recentAngleDelta > maxAngle) return false;\n\n        index++;\n        anchorDistance += current.dist(next);\n    }\n\n    // no part of the line had an angle greater than the maximum allowed. check passes.\n    return true;\n}\n","// @flow\n\nimport { number as interpolate } from '../style-spec/util/interpolate';\n\nimport Anchor from '../symbol/anchor';\nimport checkMaxAngle from './check_max_angle';\n\nimport type Point from '@mapbox/point-geometry';\nimport type {Shaping, PositionedIcon} from './shaping';\n\nexport { getAnchors, getCenterAnchor };\n\nfunction getLineLength(line: Array<Point>): number {\n    let lineLength = 0;\n    for (let k = 0; k < line.length - 1; k++) {\n        lineLength += line[k].dist(line[k + 1]);\n    }\n    return lineLength;\n}\n\nfunction getAngleWindowSize(shapedText: ?Shaping,\n                            glyphSize: number,\n                            boxScale: number): number {\n    return shapedText ?\n        3 / 5 * glyphSize * boxScale :\n        0;\n}\n\nfunction getShapedLabelLength(shapedText: ?Shaping, shapedIcon: ?PositionedIcon): number {\n    return Math.max(\n        shapedText ? shapedText.right - shapedText.left : 0,\n        shapedIcon ? shapedIcon.right - shapedIcon.left : 0);\n}\n\nfunction getCenterAnchor(line: Array<Point>,\n                         maxAngle: number,\n                         shapedText: ?Shaping,\n                         shapedIcon: ?PositionedIcon,\n                         glyphSize: number,\n                         boxScale: number) {\n    const angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);\n    const labelLength = getShapedLabelLength(shapedText, shapedIcon) * boxScale;\n\n    let prevDistance = 0;\n    const centerDistance = getLineLength(line) / 2;\n\n    for (let i = 0; i < line.length - 1; i++) {\n\n        const a = line[i],\n            b = line[i + 1];\n\n        const segmentDistance = a.dist(b);\n\n        if (prevDistance + segmentDistance > centerDistance) {\n            // The center is on this segment\n            const t = (centerDistance - prevDistance) / segmentDistance,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            const anchor = new Anchor(x, y, b.angleTo(a), i);\n            anchor._round();\n            if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                return anchor;\n            } else {\n                return;\n            }\n        }\n\n        prevDistance += segmentDistance;\n    }\n}\n\nfunction getAnchors(line: Array<Point>,\n                    spacing: number,\n                    maxAngle: number,\n                    shapedText: ?Shaping,\n                    shapedIcon: ?PositionedIcon,\n                    glyphSize: number,\n                    boxScale: number,\n                    overscaling: number,\n                    tileExtent: number) {\n\n    // Resample a line to get anchor points for labels and check that each\n    // potential label passes text-max-angle check and has enough froom to fit\n    // on the line.\n\n    const angleWindowSize = getAngleWindowSize(shapedText, glyphSize, boxScale);\n    const shapedLabelLength = getShapedLabelLength(shapedText, shapedIcon);\n    const labelLength = shapedLabelLength * boxScale;\n\n    // Is the line continued from outside the tile boundary?\n    const isLineContinued = line[0].x === 0 || line[0].x === tileExtent || line[0].y === 0 || line[0].y === tileExtent;\n\n    // Is the label long, relative to the spacing?\n    // If so, adjust the spacing so there is always a minimum space of `spacing / 4` between label edges.\n    if (spacing - labelLength < spacing / 4) {\n        spacing = labelLength + spacing / 4;\n    }\n\n    // Offset the first anchor by:\n    // Either half the label length plus a fixed extra offset if the line is not continued\n    // Or half the spacing if the line is continued.\n\n    // For non-continued lines, add a bit of fixed extra offset to avoid collisions at T intersections.\n    const fixedExtraOffset = glyphSize * 2;\n\n    const offset = !isLineContinued ?\n        ((shapedLabelLength / 2 + fixedExtraOffset) * boxScale * overscaling) % spacing :\n        (spacing / 2 * overscaling) % spacing;\n\n    return resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, false, tileExtent);\n}\n\n\nfunction resample(line, offset, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, placeAtMiddle, tileExtent) {\n\n    const halfLabelLength = labelLength / 2;\n    const lineLength = getLineLength(line);\n\n    let distance = 0,\n        markedDistance = offset - spacing;\n\n    let anchors = [];\n\n    for (let i = 0; i < line.length - 1; i++) {\n\n        const a = line[i],\n            b = line[i + 1];\n\n        const segmentDist = a.dist(b),\n            angle = b.angleTo(a);\n\n        while (markedDistance + spacing < distance + segmentDist) {\n            markedDistance += spacing;\n\n            const t = (markedDistance - distance) / segmentDist,\n                x = interpolate(a.x, b.x, t),\n                y = interpolate(a.y, b.y, t);\n\n            // Check that the point is within the tile boundaries and that\n            // the label would fit before the beginning and end of the line\n            // if placed at this point.\n            if (x >= 0 && x < tileExtent && y >= 0 && y < tileExtent &&\n                    markedDistance - halfLabelLength >= 0 &&\n                    markedDistance + halfLabelLength <= lineLength) {\n                const anchor = new Anchor(x, y, angle, i);\n                anchor._round();\n\n                if (!angleWindowSize || checkMaxAngle(line, anchor, labelLength, angleWindowSize, maxAngle)) {\n                    anchors.push(anchor);\n                }\n            }\n        }\n\n        distance += segmentDist;\n    }\n\n    if (!placeAtMiddle && !anchors.length && !isLineContinued) {\n        // The first attempt at finding anchors at which labels can be placed failed.\n        // Try again, but this time just try placing one anchor at the middle of the line.\n        // This has the most effect for short lines in overscaled tiles, since the\n        // initial offset used in overscaled tiles is calculated to align labels with positions in\n        // parent tiles instead of placing the label as close to the beginning as possible.\n        anchors = resample(line, distance / 2, spacing, angleWindowSize, maxAngle, labelLength, isLineContinued, true, tileExtent);\n    }\n\n    return anchors;\n}\n","// @flow\n\nimport type {CollisionBoxArray} from '../data/array_types';\nimport Point from '@mapbox/point-geometry';\nimport type Anchor from './anchor';\n\n/**\n * A CollisionFeature represents the area of the tile covered by a single label.\n * It is used with CollisionIndex to check if the label overlaps with any\n * previous labels. A CollisionFeature is mostly just a set of CollisionBox\n * objects.\n *\n * @private\n */\nclass CollisionFeature {\n    boxStartIndex: number;\n    boxEndIndex: number;\n\n    /**\n     * Create a CollisionFeature, adding its collision box data to the given collisionBoxArray in the process.\n     *\n     * @param line The geometry the label is placed on.\n     * @param anchor The point along the line around which the label is anchored.\n     * @param shaped The text or icon shaping results.\n     * @param boxScale A magic number used to convert from glyph metrics units to geometry units.\n     * @param padding The amount of padding to add around the label edges.\n     * @param alignLine Whether the label is aligned with the line or the viewport.\n     */\n    constructor(collisionBoxArray: CollisionBoxArray,\n                line: Array<Point>,\n                anchor: Anchor,\n                featureIndex: number,\n                sourceLayerIndex: number,\n                bucketIndex: number,\n                shaped: Object,\n                boxScale: number,\n                padding: number,\n                alignLine: boolean,\n                overscaling: number,\n                rotate: number) {\n        let y1 = shaped.top * boxScale - padding;\n        let y2 = shaped.bottom * boxScale + padding;\n        let x1 = shaped.left * boxScale - padding;\n        let x2 = shaped.right * boxScale + padding;\n\n        this.boxStartIndex = collisionBoxArray.length;\n\n        if (alignLine) {\n\n            let height = y2 - y1;\n            const length = x2 - x1;\n\n            if (height > 0) {\n                // set minimum box height to avoid very many small labels\n                height = Math.max(10 * boxScale, height);\n\n                this._addLineCollisionCircles(collisionBoxArray, line, anchor, (anchor.segment: any), length, height, featureIndex, sourceLayerIndex, bucketIndex, overscaling);\n            }\n\n        } else {\n            if (rotate) {\n                // Account for *-rotate in point collision boxes\n                // See https://github.com/mapbox/mapbox-gl-js/issues/6075\n                // Doesn't account for icon-text-fit\n\n                const tl = new Point(x1, y1);\n                const tr = new Point(x2, y1);\n                const bl = new Point(x1, y2);\n                const br = new Point(x2, y2);\n\n                const rotateRadians = rotate * Math.PI / 180;\n\n                tl._rotate(rotateRadians);\n                tr._rotate(rotateRadians);\n                bl._rotate(rotateRadians);\n                br._rotate(rotateRadians);\n\n                // Collision features require an \"on-axis\" geometry,\n                // so take the envelope of the rotated geometry\n                // (may be quite large for wide labels rotated 45 degrees)\n                x1 = Math.min(tl.x, tr.x, bl.x, br.x);\n                x2 = Math.max(tl.x, tr.x, bl.x, br.x);\n                y1 = Math.min(tl.y, tr.y, bl.y, br.y);\n                y2 = Math.max(tl.y, tr.y, bl.y, br.y);\n            }\n            collisionBoxArray.emplaceBack(anchor.x, anchor.y, x1, y1, x2, y2, featureIndex, sourceLayerIndex, bucketIndex,\n                0, 0);\n        }\n\n        this.boxEndIndex = collisionBoxArray.length;\n    }\n\n    /**\n     * Create a set of CollisionBox objects for a line.\n     *\n     * @param labelLength The length of the label in geometry units.\n     * @param anchor The point along the line around which the label is anchored.\n     * @param boxSize The size of the collision boxes that will be created.\n     * @private\n     */\n    _addLineCollisionCircles(collisionBoxArray: CollisionBoxArray,\n                           line: Array<Point>,\n                           anchor: Anchor,\n                           segment: number,\n                           labelLength: number,\n                           boxSize: number,\n                           featureIndex: number,\n                           sourceLayerIndex: number,\n                           bucketIndex: number,\n                           overscaling: number) {\n        const step = boxSize / 2;\n        const nBoxes = Math.floor(labelLength / step) || 1;\n        // We calculate line collision circles out to 300% of what would normally be our\n        // max size, to allow collision detection to work on labels that expand as\n        // they move into the distance\n        // Vertically oriented labels in the distant field can extend past this padding\n        // This is a noticeable problem in overscaled tiles where the pitch 0-based\n        // symbol spacing will put labels very close together in a pitched map.\n        // To reduce the cost of adding extra collision circles, we slowly increase\n        // them for overscaled tiles.\n        const overscalingPaddingFactor = 1 + .4 * Math.log(overscaling) / Math.LN2;\n        const nPitchPaddingBoxes = Math.floor(nBoxes * overscalingPaddingFactor / 2);\n\n        // offset the center of the first box by half a box so that the edge of the\n        // box is at the edge of the label.\n        const firstBoxOffset = -boxSize / 2;\n\n        let p = anchor;\n        let index = segment + 1;\n        let anchorDistance = firstBoxOffset;\n        const labelStartDistance = -labelLength / 2;\n        const paddingStartDistance = labelStartDistance - labelLength / 4;\n        // move backwards along the line to the first segment the label appears on\n        do {\n            index--;\n\n            if (index < 0) {\n                if (anchorDistance > labelStartDistance) {\n                    // there isn't enough room for the label after the beginning of the line\n                    // checkMaxAngle should have already caught this\n                    return;\n                } else {\n                    // The line doesn't extend far enough back for all of our padding,\n                    // but we got far enough to show the label under most conditions.\n                    index = 0;\n                    break;\n                }\n            } else {\n                anchorDistance -= line[index].dist(p);\n                p = line[index];\n            }\n        } while (anchorDistance > paddingStartDistance);\n\n        let segmentLength = line[index].dist(line[index + 1]);\n\n        for (let i = -nPitchPaddingBoxes; i < nBoxes + nPitchPaddingBoxes; i++) {\n\n            // the distance the box will be from the anchor\n            const boxOffset = i * step;\n            let boxDistanceToAnchor = labelStartDistance + boxOffset;\n\n            // make the distance between pitch padding boxes bigger\n            if (boxOffset < 0) boxDistanceToAnchor += boxOffset;\n            if (boxOffset > labelLength) boxDistanceToAnchor += boxOffset - labelLength;\n\n            if (boxDistanceToAnchor < anchorDistance) {\n                // The line doesn't extend far enough back for this box, skip it\n                // (This could allow for line collisions on distant tiles)\n                continue;\n            }\n\n            // the box is not on the current segment. Move to the next segment.\n            while (anchorDistance + segmentLength < boxDistanceToAnchor) {\n                anchorDistance += segmentLength;\n                index++;\n\n                // There isn't enough room before the end of the line.\n                if (index + 1 >= line.length) {\n                    return;\n                }\n\n                segmentLength = line[index].dist(line[index + 1]);\n            }\n\n            // the distance the box will be from the beginning of the segment\n            const segmentBoxDistance = boxDistanceToAnchor - anchorDistance;\n\n            const p0 = line[index];\n            const p1 = line[index + 1];\n            const boxAnchorPoint = p1.sub(p0)._unit()._mult(segmentBoxDistance)._add(p0)._round();\n\n            // If the box is within boxSize of the anchor, force the box to be used\n            // (so even 0-width labels use at least one box)\n            // Otherwise, the .8 multiplication gives us a little bit of conservative\n            // padding in choosing which boxes to use (see CollisionIndex#placedCollisionCircles)\n            const paddedAnchorDistance = Math.abs(boxDistanceToAnchor - firstBoxOffset) < step ?\n                0 :\n                (boxDistanceToAnchor - firstBoxOffset) * 0.8;\n\n            collisionBoxArray.emplaceBack(boxAnchorPoint.x, boxAnchorPoint.y,\n                -boxSize / 2, -boxSize / 2, boxSize / 2, boxSize / 2,\n                featureIndex, sourceLayerIndex, bucketIndex,\n                boxSize / 2, paddedAnchorDistance);\n        }\n    }\n}\n\nexport default CollisionFeature;\n","\nexport default class TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = this.data[this.length];\n            this._down(0);\n        }\n        this.data.pop();\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","// @flow\n\nimport Queue from 'tinyqueue';\n\nimport Point from '@mapbox/point-geometry';\nimport { distToSegmentSquared } from './intersection_tests';\n\n/**\n * Finds an approximation of a polygon's Pole Of Inaccessibiliy https://en.wikipedia.org/wiki/Pole_of_inaccessibility\n * This is a copy of http://github.com/mapbox/polylabel adapted to use Points\n *\n * @param polygonRings first item in array is the outer ring followed optionally by the list of holes, should be an element of the result of util/classify_rings\n * @param precision Specified in input coordinate units. If 0 returns after first run, if > 0 repeatedly narrows the search space until the radius of the area searched for the best pole is less than precision\n * @param debug Print some statistics to the console during execution\n * @returns Pole of Inaccessibiliy.\n * @private\n */\nexport default function (polygonRings: Array<Array<Point>>, precision?: number = 1, debug?: boolean = false): Point {\n    // find the bounding box of the outer ring\n    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\n    const outerRing = polygonRings[0];\n    for (let i = 0; i < outerRing.length; i++) {\n        const p = outerRing[i];\n        if (!i || p.x < minX) minX = p.x;\n        if (!i || p.y < minY) minY = p.y;\n        if (!i || p.x > maxX) maxX = p.x;\n        if (!i || p.y > maxY) maxY = p.y;\n    }\n\n    const width = maxX - minX;\n    const height = maxY - minY;\n    const cellSize = Math.min(width, height);\n    let h = cellSize / 2;\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    const cellQueue = new Queue([], compareMax);\n\n    if (cellSize === 0) return new Point(minX, minY);\n\n    // cover polygon with initial cells\n    for (let x = minX; x < maxX; x += cellSize) {\n        for (let y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygonRings));\n        }\n    }\n\n    // take centroid as the first best guess\n    let bestCell = getCentroidCell(polygonRings);\n    let numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        const cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d || !bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y - h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x - h, cell.p.y + h, h, polygonRings));\n        cellQueue.push(new Cell(cell.p.x + h, cell.p.y + h, h, polygonRings));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log(`num probes: ${numProbes}`);\n        console.log(`best distance: ${bestCell.d}`);\n    }\n\n    return bestCell.p;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.p = new Point(x, y);\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(this.p, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(p, polygon) {\n    let inside = false;\n    let minDistSq = Infinity;\n\n    for (let k = 0; k < polygon.length; k++) {\n        const ring = polygon[k];\n\n        for (let i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            const a = ring[i];\n            const b = ring[j];\n\n            if ((a.y > p.y !== b.y > p.y) &&\n                (p.x < (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, distToSegmentSquared(p, a, b));\n        }\n    }\n\n    return (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    let area = 0;\n    let x = 0;\n    let y = 0;\n    const points = polygon[0];\n    for (let i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        const a = points[i];\n        const b = points[j];\n        const f = a.x * b.y - b.x * a.y;\n        x += (a.x + b.x) * f;\n        y += (a.y + b.y) * f;\n        area += f * 3;\n    }\n    return new Cell(x / area, y / area, 0, polygon);\n}\n","/**\n * JS Implementation of MurmurHash3 (r136) (as of May 20, 2011)\n * \n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n * \n * @param {string} key ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash \n */\n\nfunction murmurhash3_32_gc(key, seed) {\n\tvar remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;\n\t\n\tremainder = key.length & 3; // key.length % 4\n\tbytes = key.length - remainder;\n\th1 = seed;\n\tc1 = 0xcc9e2d51;\n\tc2 = 0x1b873593;\n\ti = 0;\n\t\n\twhile (i < bytes) {\n\t  \tk1 = \n\t  \t  ((key.charCodeAt(i) & 0xff)) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 8) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 16) |\n\t  \t  ((key.charCodeAt(++i) & 0xff) << 24);\n\t\t++i;\n\t\t\n\t\tk1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;\n\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\tk1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;\n\n\t\th1 ^= k1;\n        h1 = (h1 << 13) | (h1 >>> 19);\n\t\th1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;\n\t\th1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));\n\t}\n\t\n\tk1 = 0;\n\t\n\tswitch (remainder) {\n\t\tcase 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;\n\t\tcase 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;\n\t\tcase 1: k1 ^= (key.charCodeAt(i) & 0xff);\n\t\t\n\t\tk1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;\n\t\tk1 = (k1 << 15) | (k1 >>> 17);\n\t\tk1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;\n\t\th1 ^= k1;\n\t}\n\t\n\th1 ^= key.length;\n\n\th1 ^= h1 >>> 16;\n\th1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;\n\th1 ^= h1 >>> 13;\n\th1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;\n\th1 ^= h1 >>> 16;\n\n\treturn h1 >>> 0;\n}\n\nif(typeof module !== \"undefined\") {\n  module.exports = murmurhash3_32_gc\n}","/**\n * JS Implementation of MurmurHash2\n * \n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/murmurhash-js\n * @author <a href=\"mailto:aappleby@gmail.com\">Austin Appleby</a>\n * @see http://sites.google.com/site/murmurhash/\n * \n * @param {string} str ASCII only\n * @param {number} seed Positive integer only\n * @return {number} 32-bit positive integer hash\n */\n\nfunction murmurhash2_32_gc(str, seed) {\n  var\n    l = str.length,\n    h = seed ^ l,\n    i = 0,\n    k;\n  \n  while (l >= 4) {\n  \tk = \n  \t  ((str.charCodeAt(i) & 0xff)) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 8) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 16) |\n  \t  ((str.charCodeAt(++i) & 0xff) << 24);\n    \n    k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n    k ^= k >>> 24;\n    k = (((k & 0xffff) * 0x5bd1e995) + ((((k >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n\n\th = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16)) ^ k;\n\n    l -= 4;\n    ++i;\n  }\n  \n  switch (l) {\n  case 3: h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n  case 2: h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n  case 1: h ^= (str.charCodeAt(i) & 0xff);\n          h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n  }\n\n  h ^= h >>> 13;\n  h = (((h & 0xffff) * 0x5bd1e995) + ((((h >>> 16) * 0x5bd1e995) & 0xffff) << 16));\n  h ^= h >>> 15;\n\n  return h >>> 0;\n}\n\nif(typeof module !== undefined) {\n  module.exports = murmurhash2_32_gc\n}\n","var murmur3 = require(\"./murmurhash3_gc.js\")\nvar murmur2 = require(\"./murmurhash2_gc.js\")\n\nmodule.exports = murmur3\nmodule.exports.murmur3 = murmur3\nmodule.exports.murmur2 = murmur2\n","// @flow\n\nimport Anchor from './anchor';\n\nimport { getAnchors, getCenterAnchor } from './get_anchors';\nimport clipLine from './clip_line';\nimport { shapeText, shapeIcon, WritingMode } from './shaping';\nimport { getGlyphQuads, getIconQuads } from './quads';\nimport CollisionFeature from './collision_feature';\nimport { warnOnce } from '../util/util';\nimport {\n    allowsVerticalWritingMode,\n    allowsLetterSpacing\n} from '../util/script_detection';\nimport findPoleOfInaccessibility from '../util/find_pole_of_inaccessibility';\nimport classifyRings from '../util/classify_rings';\nimport EXTENT from '../data/extent';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport {SIZE_PACK_FACTOR} from './symbol_size';\n\nimport type {Shaping, PositionedIcon} from './shaping';\nimport type {CollisionBoxArray} from '../data/array_types';\nimport type {SymbolFeature} from '../data/bucket/symbol_bucket';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {ImagePosition} from '../render/image_atlas';\nimport type {GlyphPosition} from '../render/glyph_atlas';\nimport type {PossiblyEvaluatedPropertyValue} from '../style/properties';\n\nimport Point from '@mapbox/point-geometry';\nimport murmur3 from 'murmurhash-js';\n\n// The symbol layout process needs `text-size` evaluated at up to five different zoom levels, and\n// `icon-size` at up to three:\n//\n//   1. `text-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `text-size`\n//       expressions, and to calculate the box dimensions for icon-text-fit.\n//   2. `icon-size` at the zoom level of the bucket. Used to calculate a per-feature size for source `icon-size`\n//       expressions.\n//   3. `text-size` and `icon-size` at the zoom level of the bucket, plus one. Used to calculate collision boxes.\n//   4. `text-size` at zoom level 18. Used for something line-symbol-placement-related.\n//   5.  For composite `*-size` expressions: two zoom levels of curve stops that \"cover\" the zoom level of the\n//       bucket. These go into a vertex buffer and are used by the shader to interpolate the size at render time.\n//\n// (1) and (2) are stored in `bucket.layers[0].layout`. The remainder are below.\n//\ntype Sizes = {\n    layoutTextSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    layoutIconSize: PossiblyEvaluatedPropertyValue<number>, // (3)\n    textMaxSize: PossiblyEvaluatedPropertyValue<number>,    // (4)\n    compositeTextSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n    compositeIconSizes: [PossiblyEvaluatedPropertyValue<number>, PossiblyEvaluatedPropertyValue<number>], // (5)\n};\n\nexport function performSymbolLayout(bucket: SymbolBucket,\n                             glyphMap: {[string]: {[number]: ?StyleGlyph}},\n                             glyphPositions: {[string]: {[number]: GlyphPosition}},\n                             imageMap: {[string]: StyleImage},\n                             imagePositions: {[string]: ImagePosition},\n                             showCollisionBoxes: boolean) {\n    bucket.createArrays();\n\n    const tileSize = 512 * bucket.overscaling;\n    bucket.tilePixelRatio = EXTENT / tileSize;\n    bucket.compareText = {};\n    bucket.iconsNeedLinear = false;\n\n    const layout = bucket.layers[0].layout;\n    const unevaluatedLayoutValues = bucket.layers[0]._unevaluatedLayout._values;\n\n    const sizes = {};\n\n    if (bucket.textSizeData.functionType === 'composite') {\n        const {min, max} = bucket.textSizeData.zoomRange;\n        sizes.compositeTextSizes = [\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(min)),\n            unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(max))\n        ];\n    }\n\n    if (bucket.iconSizeData.functionType === 'composite') {\n        const {min, max} = bucket.iconSizeData.zoomRange;\n        sizes.compositeIconSizes = [\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(min)),\n            unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(max))\n        ];\n    }\n\n    sizes.layoutTextSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.layoutIconSize = unevaluatedLayoutValues['icon-size'].possiblyEvaluate(new EvaluationParameters(bucket.zoom + 1));\n    sizes.textMaxSize = unevaluatedLayoutValues['text-size'].possiblyEvaluate(new EvaluationParameters(18));\n\n    const oneEm = 24;\n    const lineHeight = layout.get('text-line-height') * oneEm;\n    const textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point';\n    const keepUpright = layout.get('text-keep-upright');\n\n\n    for (const feature of bucket.features) {\n        const fontstack = layout.get('text-font').evaluate(feature, {}).join(',');\n        const glyphPositionMap = glyphPositions;\n\n        const shapedTextOrientations = {};\n        const text = feature.text;\n        if (text) {\n            const unformattedText = text.toString();\n            const textOffset: [number, number] = (layout.get('text-offset').evaluate(feature, {}).map((t) => t * oneEm): any);\n            const spacing = layout.get('text-letter-spacing').evaluate(feature, {}) * oneEm;\n            const spacingIfAllowed = allowsLetterSpacing(unformattedText) ? spacing : 0;\n            const textAnchor = layout.get('text-anchor').evaluate(feature, {});\n            const textJustify = layout.get('text-justify').evaluate(feature, {});\n            const maxWidth = layout.get('symbol-placement') === 'point' ?\n                layout.get('text-max-width').evaluate(feature, {}) * oneEm :\n                0;\n\n            shapedTextOrientations.horizontal = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, oneEm, WritingMode.horizontal);\n            if (allowsVerticalWritingMode(unformattedText) && textAlongLine && keepUpright) {\n                shapedTextOrientations.vertical = shapeText(text, glyphMap, fontstack, maxWidth, lineHeight, textAnchor, textJustify, spacingIfAllowed, textOffset, oneEm, WritingMode.vertical);\n            }\n        }\n\n        let shapedIcon;\n        if (feature.icon) {\n            const image = imageMap[feature.icon];\n            if (image) {\n                shapedIcon = shapeIcon(\n                    imagePositions[feature.icon],\n                    layout.get('icon-offset').evaluate(feature, {}),\n                    layout.get('icon-anchor').evaluate(feature, {}));\n                if (bucket.sdfIcons === undefined) {\n                    bucket.sdfIcons = image.sdf;\n                } else if (bucket.sdfIcons !== image.sdf) {\n                    warnOnce('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer');\n                }\n                if (image.pixelRatio !== bucket.pixelRatio) {\n                    bucket.iconsNeedLinear = true;\n                } else if (layout.get('icon-rotate').constantOr(1) !== 0) {\n                    bucket.iconsNeedLinear = true;\n                }\n            }\n        }\n\n        if (shapedTextOrientations.horizontal || shapedIcon) {\n            addFeature(bucket, feature, shapedTextOrientations, shapedIcon, glyphPositionMap, sizes);\n        }\n    }\n\n    if (showCollisionBoxes) {\n        bucket.generateCollisionDebugBuffers();\n    }\n}\n\n\n/**\n * Given a feature and its shaped text and icon data, add a 'symbol\n * instance' for each _possible_ placement of the symbol feature.\n * (At render timePlaceSymbols#place() selects which of these instances to\n * show or hide based on collisions with symbols in other layers.)\n * @private\n */\nfunction addFeature(bucket: SymbolBucket,\n                    feature: SymbolFeature,\n                    shapedTextOrientations: any,\n                    shapedIcon: PositionedIcon | void,\n                    glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                    sizes: Sizes) {\n    const layoutTextSize = sizes.layoutTextSize.evaluate(feature, {});\n    const layoutIconSize = sizes.layoutIconSize.evaluate(feature, {});\n\n    // To reduce the number of labels that jump around when zooming we need\n    // to use a text-size value that is the same for all zoom levels.\n    // bucket calculates text-size at a high zoom level so that all tiles can\n    // use the same value when calculating anchor positions.\n    let textMaxSize = sizes.textMaxSize.evaluate(feature, {});\n    if (textMaxSize === undefined) {\n        textMaxSize = layoutTextSize;\n    }\n\n    const layout = bucket.layers[0].layout;\n    const textOffset = layout.get('text-offset').evaluate(feature, {});\n    const iconOffset = layout.get('icon-offset').evaluate(feature, {});\n\n    const glyphSize = 24,\n        fontScale = layoutTextSize / glyphSize,\n        textBoxScale = bucket.tilePixelRatio * fontScale,\n        textMaxBoxScale = bucket.tilePixelRatio * textMaxSize / glyphSize,\n        iconBoxScale = bucket.tilePixelRatio * layoutIconSize,\n        symbolMinDistance = bucket.tilePixelRatio * layout.get('symbol-spacing'),\n        textPadding = layout.get('text-padding') * bucket.tilePixelRatio,\n        iconPadding = layout.get('icon-padding') * bucket.tilePixelRatio,\n        textMaxAngle = layout.get('text-max-angle') / 180 * Math.PI,\n        textAlongLine = layout.get('text-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        iconAlongLine = layout.get('icon-rotation-alignment') === 'map' && layout.get('symbol-placement') !== 'point',\n        symbolPlacement = layout.get('symbol-placement'),\n        textRepeatDistance = symbolMinDistance / 2;\n\n    const addSymbolAtAnchor = (line, anchor) => {\n        if (anchor.x < 0 || anchor.x >= EXTENT || anchor.y < 0 || anchor.y >= EXTENT) {\n            // Symbol layers are drawn across tile boundaries, We filter out symbols\n            // outside our tile boundaries (which may be included in vector tile buffers)\n            // to prevent double-drawing symbols.\n            return;\n        }\n\n        addSymbol(bucket, anchor, line, shapedTextOrientations, shapedIcon, bucket.layers[0],\n            bucket.collisionBoxArray, feature.index, feature.sourceLayerIndex, bucket.index,\n            textBoxScale, textPadding, textAlongLine, textOffset,\n            iconBoxScale, iconPadding, iconAlongLine, iconOffset,\n            feature, glyphPositionMap, sizes);\n    };\n\n    if (symbolPlacement === 'line') {\n        for (const line of clipLine(feature.geometry, 0, 0, EXTENT, EXTENT)) {\n            const anchors = getAnchors(\n                line,\n                symbolMinDistance,\n                textMaxAngle,\n                shapedTextOrientations.vertical || shapedTextOrientations.horizontal,\n                shapedIcon,\n                glyphSize,\n                textMaxBoxScale,\n                bucket.overscaling,\n                EXTENT\n            );\n            for (const anchor of anchors) {\n                const shapedText = shapedTextOrientations.horizontal;\n                if (!shapedText || !anchorIsTooClose(bucket, shapedText.text, textRepeatDistance, anchor)) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (symbolPlacement === 'line-center') {\n        // No clipping, multiple lines per feature are allowed\n        // \"lines\" with only one point are ignored as in clipLines\n        for (const line of feature.geometry) {\n            if (line.length > 1) {\n                const anchor = getCenterAnchor(\n                    line,\n                    textMaxAngle,\n                    shapedTextOrientations.vertical || shapedTextOrientations.horizontal,\n                    shapedIcon,\n                    glyphSize,\n                    textMaxBoxScale);\n                if (anchor) {\n                    addSymbolAtAnchor(line, anchor);\n                }\n            }\n        }\n    } else if (feature.type === 'Polygon') {\n        for (const polygon of classifyRings(feature.geometry, 0)) {\n            // 16 here represents 2 pixels\n            const poi = findPoleOfInaccessibility(polygon, 16);\n            addSymbolAtAnchor(polygon[0], new Anchor(poi.x, poi.y, 0));\n        }\n    } else if (feature.type === 'LineString') {\n        // https://github.com/mapbox/mapbox-gl-js/issues/3808\n        for (const line of feature.geometry) {\n            addSymbolAtAnchor(line, new Anchor(line[0].x, line[0].y, 0));\n        }\n    } else if (feature.type === 'Point') {\n        for (const points of feature.geometry) {\n            for (const point of points) {\n                addSymbolAtAnchor([point], new Anchor(point.x, point.y, 0));\n            }\n        }\n    }\n}\n\nconst MAX_PACKED_SIZE = 65535;\n\nfunction addTextVertices(bucket: SymbolBucket,\n                         anchor: Point,\n                         shapedText: Shaping,\n                         layer: SymbolStyleLayer,\n                         textAlongLine: boolean,\n                         feature: SymbolFeature,\n                         textOffset: [number, number],\n                         lineArray: {lineStartIndex: number, lineLength: number},\n                         writingMode: number,\n                         placedTextSymbolIndices: Array<number>,\n                         glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                         sizes: Sizes) {\n    const glyphQuads = getGlyphQuads(anchor, shapedText,\n                            layer, textAlongLine, feature, glyphPositionMap);\n\n    const sizeData = bucket.textSizeData;\n    let textSizeData = null;\n\n    if (sizeData.functionType === 'source') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * layer.layout.get('text-size').evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    } else if (sizeData.functionType === 'composite') {\n        textSizeData = [\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[0].evaluate(feature, {}),\n            SIZE_PACK_FACTOR * sizes.compositeTextSizes[1].evaluate(feature, {})\n        ];\n        if (textSizeData[0] > MAX_PACKED_SIZE || textSizeData[1] > MAX_PACKED_SIZE) {\n            warnOnce(`${bucket.layerIds[0]}: Value for \"text-size\" is >= 256. Reduce your \"text-size\".`);\n        }\n    }\n\n    bucket.addSymbols(\n        bucket.text,\n        glyphQuads,\n        textSizeData,\n        textOffset,\n        textAlongLine,\n        feature,\n        writingMode,\n        anchor,\n        lineArray.lineStartIndex,\n        lineArray.lineLength);\n\n    // The placedSymbolArray is used at render time in drawTileSymbols\n    // These indices allow access to the array at collision detection time\n    placedTextSymbolIndices.push(bucket.text.placedSymbolArray.length - 1);\n\n    return glyphQuads.length * 4;\n}\n\n\n/**\n * Add a single label & icon placement.\n *\n * @private\n */\nfunction addSymbol(bucket: SymbolBucket,\n                   anchor: Anchor,\n                   line: Array<Point>,\n                   shapedTextOrientations: any,\n                   shapedIcon: PositionedIcon | void,\n                   layer: SymbolStyleLayer,\n                   collisionBoxArray: CollisionBoxArray,\n                   featureIndex: number,\n                   sourceLayerIndex: number,\n                   bucketIndex: number,\n                   textBoxScale: number,\n                   textPadding: number,\n                   textAlongLine: boolean,\n                   textOffset: [number, number],\n                   iconBoxScale: number,\n                   iconPadding: number,\n                   iconAlongLine: boolean,\n                   iconOffset: [number, number],\n                   feature: SymbolFeature,\n                   glyphPositionMap: {[string]: {[number]: GlyphPosition}},\n                   sizes: Sizes) {\n    const lineArray = bucket.addToLineVertexArray(anchor, line);\n\n    let textCollisionFeature, iconCollisionFeature;\n\n    let numIconVertices = 0;\n    let numGlyphVertices = 0;\n    let numVerticalGlyphVertices = 0;\n    const key = murmur3(shapedTextOrientations.horizontal ? shapedTextOrientations.horizontal.text : '');\n    const placedTextSymbolIndices = [];\n    if (shapedTextOrientations.horizontal) {\n        // As a collision approximation, we can use either the vertical or the horizontal version of the feature\n        // We're counting on the two versions having similar dimensions\n        const textRotate = layer.layout.get('text-rotate').evaluate(feature, {});\n        textCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedTextOrientations.horizontal, textBoxScale, textPadding, textAlongLine, bucket.overscaling, textRotate);\n        numGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.horizontal, layer, textAlongLine, feature, textOffset, lineArray, shapedTextOrientations.vertical ? WritingMode.horizontal : WritingMode.horizontalOnly, placedTextSymbolIndices, glyphPositionMap, sizes);\n\n        if (shapedTextOrientations.vertical) {\n            numVerticalGlyphVertices += addTextVertices(bucket, anchor, shapedTextOrientations.vertical, layer, textAlongLine, feature, textOffset, lineArray, WritingMode.vertical, placedTextSymbolIndices, glyphPositionMap, sizes);\n        }\n    }\n\n    const textBoxStartIndex = textCollisionFeature ? textCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const textBoxEndIndex = textCollisionFeature ? textCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (shapedIcon) {\n        const iconQuads = getIconQuads(anchor, shapedIcon, layer,\n                            iconAlongLine, shapedTextOrientations.horizontal,\n                            feature);\n        const iconRotate = layer.layout.get('icon-rotate').evaluate(feature, {});\n        iconCollisionFeature = new CollisionFeature(collisionBoxArray, line, anchor, featureIndex, sourceLayerIndex, bucketIndex, shapedIcon, iconBoxScale, iconPadding, /*align boxes to line*/false, bucket.overscaling, iconRotate);\n\n        numIconVertices = iconQuads.length * 4;\n\n        const sizeData = bucket.iconSizeData;\n        let iconSizeData = null;\n\n        if (sizeData.functionType === 'source') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * layer.layout.get('icon-size').evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        } else if (sizeData.functionType === 'composite') {\n            iconSizeData = [\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[0].evaluate(feature, {}),\n                SIZE_PACK_FACTOR * sizes.compositeIconSizes[1].evaluate(feature, {})\n            ];\n            if (iconSizeData[0] > MAX_PACKED_SIZE || iconSizeData[1] > MAX_PACKED_SIZE) {\n                warnOnce(`${bucket.layerIds[0]}: Value for \"icon-size\" is >= 256. Reduce your \"icon-size\".`);\n            }\n        }\n\n        bucket.addSymbols(\n            bucket.icon,\n            iconQuads,\n            iconSizeData,\n            iconOffset,\n            iconAlongLine,\n            feature,\n            false,\n            anchor,\n            lineArray.lineStartIndex,\n            lineArray.lineLength);\n    }\n\n    const iconBoxStartIndex = iconCollisionFeature ? iconCollisionFeature.boxStartIndex : bucket.collisionBoxArray.length;\n    const iconBoxEndIndex = iconCollisionFeature ? iconCollisionFeature.boxEndIndex : bucket.collisionBoxArray.length;\n\n    if (bucket.glyphOffsetArray.length >= SymbolBucket.MAX_GLYPHS) warnOnce(\n        \"Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907\"\n    );\n\n    bucket.symbolInstances.emplaceBack(\n        anchor.x,\n        anchor.y,\n        placedTextSymbolIndices.length > 0 ? placedTextSymbolIndices[0] : -1,\n        placedTextSymbolIndices.length > 1 ? placedTextSymbolIndices[1] : -1,\n        key,\n        textBoxStartIndex,\n        textBoxEndIndex,\n        iconBoxStartIndex,\n        iconBoxEndIndex,\n        featureIndex,\n        numGlyphVertices,\n        numVerticalGlyphVertices,\n        numIconVertices,\n        0);\n}\n\nfunction anchorIsTooClose(bucket: any, text: string, repeatDistance: number, anchor: Point) {\n    const compareText = bucket.compareText;\n    if (!(text in compareText)) {\n        compareText[text] = [];\n    } else {\n        const otherAnchors = compareText[text];\n        for (let k = otherAnchors.length - 1; k >= 0; k--) {\n            if (anchor.dist(otherAnchors[k]) < repeatDistance) {\n                // If it's within repeatDistance of one anchor, stop looking\n                return true;\n            }\n        }\n    }\n    // If anchor is not within repeatDistance of any other anchor, add to array\n    compareText[text].push(anchor);\n    return false;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport { GLYPH_PBF_BORDER } from '../style/parse_glyph_pbf';\n\nimport type Anchor from './anchor';\nimport type {PositionedIcon, Shaping} from './shaping';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type {Feature} from '../style-spec/expression';\nimport type {GlyphPosition} from '../render/glyph_atlas';\n\n/**\n * A textured quad for rendering a single icon or glyph.\n *\n * The zoom range the glyph can be shown is defined by minScale and maxScale.\n *\n * @param tl The offset of the top left corner from the anchor.\n * @param tr The offset of the top right corner from the anchor.\n * @param bl The offset of the bottom left corner from the anchor.\n * @param br The offset of the bottom right corner from the anchor.\n * @param tex The texture coordinates.\n *\n * @private\n */\nexport type SymbolQuad = {\n    tl: Point,\n    tr: Point,\n    bl: Point,\n    br: Point,\n    tex: {\n        x: number,\n        y: number,\n        w: number,\n        h: number\n    },\n    writingMode: any | void,\n    glyphOffset: [number, number]\n};\n\n/**\n * Create the quads used for rendering an icon.\n * @private\n */\nexport function getIconQuads(anchor: Anchor,\n                      shapedIcon: PositionedIcon,\n                      layer: SymbolStyleLayer,\n                      alongLine: boolean,\n                      shapedText: Shaping,\n                      feature: Feature): Array<SymbolQuad> {\n    const image = shapedIcon.image;\n    const layout = layer.layout;\n\n    // If you have a 10px icon that isn't perfectly aligned to the pixel grid it will cover 11 actual\n    // pixels. The quad needs to be padded to account for this, otherwise they'll look slightly clipped\n    // on one edge in some cases.\n    const border = 1;\n\n    const top = shapedIcon.top - border / image.pixelRatio;\n    const left = shapedIcon.left - border / image.pixelRatio;\n    const bottom = shapedIcon.bottom + border / image.pixelRatio;\n    const right = shapedIcon.right + border / image.pixelRatio;\n    let tl, tr, br, bl;\n\n    // text-fit mode\n    if (layout.get('icon-text-fit') !== 'none' && shapedText) {\n        const iconWidth = (right - left),\n            iconHeight = (bottom - top),\n            size = layout.get('text-size').evaluate(feature, {}) / 24,\n            textLeft = shapedText.left * size,\n            textRight = shapedText.right * size,\n            textTop = shapedText.top * size,\n            textBottom = shapedText.bottom * size,\n            textWidth = textRight - textLeft,\n            textHeight = textBottom - textTop,\n            padT = layout.get('icon-text-fit-padding')[0],\n            padR = layout.get('icon-text-fit-padding')[1],\n            padB = layout.get('icon-text-fit-padding')[2],\n            padL = layout.get('icon-text-fit-padding')[3],\n            offsetY = layout.get('icon-text-fit') === 'width' ? (textHeight - iconHeight) * 0.5 : 0,\n            offsetX = layout.get('icon-text-fit') === 'height' ? (textWidth - iconWidth) * 0.5 : 0,\n            width = layout.get('icon-text-fit') === 'width' || layout.get('icon-text-fit') === 'both' ? textWidth : iconWidth,\n            height = layout.get('icon-text-fit') === 'height' || layout.get('icon-text-fit') === 'both' ? textHeight : iconHeight;\n        tl = new Point(textLeft + offsetX - padL,         textTop + offsetY - padT);\n        tr = new Point(textLeft + offsetX + padR + width, textTop + offsetY - padT);\n        br = new Point(textLeft + offsetX + padR + width, textTop + offsetY + padB + height);\n        bl = new Point(textLeft + offsetX - padL,         textTop + offsetY + padB + height);\n    // Normal icon size mode\n    } else {\n        tl = new Point(left, top);\n        tr = new Point(right, top);\n        br = new Point(right, bottom);\n        bl = new Point(left, bottom);\n    }\n\n    const angle = layer.layout.get('icon-rotate').evaluate(feature, {}) * Math.PI / 180;\n\n    if (angle) {\n        const sin = Math.sin(angle),\n            cos = Math.cos(angle),\n            matrix = [cos, -sin, sin, cos];\n\n        tl._matMult(matrix);\n        tr._matMult(matrix);\n        bl._matMult(matrix);\n        br._matMult(matrix);\n    }\n\n    // Icon quad is padded, so texture coordinates also need to be padded.\n    return [{tl, tr, bl, br, tex: image.paddedRect, writingMode: undefined, glyphOffset: [0, 0]}];\n}\n\n/**\n * Create the quads used for rendering a text label.\n * @private\n */\nexport function getGlyphQuads(anchor: Anchor,\n                       shaping: Shaping,\n                       layer: SymbolStyleLayer,\n                       alongLine: boolean,\n                       feature: Feature,\n                       positions: {[string]: {[number]: GlyphPosition}}): Array<SymbolQuad> {\n\n    const oneEm = 24;\n    const textRotate = layer.layout.get('text-rotate').evaluate(feature, {}) * Math.PI / 180;\n    const textOffset = layer.layout.get('text-offset').evaluate(feature, {}).map((t) => t * oneEm);\n\n    const positionedGlyphs = shaping.positionedGlyphs;\n    const quads = [];\n\n\n    for (let k = 0; k < positionedGlyphs.length; k++) {\n        const positionedGlyph = positionedGlyphs[k];\n        const glyphPositions = positions[positionedGlyph.fontStack];\n        const glyph = glyphPositions && glyphPositions[positionedGlyph.glyph];\n        if (!glyph) continue;\n\n        const rect = glyph.rect;\n        if (!rect) continue;\n\n        // The rects have an addditional buffer that is not included in their size.\n        const glyphPadding = 1.0;\n        const rectBuffer = GLYPH_PBF_BORDER + glyphPadding;\n\n        const halfAdvance = glyph.metrics.advance * positionedGlyph.scale / 2;\n\n        const glyphOffset = alongLine ?\n            [positionedGlyph.x + halfAdvance, positionedGlyph.y] :\n            [0, 0];\n\n        const builtInOffset = alongLine ?\n            [0, 0] :\n            [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];\n\n        const x1 = (glyph.metrics.left - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n        const y1 = (-glyph.metrics.top - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n        const x2 = x1 + rect.w * positionedGlyph.scale;\n        const y2 = y1 + rect.h * positionedGlyph.scale;\n\n        const tl = new Point(x1, y1);\n        const tr = new Point(x2, y1);\n        const bl  = new Point(x1, y2);\n        const br = new Point(x2, y2);\n\n        if (alongLine && positionedGlyph.vertical) {\n            // Vertical-supporting glyphs are laid out in 24x24 point boxes (1 square em)\n            // In horizontal orientation, the y values for glyphs are below the midline\n            // and we use a \"yOffset\" of -17 to pull them up to the middle.\n            // By rotating counter-clockwise around the point at the center of the left\n            // edge of a 24x24 layout box centered below the midline, we align the center\n            // of the glyphs with the horizontal midline, so the yOffset is no longer\n            // necessary, but we also pull the glyph to the left along the x axis\n            const center = new Point(-halfAdvance, halfAdvance);\n            const verticalRotation = -Math.PI / 2;\n            const xOffsetCorrection = new Point(5, 0);\n            tl._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            tr._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            bl._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n            br._rotateAround(verticalRotation, center)._add(xOffsetCorrection);\n        }\n\n        if (textRotate) {\n            const sin = Math.sin(textRotate),\n                cos = Math.cos(textRotate),\n                matrix = [cos, -sin, sin, cos];\n\n            tl._matMult(matrix);\n            tr._matMult(matrix);\n            bl._matMult(matrix);\n            br._matMult(matrix);\n        }\n\n        quads.push({tl, tr, bl, br, tex: rect, writingMode: shaping.writingMode, glyphOffset});\n    }\n\n    return quads;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nexport default clipLine;\n\n/**\n * Returns the part of a multiline that intersects with the provided rectangular box.\n *\n * @param lines\n * @param x1 the left edge of the box\n * @param y1 the top edge of the box\n * @param x2 the right edge of the box\n * @param y2 the bottom edge of the box\n * @returns lines\n * @private\n */\nfunction clipLine(lines: Array<Array<Point>>, x1: number, y1: number, x2: number, y2: number): Array<Array<Point>> {\n    const clippedLines = [];\n\n    for (let l = 0; l < lines.length; l++) {\n        const line = lines[l];\n        let clippedLine;\n\n        for (let i = 0; i < line.length - 1; i++) {\n            let p0 = line[i];\n            let p1 = line[i + 1];\n\n\n            if (p0.x < x1 && p1.x < x1) {\n                continue;\n            } else if (p0.x < x1) {\n                p0 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x < x1) {\n                p1 = new Point(x1, p0.y + (p1.y - p0.y) * ((x1 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y < y1 && p1.y < y1) {\n                continue;\n            } else if (p0.y < y1) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            } else if (p1.y < y1) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y1 - p0.y) / (p1.y - p0.y)), y1)._round();\n            }\n\n            if (p0.x >= x2 && p1.x >= x2) {\n                continue;\n            } else if (p0.x >= x2) {\n                p0 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            } else if (p1.x >= x2) {\n                p1 = new Point(x2, p0.y + (p1.y - p0.y) * ((x2 - p0.x) / (p1.x - p0.x)))._round();\n            }\n\n            if (p0.y >= y2 && p1.y >= y2) {\n                continue;\n            } else if (p0.y >= y2) {\n                p0 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            } else if (p1.y >= y2) {\n                p1 = new Point(p0.x + (p1.x - p0.x) * ((y2 - p0.y) / (p1.y - p0.y)), y2)._round();\n            }\n\n            if (!clippedLine || !p0.equals(clippedLine[clippedLine.length - 1])) {\n                clippedLine = [p0];\n                clippedLines.push(clippedLine);\n            }\n\n            clippedLine.push(p1);\n        }\n    }\n\n    return clippedLines;\n}\n","// @flow\n\nimport { AlphaImage } from '../util/image';\nimport { register } from '../util/web_worker_transfer';\nimport potpack from 'potpack';\n\nimport type {GlyphMetrics, StyleGlyph} from '../style/style_glyph';\n\nconst padding = 1;\n\ntype Rect = {\n    x: number,\n    y: number,\n    w: number,\n    h: number\n};\n\nexport type GlyphPosition = {\n    rect: Rect,\n    metrics: GlyphMetrics\n};\n\nexport type GlyphPositions = { [string]: { [number]: GlyphPosition } }\n\nexport default class GlyphAtlas {\n    image: AlphaImage;\n    positions: GlyphPositions;\n\n    constructor(stacks: { [string]: { [number]: ?StyleGlyph } }) {\n        const positions = {};\n        const bins = [];\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n            const stackPositions = positions[stack] = {};\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n\n                const bin = {\n                    x: 0,\n                    y: 0,\n                    w: src.bitmap.width + 2 * padding,\n                    h: src.bitmap.height + 2 * padding\n                };\n                bins.push(bin);\n                stackPositions[id] = {rect: bin, metrics: src.metrics};\n            }\n        }\n\n        const {w, h} = potpack(bins);\n        const image = new AlphaImage({width: w || 1, height: h || 1});\n\n        for (const stack in stacks) {\n            const glyphs = stacks[stack];\n\n            for (const id in glyphs) {\n                const src = glyphs[+id];\n                if (!src || src.bitmap.width === 0 || src.bitmap.height === 0) continue;\n                const bin = positions[stack][id].rect;\n                AlphaImage.copy(src.bitmap, image, {x: 0, y: 0}, {x: bin.x + padding, y: bin.y + padding}, src.bitmap);\n            }\n        }\n\n        this.image = image;\n        this.positions = positions;\n    }\n}\n\nregister('GlyphAtlas', GlyphAtlas);\n","// @flow\n\nimport FeatureIndex from '../data/feature_index';\n\nimport { performSymbolLayout } from '../symbol/symbol_layout';\nimport { CollisionBoxArray } from '../data/array_types';\nimport DictionaryCoder from '../util/dictionary_coder';\nimport SymbolBucket from '../data/bucket/symbol_bucket';\nimport LineBucket from '../data/bucket/line_bucket';\nimport FillBucket from '../data/bucket/fill_bucket';\nimport FillExtrusionBucket from '../data/bucket/fill_extrusion_bucket';\nimport { warnOnce, mapObject, values } from '../util/util';\nimport assert from 'assert';\nimport ImageAtlas from '../render/image_atlas';\nimport GlyphAtlas from '../render/glyph_atlas';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport { OverscaledTileID } from './tile_id';\n\nimport type {Bucket} from '../data/bucket';\nimport type Actor from '../util/actor';\nimport type StyleLayer from '../style/style_layer';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {StyleImage} from '../style/style_image';\nimport type {StyleGlyph} from '../style/style_glyph';\nimport type {\n    WorkerTileParameters,\n    WorkerTileCallback,\n} from '../source/worker_source';\n\nclass WorkerTile {\n    tileID: OverscaledTileID;\n    uid: string;\n    zoom: number;\n    pixelRatio: number;\n    tileSize: number;\n    source: string;\n    overscaling: number;\n    showCollisionBoxes: boolean;\n    collectResourceTiming: boolean;\n    returnDependencies: boolean;\n\n    status: 'parsing' | 'done';\n    data: VectorTile;\n    collisionBoxArray: CollisionBoxArray;\n\n    abort: ?() => void;\n    reloadCallback: WorkerTileCallback;\n    vectorTile: VectorTile;\n\n    constructor(params: WorkerTileParameters) {\n        this.tileID = new OverscaledTileID(params.tileID.overscaledZ, params.tileID.wrap, params.tileID.canonical.z, params.tileID.canonical.x, params.tileID.canonical.y);\n        this.uid = params.uid;\n        this.zoom = params.zoom;\n        this.pixelRatio = params.pixelRatio;\n        this.tileSize = params.tileSize;\n        this.source = params.source;\n        this.overscaling = this.tileID.overscaleFactor();\n        this.showCollisionBoxes = params.showCollisionBoxes;\n        this.collectResourceTiming = !!params.collectResourceTiming;\n        this.returnDependencies = !!params.returnDependencies;\n    }\n\n    parse(data: VectorTile, layerIndex: StyleLayerIndex, actor: Actor, callback: WorkerTileCallback) {\n        this.status = 'parsing';\n        this.data = data;\n\n        this.collisionBoxArray = new CollisionBoxArray();\n        const sourceLayerCoder = new DictionaryCoder(Object.keys(data.layers).sort());\n\n        const featureIndex = new FeatureIndex(this.tileID);\n        featureIndex.bucketLayerIDs = [];\n\n        const buckets: {[string]: Bucket} = {};\n\n        const options = {\n            featureIndex,\n            iconDependencies: {},\n            patternDependencies: {},\n            glyphDependencies: {}\n        };\n\n        const layerFamilies = layerIndex.familiesBySource[this.source];\n        for (const sourceLayerId in layerFamilies) {\n            const sourceLayer = data.layers[sourceLayerId];\n            if (!sourceLayer) {\n                continue;\n            }\n\n            if (sourceLayer.version === 1) {\n                warnOnce(`Vector tile source \"${this.source}\" layer \"${sourceLayerId}\" ` +\n                    `does not use vector tile spec v2 and therefore may have some rendering errors.`);\n            }\n\n            const sourceLayerIndex = sourceLayerCoder.encode(sourceLayerId);\n            const features = [];\n            for (let index = 0; index < sourceLayer.length; index++) {\n                const feature = sourceLayer.feature(index);\n                features.push({ feature, index, sourceLayerIndex });\n            }\n\n            for (const family of layerFamilies[sourceLayerId]) {\n                const layer = family[0];\n\n                assert(layer.source === this.source);\n                if (layer.minzoom && this.zoom < Math.floor(layer.minzoom)) continue;\n                if (layer.maxzoom && this.zoom >= layer.maxzoom) continue;\n                if (layer.visibility === 'none') continue;\n\n                recalculateLayers(family, this.zoom);\n\n                const bucket = buckets[layer.id] = layer.createBucket({\n                    index: featureIndex.bucketLayerIDs.length,\n                    layers: family,\n                    zoom: this.zoom,\n                    pixelRatio: this.pixelRatio,\n                    overscaling: this.overscaling,\n                    collisionBoxArray: this.collisionBoxArray,\n                    sourceLayerIndex,\n                    sourceID: this.source\n                });\n\n                bucket.populate(features, options);\n                featureIndex.bucketLayerIDs.push(family.map((l) => l.id));\n            }\n        }\n\n        let error: ?Error;\n        let glyphMap: ?{[string]: {[number]: ?StyleGlyph}};\n        let iconMap: ?{[string]: StyleImage};\n        let patternMap: ?{[string]: StyleImage};\n\n        const stacks = mapObject(options.glyphDependencies, (glyphs) => Object.keys(glyphs).map(Number));\n        if (Object.keys(stacks).length) {\n            actor.send('getGlyphs', {uid: this.uid, stacks}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    glyphMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            glyphMap = {};\n        }\n\n        const icons = Object.keys(options.iconDependencies);\n        if (icons.length) {\n            actor.send('getImages', {icons}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    iconMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            iconMap = {};\n        }\n\n        const patterns = Object.keys(options.patternDependencies);\n        if (patterns.length) {\n            actor.send('getImages', {icons: patterns}, (err, result) => {\n                if (!error) {\n                    error = err;\n                    patternMap = result;\n                    maybePrepare.call(this);\n                }\n            });\n        } else {\n            patternMap = {};\n        }\n\n\n        maybePrepare.call(this);\n\n        function maybePrepare() {\n            if (error) {\n                return callback(error);\n            } else if (glyphMap && iconMap && patternMap) {\n                const glyphAtlas = new GlyphAtlas(glyphMap);\n                const imageAtlas = new ImageAtlas(iconMap, patternMap);\n\n                for (const key in buckets) {\n                    const bucket = buckets[key];\n                    if (bucket instanceof SymbolBucket) {\n                        recalculateLayers(bucket.layers, this.zoom);\n                        performSymbolLayout(bucket, glyphMap, glyphAtlas.positions, iconMap, imageAtlas.iconPositions, this.showCollisionBoxes);\n                    } else if (bucket.hasPattern &&\n                        (bucket instanceof LineBucket ||\n                         bucket instanceof FillBucket ||\n                         bucket instanceof FillExtrusionBucket)) {\n                        recalculateLayers(bucket.layers, this.zoom);\n                        bucket.addFeatures(options, imageAtlas.patternPositions);\n                    }\n                }\n\n                this.status = 'done';\n                callback(null, {\n                    buckets: values(buckets).filter(b => !b.isEmpty()),\n                    featureIndex,\n                    collisionBoxArray: this.collisionBoxArray,\n                    glyphAtlasImage: glyphAtlas.image,\n                    imageAtlas,\n                    // Only used for benchmarking:\n                    glyphMap: this.returnDependencies ? glyphMap : null,\n                    iconMap: this.returnDependencies ? iconMap : null,\n                    glyphPositions: this.returnDependencies ? glyphAtlas.positions : null\n                });\n            }\n        }\n    }\n}\n\nfunction recalculateLayers(layers: $ReadOnlyArray<StyleLayer>, zoom: number) {\n    // Layers are shared and may have been used by a WorkerTile with a different zoom.\n    const parameters = new EvaluationParameters(zoom);\n    for (const layer of layers) {\n        layer.recalculate(parameters);\n    }\n}\n\nexport default WorkerTile;\n","// @flow\n\nimport type {RequestParameters} from '../util/ajax';\n\n// Wraps performance to facilitate testing\n// Not incorporated into browser.js because the latter is poisonous when used outside the main thread\nconst performanceExists = typeof performance !== 'undefined';\nconst wrapper = {};\n\nwrapper.getEntriesByName = (url: string) => {\n    if (performanceExists && performance && performance.getEntriesByName)\n        return performance.getEntriesByName(url);\n    else\n        return false;\n};\n\nwrapper.mark = (name: string) => {\n    if (performanceExists && performance && performance.mark)\n        return performance.mark(name);\n    else\n        return false;\n};\n\nwrapper.measure = (name: string, startMark: string, endMark: string) => {\n    if (performanceExists && performance && performance.measure)\n        return performance.measure(name, startMark, endMark);\n    else\n        return false;\n};\n\nwrapper.clearMarks = (name: string) => {\n    if (performanceExists && performance && performance.clearMarks)\n        return performance.clearMarks(name);\n    else\n        return false;\n};\n\nwrapper.clearMeasures = (name: string) => {\n    if (performanceExists && performance && performance.clearMeasures)\n        return performance.clearMeasures(name);\n    else\n        return false;\n};\n\n/**\n * Safe wrapper for the performance resource timing API in web workers with graceful degradation\n *\n * @param {RequestParameters} request\n * @private\n */\nclass Performance {\n    _marks: {start: string, end: string, measure: string};\n\n    constructor (request: RequestParameters) {\n        this._marks = {\n            start: [request.url, 'start'].join('#'),\n            end: [request.url, 'end'].join('#'),\n            measure: request.url.toString()\n        };\n\n        wrapper.mark(this._marks.start);\n    }\n\n    finish() {\n        wrapper.mark(this._marks.end);\n        let resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n        // fallback if web worker implementation of perf.getEntriesByName returns empty\n        if (resourceTimingData.length === 0) {\n            wrapper.measure(this._marks.measure, this._marks.start, this._marks.end);\n            resourceTimingData = wrapper.getEntriesByName(this._marks.measure);\n\n            // cleanup\n            wrapper.clearMarks(this._marks.start);\n            wrapper.clearMarks(this._marks.end);\n            wrapper.clearMeasures(this._marks.measure);\n        }\n\n        return resourceTimingData;\n    }\n}\n\nwrapper.Performance = Performance;\n\nexport default wrapper;\n","// @flow\n\nimport { getArrayBuffer } from '../util/ajax';\n\nimport vt from '@mapbox/vector-tile';\nimport Protobuf from 'pbf';\nimport WorkerTile from './worker_tile';\nimport { extend } from '../util/util';\nimport performance from '../util/performance';\n\nimport type {\n    WorkerSource,\n    WorkerTileParameters,\n    WorkerTileCallback,\n    TileParameters\n} from '../source/worker_source';\n\nimport type {PerformanceResourceTiming} from '../types/performance_resource_timing';\nimport type Actor from '../util/actor';\nimport type StyleLayerIndex from '../style/style_layer_index';\nimport type {Callback} from '../types/callback';\n\nexport type LoadVectorTileResult = {\n    vectorTile: VectorTile;\n    rawData: ArrayBuffer;\n    expires?: any;\n    cacheControl?: any;\n    resourceTiming?: Array<PerformanceResourceTiming>;\n};\n\n/**\n * @callback LoadVectorDataCallback\n * @param error\n * @param vectorTile\n * @private\n */\nexport type LoadVectorDataCallback = Callback<?LoadVectorTileResult>;\n\nexport type AbortVectorData = () => void;\nexport type LoadVectorData = (params: WorkerTileParameters, callback: LoadVectorDataCallback) => ?AbortVectorData;\n\n/**\n * @private\n */\nfunction loadVectorTile(params: WorkerTileParameters, callback: LoadVectorDataCallback) {\n    const request = getArrayBuffer(params.request, (err: ?Error, data: ?ArrayBuffer, cacheControl: ?string, expires: ?string) => {\n        if (err) {\n            callback(err);\n        } else if (data) {\n            callback(null, {\n                vectorTile: new vt.VectorTile(new Protobuf(data)),\n                rawData: data,\n                cacheControl,\n                expires\n            });\n        }\n    });\n    return () => {\n        request.cancel();\n        callback();\n    };\n}\n\n/**\n * The {@link WorkerSource} implementation that supports {@link VectorTileSource}.\n * This class is designed to be easily reused to support custom source types\n * for data formats that can be parsed/converted into an in-memory VectorTile\n * representation.  To do so, create it with\n * `new VectorTileWorkerSource(actor, styleLayers, customLoadVectorDataFunction)`.\n *\n * @private\n */\nclass VectorTileWorkerSource implements WorkerSource {\n    actor: Actor;\n    layerIndex: StyleLayerIndex;\n    loadVectorData: LoadVectorData;\n    loading: { [string]: WorkerTile };\n    loaded: { [string]: WorkerTile };\n\n    /**\n     * @param [loadVectorData] Optional method for custom loading of a VectorTile\n     * object based on parameters passed from the main-thread Source. See\n     * {@link VectorTileWorkerSource#loadTile}. The default implementation simply\n     * loads the pbf at `params.url`.\n     */\n    constructor(actor: Actor, layerIndex: StyleLayerIndex, loadVectorData: ?LoadVectorData) {\n        this.actor = actor;\n        this.layerIndex = layerIndex;\n        this.loadVectorData = loadVectorData || loadVectorTile;\n        this.loading = {};\n        this.loaded = {};\n    }\n\n    /**\n     * Implements {@link WorkerSource#loadTile}. Delegates to\n     * {@link VectorTileWorkerSource#loadVectorData} (which by default expects\n     * a `params.url` property) for fetching and producing a VectorTile object.\n     */\n    loadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const uid = params.uid;\n\n        if (!this.loading)\n            this.loading = {};\n\n        const perf = (params && params.request && params.request.collectResourceTiming) ?\n            new performance.Performance(params.request) : false;\n\n        const workerTile = this.loading[uid] = new WorkerTile(params);\n        workerTile.abort = this.loadVectorData(params, (err, response) => {\n            delete this.loading[uid];\n\n            if (err || !response) {\n                workerTile.status = 'done';\n                this.loaded[uid] = workerTile;\n                return callback(err);\n            }\n\n            const rawTileData = response.rawData;\n            const cacheControl = {};\n            if (response.expires) cacheControl.expires = response.expires;\n            if (response.cacheControl) cacheControl.cacheControl = response.cacheControl;\n\n            const resourceTiming = {};\n            if (perf) {\n                const resourceTimingData = perf.finish();\n                // it's necessary to eval the result of getEntriesByName() here via parse/stringify\n                // late evaluation in the main thread causes TypeError: illegal invocation\n                if (resourceTimingData)\n                    resourceTiming.resourceTiming = JSON.parse(JSON.stringify(resourceTimingData));\n            }\n\n            workerTile.vectorTile = response.vectorTile;\n            workerTile.parse(response.vectorTile, this.layerIndex, this.actor, (err, result) => {\n                if (err || !result) return callback(err);\n\n                // Transferring a copy of rawTileData because the worker needs to retain its copy.\n                callback(null, extend({rawTileData: rawTileData.slice(0)}, result, cacheControl, resourceTiming));\n            });\n\n            this.loaded = this.loaded || {};\n            this.loaded[uid] = workerTile;\n        });\n    }\n\n    /**\n     * Implements {@link WorkerSource#reloadTile}.\n     */\n    reloadTile(params: WorkerTileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid,\n            vtSource = this;\n        if (loaded && loaded[uid]) {\n            const workerTile = loaded[uid];\n            workerTile.showCollisionBoxes = params.showCollisionBoxes;\n\n            const done = (err, data) => {\n                const reloadCallback = workerTile.reloadCallback;\n                if (reloadCallback) {\n                    delete workerTile.reloadCallback;\n                    workerTile.parse(workerTile.vectorTile, vtSource.layerIndex, vtSource.actor, reloadCallback);\n                }\n                callback(err, data);\n            };\n\n            if (workerTile.status === 'parsing') {\n                workerTile.reloadCallback = done;\n            } else if (workerTile.status === 'done') {\n                // if there was no vector tile data on the initial load, don't try and re-parse tile\n                if (workerTile.vectorTile) {\n                    workerTile.parse(workerTile.vectorTile, this.layerIndex, this.actor, done);\n                } else {\n                    done();\n                }\n            }\n        }\n    }\n\n    /**\n     * Implements {@link WorkerSource#abortTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    abortTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loading = this.loading,\n            uid = params.uid;\n        if (loading && loading[uid] && loading[uid].abort) {\n            loading[uid].abort();\n            delete loading[uid];\n        }\n        callback();\n    }\n\n    /**\n     * Implements {@link WorkerSource#removeTile}.\n     *\n     * @param params\n     * @param params.uid The UID for this tile.\n     */\n    removeTile(params: TileParameters, callback: WorkerTileCallback) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n        callback();\n    }\n}\n\nexport default VectorTileWorkerSource;\n","// @flow\n\nimport DEMData from '../data/dem_data';\n\nimport type Actor from '../util/actor';\nimport type {\n    WorkerDEMTileParameters,\n    WorkerDEMTileCallback,\n    TileParameters\n} from './worker_source';\n\n\nclass RasterDEMTileWorkerSource {\n    actor: Actor;\n    loaded: {[string]: DEMData};\n\n    constructor() {\n        this.loaded = {};\n    }\n\n    loadTile(params: WorkerDEMTileParameters, callback: WorkerDEMTileCallback) {\n        const {uid, encoding, rawImageData} = params;\n        const dem = new DEMData(uid, rawImageData, encoding);\n\n        this.loaded = this.loaded || {};\n        this.loaded[uid] = dem;\n        callback(null, dem);\n    }\n\n    removeTile(params: TileParameters) {\n        const loaded = this.loaded,\n            uid = params.uid;\n        if (loaded && loaded[uid]) {\n            delete loaded[uid];\n        }\n    }\n}\n\nexport default RasterDEMTileWorkerSource;\n","module.exports.RADIUS = 6378137;\nmodule.exports.FLATTENING = 1/298.257223563;\nmodule.exports.POLAR_RADIUS = 6356752.3142;\n","var wgs84 = require('wgs84');\n\nmodule.exports.geometry = geometry;\nmodule.exports.ring = ringArea;\n\nfunction geometry(_) {\n    var area = 0, i;\n    switch (_.type) {\n        case 'Polygon':\n            return polygonArea(_.coordinates);\n        case 'MultiPolygon':\n            for (i = 0; i < _.coordinates.length; i++) {\n                area += polygonArea(_.coordinates[i]);\n            }\n            return area;\n        case 'Point':\n        case 'MultiPoint':\n        case 'LineString':\n        case 'MultiLineString':\n            return 0;\n        case 'GeometryCollection':\n            for (i = 0; i < _.geometries.length; i++) {\n                area += geometry(_.geometries[i]);\n            }\n            return area;\n    }\n}\n\nfunction polygonArea(coords) {\n    var area = 0;\n    if (coords && coords.length > 0) {\n        area += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            area -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return area;\n}\n\n/**\n * Calculate the approximate area of the polygon were it projected onto\n *     the earth.  Note that this area will be positive if ring is oriented\n *     clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n *     Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n *\n * Returns:\n * {float} The approximate signed geodesic area of the polygon in square\n *     meters.\n */\n\nfunction ringArea(coords) {\n    var p1, p2, p3, lowerIndex, middleIndex, upperIndex, i,\n    area = 0,\n    coordsLength = coords.length;\n\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {// i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength -1;\n                upperIndex = 0;\n            } else if (i === coordsLength - 1) {// i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            } else { // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i+1;\n                upperIndex = i+2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));\n        }\n\n        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;\n    }\n\n    return area;\n}\n\nfunction rad(_) {\n    return _ * Math.PI / 180;\n}","var geojsonArea = require('@mapbox/geojson-area');\n\nmodule.exports = rewind;\n\nfunction rewind(gj, outer) {\n    switch ((gj && gj.type) || null) {\n        case 'FeatureCollection':\n            gj.features = gj.features.map(curryOuter(rewind, outer));\n            return gj;\n        case 'GeometryCollection':\n            gj.geometries = gj.geometries.map(curryOuter(rewind, outer));\n            return gj;\n        case 'Feature':\n            gj.geometry = rewind(gj.geometry, outer);\n            return gj;\n        case 'Polygon':\n        case 'MultiPolygon':\n            return correct(gj, outer);\n        default:\n            return gj;\n    }\n}\n\nfunction curryOuter(a, b) {\n    return function(_) { return a(_, b); };\n}\n\nfunction correct(_, outer) {\n    if (_.type === 'Polygon') {\n        _.coordinates = correctRings(_.coordinates, outer);\n    } else if (_.type === 'MultiPolygon') {\n        _.coordinates = _.coordinates.map(curryOuter(correctRings, outer));\n    }\n    return _;\n}\n\nfunction correctRings(_, outer) {\n    outer = !!outer;\n    _[0] = wind(_[0], outer);\n    for (var i = 1; i < _.length; i++) {\n        _[i] = wind(_[i], !outer);\n    }\n    return _;\n}\n\nfunction wind(_, dir) {\n    return cw(_) === dir ? _ : _.reverse();\n}\n\nfunction cw(_) {\n    return geojsonArea.ring(_) >= 0;\n}\n","// @flow\n\nimport Point from '@mapbox/point-geometry';\n\nimport mvt from '@mapbox/vector-tile';\nconst toGeoJSON = mvt.VectorTileFeature.prototype.toGeoJSON;\nimport EXTENT from '../data/extent';\n\n// The feature type used by geojson-vt and supercluster. Should be extracted to\n// global type and used in module definitions for those two modules.\ntype Feature = {\n    type: 1,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<[number, number]>,\n} | {\n    type: 2 | 3,\n    id: mixed,\n    tags: {[string]: string | number | boolean},\n    geometry: Array<Array<[number, number]>>,\n}\n\nclass FeatureWrapper implements VectorTileFeature {\n    _feature: Feature;\n\n    extent: number;\n    type: 1 | 2 | 3;\n    id: number;\n    properties: {[string]: string | number | boolean};\n\n    constructor(feature: Feature) {\n        this._feature = feature;\n\n        this.extent = EXTENT;\n        this.type = feature.type;\n        this.properties = feature.tags;\n\n        // If the feature has a top-level `id` property, copy it over, but only\n        // if it can be coerced to an integer, because this wrapper is used for\n        // serializing geojson feature data into vector tile PBF data, and the\n        // vector tile spec only supports integer values for feature ids --\n        // allowing non-integer values here results in a non-compliant PBF\n        // that causes an exception when it is parsed with vector-tile-js\n        if ('id' in feature && !isNaN(feature.id)) {\n            this.id = parseInt(feature.id, 10);\n        }\n    }\n\n    loadGeometry() {\n        if (this._feature.type === 1) {\n            const geometry = [];\n            for (const point of this._feature.geometry) {\n                geometry.push([new Point(point[0], point[1])]);\n            }\n            return geometry;\n        } else {\n            const geometry = [];\n            for (const ring of this._feature.geometry) {\n                const newRing = [];\n                for (const point of ring) {\n                    newRing.push(new Point(point[0], point[1]));\n                }\n                geometry.push(newRing);\n            }\n            return geometry;\n        }\n    }\n\n    toGeoJSON(x: number, y: number, z: number) {\n        return toGeoJSON.call(this, x, y, z);\n    }\n}\n\nclass GeoJSONWrapper implements VectorTile, VectorTileLayer {\n    layers: {[string]: VectorTileLayer};\n    name: string;\n    extent: number;\n    length: number;\n    _features: Array<Feature>;\n\n    constructor(features: Array<Feature>) {\n        this.layers = { '_geojsonTileLayer': this };\n        this.name = '_geojsonTileLayer';\n        this.extent = EXTENT;\n        this.length = features.length;\n        this._features = features;\n    }\n\n    feature(i: number): VectorTileFeature {\n        return new FeatureWrapper(this._features[i]);\n    }\n}\n\nexport default GeoJSONWrapper;\n","'use strict'\n\nvar Point = require('@mapbox/point-geometry')\nvar VectorTileFeature = require('@mapbox/vector-tile').VectorTileFeature\n\nmodule.exports = GeoJSONWrapper\n\n// conform to vectortile api\nfunction GeoJSONWrapper (features, options) {\n  this.options = options || {}\n  this.features = features\n  this.length = features.length\n}\n\nGeoJSONWrapper.prototype.feature = function (i) {\n  return new FeatureWrapper(this.features[i], this.options.extent)\n}\n\nfunction FeatureWrapper (feature, extent) {\n  this.id = typeof feature.id === 'number' ? feature.id : undefined\n  this.type = feature.type\n  this.rawGeometry = feature.type === 1 ? [feature.geometry] : feature.geometry\n  this.properties = feature.tags\n  this.extent = extent || 4096\n}\n\nFeatureWrapper.prototype.loadGeometry = function () {\n  var rings = this.rawGeometry\n  this.geometry = []\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n    var newRing = []\n    for (var j = 0; j < ring.length; j++) {\n      newRing.push(new Point(ring[j][0], ring[j][1]))\n    }\n    this.geometry.push(newRing)\n  }\n  return this.geometry\n}\n\nFeatureWrapper.prototype.bbox = function () {\n  if (!this.geometry) this.loadGeometry()\n\n  var rings = this.geometry\n  var x1 = Infinity\n  var x2 = -Infinity\n  var y1 = Infinity\n  var y2 = -Infinity\n\n  for (var i = 0; i < rings.length; i++) {\n    var ring = rings[i]\n\n    for (var j = 0; j < ring.length; j++) {\n      var coord = ring[j]\n\n      x1 = Math.min(x1, coord.x)\n      x2 = Math.max(x2, coord.x)\n      y1 = Math.min(y1, coord.y)\n      y2 = Math.max(y2, coord.y)\n    }\n  }\n\n  return [x1, y1, x2, y2]\n}\n\nFeatureWrapper.prototype.toGeoJSON = VectorTileFeature.prototype.toGeoJSON\n","var Pbf = require('pbf')\nvar GeoJSONWrapper = require('./lib/geojson_wrapper')\n\nmodule.exports = fromVectorTileJs\nmodule.exports.fromVectorTileJs = fromVectorTileJs\nmodule.exports.fromGeojsonVt = fromGeojsonVt\nmodule.exports.GeoJSONWrapper = GeoJSONWrapper\n\n/**\n * Serialize a vector-tile-js-created tile to pbf\n *\n * @param {Object} tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromVectorTileJs (tile) {\n  var out = new Pbf()\n  writeTile(tile, out)\n  return out.finish()\n}\n\n/**\n * Serialized a geojson-vt-created tile to pbf.\n *\n * @param {Object} layers - An object mapping layer names to geojson-vt-created vector tile objects\n * @param {Object} [options] - An object specifying the vector-tile specification version and extent that were used to create `layers`.\n * @param {Number} [options.version=1] - Version of vector-tile spec used\n * @param {Number} [options.extent=4096] - Extent of the vector tile\n * @return {Buffer} uncompressed, pbf-serialized tile data\n */\nfunction fromGeojsonVt (layers, options) {\n  options = options || {}\n  var l = {}\n  for (var k in layers) {\n    l[k] = new GeoJSONWrapper(layers[k].features, options)\n    l[k].name = k\n    l[k].version = options.version\n    l[k].extent = options.extent\n  }\n  return fromVectorTileJs({layers: l})\n}\n\nfunction writeTile (tile, pbf) {\n  for (var key in tile.layers) {\n    pbf.writeMessage(3, writeLayer, tile.layers[key])\n  }\n}\n\nfunction writeLayer (layer, pbf) {\n  pbf.writeVarintField(15, layer.version || 1)\n  pbf.writeStringField(1, layer.name || '')\n  pbf.writeVarintField(5, layer.extent || 4096)\n\n  var i\n  var context = {\n    keys: [],\n    values: [],\n    keycache: {},\n    valuecache: {}\n  }\n\n  for (i = 0; i < layer.length; i++) {\n    context.feature = layer.feature(i)\n    pbf.writeMessage(2, writeFeature, context)\n  }\n\n  var keys = context.keys\n  for (i = 0; i < keys.length; i++) {\n    pbf.writeStringField(3, keys[i])\n  }\n\n  var values = context.values\n  for (i = 0; i < values.length; i++) {\n    pbf.writeMessage(4, writeValue, values[i])\n  }\n}\n\nfunction writeFeature (context, pbf) {\n  var feature = context.feature\n\n  if (feature.id !== undefined) {\n    pbf.writeVarintField(1, feature.id)\n  }\n\n  pbf.writeMessage(2, writeProperties, context)\n  pbf.writeVarintField(3, feature.type)\n  pbf.writeMessage(4, writeGeometry, feature)\n}\n\nfunction writeProperties (context, pbf) {\n  var feature = context.feature\n  var keys = context.keys\n  var values = context.values\n  var keycache = context.keycache\n  var valuecache = context.valuecache\n\n  for (var key in feature.properties) {\n    var keyIndex = keycache[key]\n    if (typeof keyIndex === 'undefined') {\n      keys.push(key)\n      keyIndex = keys.length - 1\n      keycache[key] = keyIndex\n    }\n    pbf.writeVarint(keyIndex)\n\n    var value = feature.properties[key]\n    var type = typeof value\n    if (type !== 'string' && type !== 'boolean' && type !== 'number') {\n      value = JSON.stringify(value)\n    }\n    var valueKey = type + ':' + value\n    var valueIndex = valuecache[valueKey]\n    if (typeof valueIndex === 'undefined') {\n      values.push(value)\n      valueIndex = values.length - 1\n      valuecache[valueKey] = valueIndex\n    }\n    pbf.writeVarint(valueIndex)\n  }\n}\n\nfunction command (cmd, length) {\n  return (length << 3) + (cmd & 0x7)\n}\n\nfunction zigzag (num) {\n  return (num << 1) ^ (num >> 31)\n}\n\nfunction writeGeometry (feature, pbf) {\n  var geometry = feature.loadGeometry()\n  var type = feature.type\n  var x = 0\n  var y = 0\n  var rings = geometry.length\n  for (var r = 0; r < rings; r++) {\n    var ring = geometry[r]\n    var count = 1\n    if (type === 1) {\n      count = ring.length\n    }\n    pbf.writeVarint(command(1, count)) // moveto\n    // do not write polygon closing path as lineto\n    var lineCount = type === 3 ? ring.length - 1 : ring.length\n    for (var i = 0; i < lineCount; i++) {\n      if (i === 1 && type !== 1) {\n        pbf.writeVarint(command(2, lineCount - 1)) // lineto\n      }\n      var dx = ring[i].x - x\n      var dy = ring[i].y - y\n      pbf.writeVarint(zigzag(dx))\n      pbf.writeVarint(zigzag(dy))\n      x += dx\n      y += dy\n    }\n    if (type === 3) {\n      pbf.writeVarint(command(7, 1)) // closepath\n    }\n  }\n}\n\nfunction writeValue (value, pbf) {\n  var type = typeof value\n  if (type === 'string') {\n    pbf.writeStringField(1, value)\n  } else if (type === 'boolean') {\n    pbf.writeBooleanField(7, value)\n  } else if (type === 'number') {\n    if (value % 1 !== 0) {\n      pbf.writeDoubleField(3, value)\n    } else if (value < 0) {\n      pbf.writeSVarintField(6, value)\n    } else {\n      pbf.writeVarintField(5, value)\n    }\n  }\n}\n","// @flow\n\nimport { mat4 } from 'gl-matrix';\nimport EXTENT from '../data/extent';\nimport { PosArray } from '../data/array_types';\nimport { LineIndexArray } from '../data/index_array_type';\nimport posAttributes from '../data/pos_attributes';\nimport SegmentVector from '../data/segment';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport { debugUniformValues } from './program/debug_program';\nimport Color from '../style-spec/util/color';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawDebug;\n\nfunction drawDebug(painter: Painter, sourceCache: SourceCache, coords: Array<OverscaledTileID>) {\n    for (let i = 0; i < coords.length; i++) {\n        drawDebugTile(painter, sourceCache, coords[i]);\n    }\n}\n\nfunction drawDebugTile(painter, sourceCache, coord) {\n    const context = painter.context;\n    const gl = context.gl;\n\n    const posMatrix = coord.posMatrix;\n    const program = painter.useProgram('debug');\n\n    const depthMode = DepthMode.disabled;\n    const stencilMode = StencilMode.disabled;\n    const colorMode = painter.colorModeForRenderPass();\n    const id = '$debug';\n\n    program.draw(context, gl.LINE_STRIP, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        debugUniformValues(posMatrix, Color.red), id,\n        painter.debugBuffer, painter.tileBorderIndexBuffer, painter.debugSegments);\n\n    const vertices = createTextVertices(coord.toString(), 50, 200, 5);\n    const debugTextArray = new PosArray();\n    const debugTextIndices = new LineIndexArray();\n    for (let v = 0; v < vertices.length; v += 2) {\n        debugTextArray.emplaceBack(vertices[v], vertices[v + 1]);\n        debugTextIndices.emplaceBack(v, v + 1);\n    }\n    const debugTextBuffer = context.createVertexBuffer(debugTextArray, posAttributes.members);\n    const debugTextIndexBuffer = context.createIndexBuffer(debugTextIndices);\n    const debugTextSegment = SegmentVector.simpleSegment(0, 0, debugTextArray.length / 2, debugTextArray.length / 2);\n\n    // Draw the halo with multiple 1px lines instead of one wider line because\n    // the gl spec doesn't guarantee support for lines with width > 1.\n    const tileSize = sourceCache.getTile(coord).tileSize;\n    const onePixel = EXTENT / (Math.pow(2, painter.transform.zoom - coord.overscaledZ) * tileSize);\n    const translations = [[-1, -1], [-1, 1], [1, -1], [1, 1]];\n    for (let i = 0; i < translations.length; i++) {\n        const translation = translations[i];\n\n        program.draw(context, gl.LINES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n            debugUniformValues(\n                mat4.translate([], posMatrix, [\n                    onePixel * translation[0],\n                    onePixel * translation[1], 0]),\n                Color.white),\n            id, debugTextBuffer, debugTextIndexBuffer, debugTextSegment);\n    }\n\n    program.draw(context, gl.LINES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        debugUniformValues(posMatrix, Color.black), id,\n        debugTextBuffer, debugTextIndexBuffer, debugTextSegment);\n}\n\n// Font data From Hershey Simplex Font\n// http://paulbourke.net/dataformats/hershey/\nconst simplexFont = {\n    \" \": [16, []],\n    \"!\": [10, [5, 21, 5, 7, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \"\\\"\": [16, [4, 21, 4, 14, -1, -1, 12, 21, 12, 14]],\n    \"#\": [21, [11, 25, 4, -7, -1, -1, 17, 25, 10, -7, -1, -1, 4, 12, 18, 12, -1, -1, 3, 6, 17, 6]],\n    \"$\": [20, [8, 25, 8, -4, -1, -1, 12, 25, 12, -4, -1, -1, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],\n    \"%\": [24, [21, 21, 3, 0, -1, -1, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, -1, -1, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7]],\n    \"&\": [26, [23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2]],\n    \"'\": [10, [5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15]],\n    \"(\": [14, [11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7]],\n    \")\": [14, [3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7]],\n    \"*\": [16, [8, 21, 8, 9, -1, -1, 3, 18, 13, 12, -1, -1, 13, 18, 3, 12]],\n    \"+\": [26, [13, 18, 13, 0, -1, -1, 4, 9, 22, 9]],\n    \",\": [10, [6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],\n    \"-\": [26, [4, 9, 22, 9]],\n    \".\": [10, [5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \"/\": [22, [20, 25, 2, -7]],\n    \"0\": [20, [9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21]],\n    \"1\": [20, [6, 17, 8, 18, 11, 21, 11, 0]],\n    \"2\": [20, [4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0]],\n    \"3\": [20, [5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],\n    \"4\": [20, [13, 21, 3, 7, 18, 7, -1, -1, 13, 21, 13, 0]],\n    \"5\": [20, [15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4]],\n    \"6\": [20, [16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7]],\n    \"7\": [20, [17, 21, 7, 0, -1, -1, 3, 21, 17, 21]],\n    \"8\": [20, [8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21]],\n    \"9\": [20, [16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3]],\n    \":\": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2]],\n    \";\": [10, [5, 14, 4, 13, 5, 12, 6, 13, 5, 14, -1, -1, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4]],\n    \"<\": [24, [20, 18, 4, 9, 20, 0]],\n    \"=\": [26, [4, 12, 22, 12, -1, -1, 4, 6, 22, 6]],\n    \">\": [24, [4, 18, 20, 9, 4, 0]],\n    \"?\": [18, [3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, -1, -1, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2]],\n    \"@\": [27, [18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, -1, -1, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, -1, -1, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, -1, -1, 19, 16, 18, 8, 18, 6, 19, 5]],\n    \"A\": [18, [9, 21, 1, 0, -1, -1, 9, 21, 17, 0, -1, -1, 4, 7, 14, 7]],\n    \"B\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, -1, -1, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0]],\n    \"C\": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5]],\n    \"D\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0]],\n    \"E\": [19, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11, -1, -1, 4, 0, 17, 0]],\n    \"F\": [18, [4, 21, 4, 0, -1, -1, 4, 21, 17, 21, -1, -1, 4, 11, 12, 11]],\n    \"G\": [21, [18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, -1, -1, 13, 8, 18, 8]],\n    \"H\": [22, [4, 21, 4, 0, -1, -1, 18, 21, 18, 0, -1, -1, 4, 11, 18, 11]],\n    \"I\": [8, [4, 21, 4, 0]],\n    \"J\": [16, [12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7]],\n    \"K\": [21, [4, 21, 4, 0, -1, -1, 18, 21, 4, 7, -1, -1, 9, 12, 18, 0]],\n    \"L\": [17, [4, 21, 4, 0, -1, -1, 4, 0, 16, 0]],\n    \"M\": [24, [4, 21, 4, 0, -1, -1, 4, 21, 12, 0, -1, -1, 20, 21, 12, 0, -1, -1, 20, 21, 20, 0]],\n    \"N\": [22, [4, 21, 4, 0, -1, -1, 4, 21, 18, 0, -1, -1, 18, 21, 18, 0]],\n    \"O\": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21]],\n    \"P\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10]],\n    \"Q\": [22, [9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, -1, -1, 12, 4, 18, -2]],\n    \"R\": [21, [4, 21, 4, 0, -1, -1, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, -1, -1, 11, 11, 18, 0]],\n    \"S\": [20, [17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3]],\n    \"T\": [16, [8, 21, 8, 0, -1, -1, 1, 21, 15, 21]],\n    \"U\": [22, [4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21]],\n    \"V\": [18, [1, 21, 9, 0, -1, -1, 17, 21, 9, 0]],\n    \"W\": [24, [2, 21, 7, 0, -1, -1, 12, 21, 7, 0, -1, -1, 12, 21, 17, 0, -1, -1, 22, 21, 17, 0]],\n    \"X\": [20, [3, 21, 17, 0, -1, -1, 17, 21, 3, 0]],\n    \"Y\": [18, [1, 21, 9, 11, 9, 0, -1, -1, 17, 21, 9, 11]],\n    \"Z\": [20, [17, 21, 3, 0, -1, -1, 3, 21, 17, 21, -1, -1, 3, 0, 17, 0]],\n    \"[\": [14, [4, 25, 4, -7, -1, -1, 5, 25, 5, -7, -1, -1, 4, 25, 11, 25, -1, -1, 4, -7, 11, -7]],\n    \"\\\\\": [14, [0, 21, 14, -3]],\n    \"]\": [14, [9, 25, 9, -7, -1, -1, 10, 25, 10, -7, -1, -1, 3, 25, 10, 25, -1, -1, 3, -7, 10, -7]],\n    \"^\": [16, [6, 15, 8, 18, 10, 15, -1, -1, 3, 12, 8, 17, 13, 12, -1, -1, 8, 17, 8, 0]],\n    \"_\": [16, [0, -2, 16, -2]],\n    \"`\": [10, [6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17]],\n    \"a\": [19, [15, 14, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"b\": [19, [4, 21, 4, 0, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],\n    \"c\": [18, [15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"d\": [19, [15, 21, 15, 0, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"e\": [18, [3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"f\": [12, [10, 21, 8, 21, 6, 20, 5, 17, 5, 0, -1, -1, 2, 14, 9, 14]],\n    \"g\": [19, [15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"h\": [19, [4, 21, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],\n    \"i\": [8, [3, 21, 4, 20, 5, 21, 4, 22, 3, 21, -1, -1, 4, 14, 4, 0]],\n    \"j\": [10, [5, 21, 6, 20, 7, 21, 6, 22, 5, 21, -1, -1, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7]],\n    \"k\": [17, [4, 21, 4, 0, -1, -1, 14, 14, 4, 4, -1, -1, 8, 8, 15, 0]],\n    \"l\": [8, [4, 21, 4, 0]],\n    \"m\": [30, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, -1, -1, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0]],\n    \"n\": [19, [4, 14, 4, 0, -1, -1, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0]],\n    \"o\": [19, [8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14]],\n    \"p\": [19, [4, 14, 4, -7, -1, -1, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3]],\n    \"q\": [19, [15, 14, 15, -7, -1, -1, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3]],\n    \"r\": [13, [4, 14, 4, 0, -1, -1, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14]],\n    \"s\": [17, [14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3]],\n    \"t\": [12, [5, 21, 5, 4, 6, 1, 8, 0, 10, 0, -1, -1, 2, 14, 9, 14]],\n    \"u\": [19, [4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, -1, -1, 15, 14, 15, 0]],\n    \"v\": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0]],\n    \"w\": [22, [3, 14, 7, 0, -1, -1, 11, 14, 7, 0, -1, -1, 11, 14, 15, 0, -1, -1, 19, 14, 15, 0]],\n    \"x\": [17, [3, 14, 14, 0, -1, -1, 14, 14, 3, 0]],\n    \"y\": [16, [2, 14, 8, 0, -1, -1, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7]],\n    \"z\": [17, [14, 14, 3, 0, -1, -1, 3, 14, 14, 14, -1, -1, 3, 0, 14, 0]],\n    \"{\": [14, [9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, -1, -1, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, -1, -1, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7]],\n    \"|\": [8, [4, 25, 4, -7]],\n    \"}\": [14, [5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, -1, -1, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, -1, -1, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7]],\n    \"~\": [24, [3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, -1, -1, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]]\n};\n\nfunction createTextVertices(text, left, baseline, scale) {\n    scale = scale || 1;\n\n    const strokes = [];\n    let i, len, j, len2, glyph, x, y, prev;\n\n    for (i = 0, len = text.length; i < len; i++) {\n        glyph = simplexFont[text[i]];\n        if (!glyph) continue;\n        prev = null;\n\n        for (j = 0, len2 = glyph[1].length; j < len2; j += 2) {\n            if (glyph[1][j] === -1 && glyph[1][j + 1] === -1) {\n                prev = null;\n\n            } else {\n                x = left + glyph[1][j] * scale;\n                y = baseline - glyph[1][j + 1] * scale;\n                if (prev) {\n                    strokes.push(prev.x, prev.y, x, y);\n                }\n                prev = {x, y};\n            }\n        }\n        left += glyph[0] * scale;\n    }\n\n    return strokes;\n}\n","// @flow\n\nimport browser from '../util/browser';\n\nimport { mat4 } from 'gl-matrix';\nimport SourceCache from '../source/source_cache';\nimport EXTENT from '../data/extent';\nimport pixelsToTileUnits from '../source/pixels_to_tile_units';\nimport SegmentVector from '../data/segment';\nimport { RasterBoundsArray, PosArray, TriangleIndexArray, LineStripIndexArray } from '../data/array_types';\nimport rasterBoundsAttributes from '../data/raster_bounds_attributes';\nimport posAttributes from '../data/pos_attributes';\nimport ProgramConfiguration from '../data/program_configuration';\nimport CrossTileSymbolIndex from '../symbol/cross_tile_symbol_index';\nimport * as shaders from '../shaders';\nimport Program from './program';\nimport { programUniforms } from './program/program_uniforms';\nimport Context from '../gl/context';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport ColorMode from '../gl/color_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport Texture from './texture';\nimport updateTileMasks from './tile_mask';\nimport { clippingMaskUniformValues } from './program/clipping_mask_program';\nimport Color from '../style-spec/util/color';\nimport symbol from './draw_symbol';\nimport circle from './draw_circle';\nimport heatmap from './draw_heatmap';\nimport line from './draw_line';\nimport fill from './draw_fill';\nimport fillExtrusion from './draw_fill_extrusion';\nimport hillshade from './draw_hillshade';\nimport raster from './draw_raster';\nimport background from './draw_background';\nimport debug from './draw_debug';\nimport custom from './draw_custom';\n\nconst draw = {\n    symbol,\n    circle,\n    heatmap,\n    line,\n    fill,\n    'fill-extrusion': fillExtrusion,\n    hillshade,\n    raster,\n    background,\n    debug,\n    custom\n};\n\nimport type Transform from '../geo/transform';\nimport type Tile from '../source/tile';\nimport type {OverscaledTileID} from '../source/tile_id';\nimport type Style from '../style/style';\nimport type StyleLayer from '../style/style_layer';\nimport type {CrossFaded} from '../style/properties';\nimport type LineAtlas from './line_atlas';\nimport type ImageManager from './image_manager';\nimport type GlyphManager from './glyph_manager';\nimport type VertexBuffer from '../gl/vertex_buffer';\nimport type IndexBuffer from '../gl/index_buffer';\nimport type {DepthMaskType, DepthFuncType} from '../gl/types';\n\nexport type RenderPass = 'offscreen' | 'opaque' | 'translucent';\n\ntype PainterOptions = {\n    showOverdrawInspector: boolean,\n    showTileBoundaries: boolean,\n    rotating: boolean,\n    zooming: boolean,\n    moving: boolean,\n    fadeDuration: number\n}\n\n/**\n * Initialize a new painter object.\n *\n * @param {Canvas} gl an experimental-webgl drawing context\n * @private\n */\nclass Painter {\n    context: Context;\n    transform: Transform;\n    _tileTextures: { [number]: Array<Texture> };\n    numSublayers: number;\n    depthEpsilon: number;\n    emptyProgramConfiguration: ProgramConfiguration;\n    width: number;\n    height: number;\n    depthRbo: WebGLRenderbuffer;\n    depthRboNeedsClear: boolean;\n    tileExtentBuffer: VertexBuffer;\n    tileExtentSegments: SegmentVector;\n    debugBuffer: VertexBuffer;\n    debugSegments: SegmentVector;\n    rasterBoundsBuffer: VertexBuffer;\n    rasterBoundsSegments: SegmentVector;\n    viewportBuffer: VertexBuffer;\n    viewportSegments: SegmentVector;\n    quadTriangleIndexBuffer: IndexBuffer;\n    tileBorderIndexBuffer: IndexBuffer;\n    _tileClippingMaskIDs: { [number]: number };\n    stencilClearMode: StencilMode;\n    style: Style;\n    options: PainterOptions;\n    lineAtlas: LineAtlas;\n    imageManager: ImageManager;\n    glyphManager: GlyphManager;\n    depthRange: number;\n    renderPass: RenderPass;\n    currentLayer: number;\n    id: string;\n    _showOverdrawInspector: boolean;\n    cache: { [string]: Program<*> };\n    crossTileSymbolIndex: CrossTileSymbolIndex;\n    symbolFadeChange: number;\n\n    constructor(gl: WebGLRenderingContext, transform: Transform) {\n        this.context = new Context(gl);\n        this.transform = transform;\n        this._tileTextures = {};\n\n        this.setup();\n\n        // Within each layer there are multiple distinct z-planes that can be drawn to.\n        // This is implemented using the WebGL depth buffer.\n        this.numSublayers = SourceCache.maxUnderzooming + SourceCache.maxOverzooming + 1;\n        this.depthEpsilon = 1 / Math.pow(2, 16);\n\n        this.depthRboNeedsClear = true;\n\n        this.emptyProgramConfiguration = new ProgramConfiguration();\n\n        this.crossTileSymbolIndex = new CrossTileSymbolIndex();\n    }\n\n    /*\n     * Update the GL viewport, projection matrix, and transforms to compensate\n     * for a new width and height value.\n     */\n    resize(width: number, height: number) {\n        const gl = this.context.gl;\n\n        this.width = width * browser.devicePixelRatio;\n        this.height = height * browser.devicePixelRatio;\n        this.context.viewport.set([0, 0, this.width, this.height]);\n\n        if (this.style) {\n            for (const layerId of this.style._order) {\n                this.style._layers[layerId].resize();\n            }\n        }\n\n        if (this.depthRbo) {\n            gl.deleteRenderbuffer(this.depthRbo);\n            this.depthRbo = null;\n        }\n    }\n\n    setup() {\n        const context = this.context;\n\n        const tileExtentArray = new PosArray();\n        tileExtentArray.emplaceBack(0, 0);\n        tileExtentArray.emplaceBack(EXTENT, 0);\n        tileExtentArray.emplaceBack(0, EXTENT);\n        tileExtentArray.emplaceBack(EXTENT, EXTENT);\n        this.tileExtentBuffer = context.createVertexBuffer(tileExtentArray, posAttributes.members);\n        this.tileExtentSegments = SegmentVector.simpleSegment(0, 0, 4, 2);\n\n        const debugArray = new PosArray();\n        debugArray.emplaceBack(0, 0);\n        debugArray.emplaceBack(EXTENT, 0);\n        debugArray.emplaceBack(0, EXTENT);\n        debugArray.emplaceBack(EXTENT, EXTENT);\n        this.debugBuffer = context.createVertexBuffer(debugArray, posAttributes.members);\n        this.debugSegments = SegmentVector.simpleSegment(0, 0, 4, 5);\n\n        const rasterBoundsArray = new RasterBoundsArray();\n        rasterBoundsArray.emplaceBack(0, 0, 0, 0);\n        rasterBoundsArray.emplaceBack(EXTENT, 0, EXTENT, 0);\n        rasterBoundsArray.emplaceBack(0, EXTENT, 0, EXTENT);\n        rasterBoundsArray.emplaceBack(EXTENT, EXTENT, EXTENT, EXTENT);\n        this.rasterBoundsBuffer = context.createVertexBuffer(rasterBoundsArray, rasterBoundsAttributes.members);\n        this.rasterBoundsSegments = SegmentVector.simpleSegment(0, 0, 4, 2);\n\n        const viewportArray = new PosArray();\n        viewportArray.emplaceBack(0, 0);\n        viewportArray.emplaceBack(1, 0);\n        viewportArray.emplaceBack(0, 1);\n        viewportArray.emplaceBack(1, 1);\n        this.viewportBuffer = context.createVertexBuffer(viewportArray, posAttributes.members);\n        this.viewportSegments = SegmentVector.simpleSegment(0, 0, 4, 2);\n\n        const tileLineStripIndices = new LineStripIndexArray();\n        tileLineStripIndices.emplaceBack(0);\n        tileLineStripIndices.emplaceBack(1);\n        tileLineStripIndices.emplaceBack(3);\n        tileLineStripIndices.emplaceBack(2);\n        tileLineStripIndices.emplaceBack(0);\n        this.tileBorderIndexBuffer = context.createIndexBuffer(tileLineStripIndices);\n\n        const quadTriangleIndices = new TriangleIndexArray();\n        quadTriangleIndices.emplaceBack(0, 1, 2);\n        quadTriangleIndices.emplaceBack(2, 1, 3);\n        this.quadTriangleIndexBuffer = context.createIndexBuffer(quadTriangleIndices);\n\n        const gl = this.context.gl;\n        this.stencilClearMode = new StencilMode({ func: gl.ALWAYS, mask: 0 }, 0x0, 0xFF, gl.ZERO, gl.ZERO, gl.ZERO);\n    }\n\n    /*\n     * Reset the drawing canvas by clearing the stencil buffer so that we can draw\n     * new tiles at the same location, while retaining previously drawn pixels.\n     */\n    clearStencil() {\n        const context = this.context;\n        const gl = context.gl;\n\n        // As a temporary workaround for https://github.com/mapbox/mapbox-gl-js/issues/5490,\n        // pending an upstream fix, we draw a fullscreen stencil=0 clipping mask here,\n        // effectively clearing the stencil buffer: once an upstream patch lands, remove\n        // this function in favor of context.clear({ stencil: 0x0 })\n\n        const matrix = mat4.create();\n        mat4.ortho(matrix, 0, this.width, this.height, 0, 0, 1);\n        mat4.scale(matrix, matrix, [gl.drawingBufferWidth, gl.drawingBufferHeight, 0]);\n\n        this.useProgram('clippingMask').draw(context, gl.TRIANGLES,\n            DepthMode.disabled, this.stencilClearMode, ColorMode.disabled, CullFaceMode.disabled,\n            clippingMaskUniformValues(matrix),\n            '$clipping', this.viewportBuffer,\n            this.quadTriangleIndexBuffer, this.viewportSegments);\n    }\n\n    _renderTileClippingMasks(tileIDs: Array<OverscaledTileID>) {\n        const context = this.context;\n        const gl = context.gl;\n\n        context.setColorMode(ColorMode.disabled);\n        context.setDepthMode(DepthMode.disabled);\n\n        const program = this.useProgram('clippingMask');\n\n        let idNext = 1;\n        this._tileClippingMaskIDs = {};\n\n        for (const tileID of tileIDs) {\n            const id = this._tileClippingMaskIDs[tileID.key] = idNext++;\n\n            program.draw(context, gl.TRIANGLES, DepthMode.disabled,\n                // Tests will always pass, and ref value will be written to stencil buffer.\n                new StencilMode({ func: gl.ALWAYS, mask: 0 }, id, 0xFF, gl.KEEP, gl.KEEP, gl.REPLACE),\n                ColorMode.disabled, CullFaceMode.disabled, clippingMaskUniformValues(tileID.posMatrix),\n                '$clipping', this.tileExtentBuffer,\n                this.quadTriangleIndexBuffer, this.tileExtentSegments);\n        }\n    }\n\n    stencilModeForClipping(tileID: OverscaledTileID): StencilMode {\n        const gl = this.context.gl;\n        return new StencilMode({ func: gl.EQUAL, mask: 0xFF }, this._tileClippingMaskIDs[tileID.key], 0x00, gl.KEEP, gl.KEEP, gl.REPLACE);\n    }\n\n    colorModeForRenderPass(): $ReadOnly<ColorMode> {\n        const gl = this.context.gl;\n        if (this._showOverdrawInspector) {\n            const numOverdrawSteps = 8;\n            const a = 1 / numOverdrawSteps;\n\n            return new ColorMode([gl.CONSTANT_COLOR, gl.ONE], new Color(a, a, a, 0), [true, true, true, true]);\n        } else if (this.renderPass === 'opaque') {\n            return ColorMode.unblended;\n        } else {\n            return ColorMode.alphaBlended;\n        }\n    }\n\n    depthModeForSublayer(n: number, mask: DepthMaskType, func: ?DepthFuncType): DepthMode {\n        const depth = 1 - ((1 + this.currentLayer) * this.numSublayers + n) * this.depthEpsilon;\n        return new DepthMode(func || this.context.gl.LEQUAL, mask, [depth, depth]);\n    }\n\n    render(style: Style, options: PainterOptions) {\n        this.style = style;\n        this.options = options;\n\n        this.lineAtlas = style.lineAtlas;\n        this.imageManager = style.imageManager;\n        this.glyphManager = style.glyphManager;\n\n        this.symbolFadeChange = style.placement.symbolFadeChange(browser.now());\n\n        const layerIds = this.style._order;\n        const sourceCaches = this.style.sourceCaches;\n\n        for (const id in sourceCaches) {\n            const sourceCache = sourceCaches[id];\n            if (sourceCache.used) {\n                sourceCache.prepare(this.context);\n            }\n        }\n\n        const coordsAscending: {[string]: Array<OverscaledTileID>} = {};\n        const coordsDescending: {[string]: Array<OverscaledTileID>} = {};\n        const coordsDescendingSymbol: {[string]: Array<OverscaledTileID>} = {};\n\n        for (const id in sourceCaches) {\n            const sourceCache = sourceCaches[id];\n            coordsAscending[id] = sourceCache.getVisibleCoordinates();\n            coordsDescending[id] = coordsAscending[id].slice().reverse();\n            coordsDescendingSymbol[id] = sourceCache.getVisibleCoordinates(true).reverse();\n        }\n\n        for (const id in sourceCaches) {\n            const sourceCache = sourceCaches[id];\n            const source = sourceCache.getSource();\n            if (source.type !== 'raster' && source.type !== 'raster-dem') continue;\n            const visibleTiles = [];\n            for (const coord of coordsAscending[id]) visibleTiles.push(sourceCache.getTile(coord));\n            updateTileMasks(visibleTiles, this.context);\n        }\n\n        // Offscreen pass ===============================================\n        // We first do all rendering that requires rendering to a separate\n        // framebuffer, and then save those for rendering back to the map\n        // later: in doing this we avoid doing expensive framebuffer restores.\n        this.renderPass = 'offscreen';\n        this.depthRboNeedsClear = true;\n\n        for (const layerId of layerIds) {\n            const layer = this.style._layers[layerId];\n            if (!layer.hasOffscreenPass() || layer.isHidden(this.transform.zoom)) continue;\n\n            const coords = coordsDescending[layer.source];\n            if (layer.type !== 'custom' && !coords.length) continue;\n\n            this.renderLayer(this, sourceCaches[layer.source], layer, coords);\n        }\n\n        // Rebind the main framebuffer now that all offscreen layers have been rendered:\n        this.context.bindFramebuffer.set(null);\n\n        // Clear buffers in preparation for drawing to the main framebuffer\n        this.context.clear({ color: options.showOverdrawInspector ? Color.black : Color.transparent, depth: 1 });\n\n        this._showOverdrawInspector = options.showOverdrawInspector;\n        this.depthRange = (style._order.length + 2) * this.numSublayers * this.depthEpsilon;\n\n        // Opaque pass ===============================================\n        // Draw opaque layers top-to-bottom first.\n        this.renderPass = 'opaque';\n        let prevSourceId;\n\n        for (this.currentLayer = layerIds.length - 1; this.currentLayer >= 0; this.currentLayer--) {\n            const layer = this.style._layers[layerIds[this.currentLayer]];\n            const sourceCache = sourceCaches[layer.source];\n            const coords = coordsAscending[layer.source];\n\n            if (layer.source !== prevSourceId && sourceCache) {\n                this.clearStencil();\n                if (sourceCache.getSource().isTileClipped) {\n                    this._renderTileClippingMasks(coords);\n                }\n            }\n\n            this.renderLayer(this, sourceCache, layer, coords);\n            prevSourceId = layer.source;\n        }\n\n        // Translucent pass ===============================================\n        // Draw all other layers bottom-to-top.\n        this.renderPass = 'translucent';\n\n        for (this.currentLayer = 0, prevSourceId = null; this.currentLayer < layerIds.length; this.currentLayer++) {\n            const layer = this.style._layers[layerIds[this.currentLayer]];\n            const sourceCache = sourceCaches[layer.source];\n\n            // For symbol layers in the translucent pass, we add extra tiles to the renderable set\n            // for cross-tile symbol fading. Symbol layers don't use tile clipping, so no need to render\n            // separate clipping masks\n            const coords = (layer.type === 'symbol' ? coordsDescendingSymbol : coordsDescending)[layer.source];\n\n            if (layer.source !== prevSourceId && sourceCache) {\n                this.clearStencil();\n                if (sourceCache.getSource().isTileClipped) {\n                    this._renderTileClippingMasks(coordsAscending[layer.source]);\n                }\n            }\n\n            this.renderLayer(this, sourceCache, layer, coords);\n            prevSourceId = layer.source;\n        }\n\n        if (this.options.showTileBoundaries) {\n            for (const id in sourceCaches) {\n                draw.debug(this, sourceCaches[id], coordsAscending[id]);\n                break;\n            }\n        }\n\n        this.setCustomLayerDefaults();\n    }\n\n    setupOffscreenDepthRenderbuffer(): void {\n        const context = this.context;\n        // All of the 3D textures will use the same depth renderbuffer.\n        if (!this.depthRbo) {\n            this.depthRbo = context.createRenderbuffer(context.gl.DEPTH_COMPONENT16, this.width, this.height);\n        }\n    }\n\n    renderLayer(painter: Painter, sourceCache: SourceCache, layer: StyleLayer, coords: Array<OverscaledTileID>) {\n        if (layer.isHidden(this.transform.zoom)) return;\n        if (layer.type !== 'background' && layer.type !== 'custom' && !coords.length) return;\n        this.id = layer.id;\n\n        draw[layer.type](painter, sourceCache, layer, coords);\n    }\n\n    /**\n     * Transform a matrix to incorporate the *-translate and *-translate-anchor properties into it.\n     * @param inViewportPixelUnitsUnits True when the units accepted by the matrix are in viewport pixels instead of tile units.\n     * @returns {Float32Array} matrix\n     */\n    translatePosMatrix(matrix: Float32Array, tile: Tile, translate: [number, number], translateAnchor: 'map' | 'viewport', inViewportPixelUnitsUnits?: boolean) {\n        if (!translate[0] && !translate[1]) return matrix;\n\n        const angle = inViewportPixelUnitsUnits ?\n            (translateAnchor === 'map' ? this.transform.angle : 0) :\n            (translateAnchor === 'viewport' ? -this.transform.angle : 0);\n\n        if (angle) {\n            const sinA = Math.sin(angle);\n            const cosA = Math.cos(angle);\n            translate = [\n                translate[0] * cosA - translate[1] * sinA,\n                translate[0] * sinA + translate[1] * cosA\n            ];\n        }\n\n        const translation = [\n            inViewportPixelUnitsUnits ? translate[0] : pixelsToTileUnits(tile, translate[0], this.transform.zoom),\n            inViewportPixelUnitsUnits ? translate[1] : pixelsToTileUnits(tile, translate[1], this.transform.zoom),\n            0\n        ];\n\n        const translatedMatrix = new Float32Array(16);\n        mat4.translate(translatedMatrix, matrix, translation);\n        return translatedMatrix;\n    }\n\n    saveTileTexture(texture: Texture) {\n        const textures = this._tileTextures[texture.size[0]];\n        if (!textures) {\n            this._tileTextures[texture.size[0]] = [texture];\n        } else {\n            textures.push(texture);\n        }\n    }\n\n    getTileTexture(size: number) {\n        const textures = this._tileTextures[size];\n        return textures && textures.length > 0 ? textures.pop() : null;\n    }\n\n    /**\n     * Checks whether a pattern image is needed, and if it is, whether it is not loaded.\n     *\n     * @returns true if a needed image is missing and rendering needs to be skipped.\n     */\n    isPatternMissing(image: ?CrossFaded<string>): boolean {\n        if (!image) return false;\n        const imagePosA = this.imageManager.getPattern(image.from);\n        const imagePosB = this.imageManager.getPattern(image.to);\n        return !imagePosA || !imagePosB;\n    }\n\n    useProgram(name: string, programConfiguration: ProgramConfiguration = this.emptyProgramConfiguration): Program<any> {\n        this.cache = this.cache || {};\n        const key = `${name}${programConfiguration.cacheKey || ''}${this._showOverdrawInspector ? '/overdraw' : ''}`;\n        if (!this.cache[key]) {\n            this.cache[key] = new Program(this.context, shaders[name], programConfiguration, programUniforms[name], this._showOverdrawInspector);\n        }\n        return this.cache[key];\n    }\n\n    /*\n     * Reset some GL state to default values to avoid hard-to-debug bugs\n     * in custom layers.\n     */\n    setCustomLayerDefaults() {\n        // Prevent custom layers from unintentionally modify the last VAO used.\n        // All other state is state is restored on it's own, but for VAOs it's\n        // simpler to unbind so that we don't have to track the state of VAOs.\n        this.context.unbindVAO();\n\n        // The default values for this state is meaningful and often expected.\n        // Leaving this state dirty could cause a lot of confusion for users.\n        this.context.cullFace.setDefault();\n        this.context.activeTexture.setDefault();\n        this.context.pixelStoreUnpack.setDefault();\n        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault();\n        this.context.pixelStoreUnpackFlipY.setDefault();\n    }\n\n    /*\n     * Set GL state that is shared by all layers.\n     */\n    setBaseState() {\n        const gl = this.context.gl;\n        this.context.cullFace.set(false);\n        this.context.viewport.set([0, 0, this.width, this.height]);\n        this.context.blendEquation.set(gl.FUNC_ADD);\n    }\n}\n\nexport default Painter;\n","// @flow\n\nimport drawCollisionDebug from './draw_collision_debug';\n\nimport SegmentVector from '../data/segment';\nimport pixelsToTileUnits from '../source/pixels_to_tile_units';\nimport * as symbolProjection from '../symbol/projection';\nimport * as symbolSize from '../symbol/symbol_size';\nimport { mat4 } from 'gl-matrix';\nconst identityMat4 = mat4.identity(new Float32Array(16));\nimport properties from '../style/style_layer/symbol_style_layer_properties';\nconst symbolLayoutProperties = properties.layout;\nimport StencilMode from '../gl/stencil_mode';\nimport DepthMode from '../gl/depth_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport {\n    symbolIconUniformValues,\n    symbolSDFUniformValues\n} from './program/symbol_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type SymbolStyleLayer from '../style/style_layer/symbol_style_layer';\nimport type SymbolBucket, {SymbolBuffers} from '../data/bucket/symbol_bucket';\nimport type Texture from '../render/texture';\nimport type {OverscaledTileID} from '../source/tile_id';\nimport type {UniformValues} from './uniform_binding';\nimport type {SymbolSDFUniformsType} from '../render/program/symbol_program';\n\nexport default drawSymbols;\n\ntype SymbolTileRenderState = {\n    segments: SegmentVector,\n    sortKey: number,\n    state: {\n        program: any,\n        buffers: SymbolBuffers,\n        uniformValues: any,\n        atlasTexture: Texture,\n        atlasInterpolation: any,\n        isSDF: boolean,\n        hasHalo: boolean\n    }\n};\n\nfunction drawSymbols(painter: Painter, sourceCache: SourceCache, layer: SymbolStyleLayer, coords: Array<OverscaledTileID>) {\n    if (painter.renderPass !== 'translucent') return;\n\n    // Disable the stencil test so that labels aren't clipped to tile boundaries.\n    const stencilMode = StencilMode.disabled;\n    const colorMode = painter.colorModeForRenderPass();\n\n    if (layer.paint.get('icon-opacity').constantOr(1) !== 0) {\n        drawLayerSymbols(painter, sourceCache, layer, coords, false,\n            layer.paint.get('icon-translate'),\n            layer.paint.get('icon-translate-anchor'),\n            layer.layout.get('icon-rotation-alignment'),\n            layer.layout.get('icon-pitch-alignment'),\n            layer.layout.get('icon-keep-upright'),\n            stencilMode, colorMode\n        );\n    }\n\n    if (layer.paint.get('text-opacity').constantOr(1) !== 0) {\n        drawLayerSymbols(painter, sourceCache, layer, coords, true,\n            layer.paint.get('text-translate'),\n            layer.paint.get('text-translate-anchor'),\n            layer.layout.get('text-rotation-alignment'),\n            layer.layout.get('text-pitch-alignment'),\n            layer.layout.get('text-keep-upright'),\n            stencilMode, colorMode\n        );\n    }\n\n    if (sourceCache.map.showCollisionBoxes) {\n        drawCollisionDebug(painter, sourceCache, layer, coords);\n    }\n}\n\nfunction drawLayerSymbols(painter, sourceCache, layer, coords, isText, translate, translateAnchor,\n    rotationAlignment, pitchAlignment, keepUpright, stencilMode, colorMode) {\n\n    const context = painter.context;\n    const gl = context.gl;\n    const tr = painter.transform;\n\n    const rotateWithMap = rotationAlignment === 'map';\n    const pitchWithMap = pitchAlignment === 'map';\n    const alongLine = rotateWithMap && layer.layout.get('symbol-placement') !== 'point';\n    // Line label rotation happens in `updateLineLabels`\n    // Pitched point labels are automatically rotated by the labelPlaneMatrix projection\n    // Unpitched point labels need to have their rotation applied after projection\n    const rotateInShader = rotateWithMap && !pitchWithMap && !alongLine;\n\n    const sortFeaturesByKey = layer.layout.get('symbol-sort-key').constantOr(1) !== undefined;\n\n    const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n\n    let program;\n    let size;\n\n    const tileRenderState: Array<SymbolTileRenderState> = [];\n\n    for (const coord of coords) {\n        const tile = sourceCache.getTile(coord);\n        const bucket: SymbolBucket = (tile.getBucket(layer): any);\n        if (!bucket) continue;\n        const buffers = isText ? bucket.text : bucket.icon;\n        if (!buffers || !buffers.segments.get().length) continue;\n        const programConfiguration = buffers.programConfigurations.get(layer.id);\n\n        const isSDF = isText || bucket.sdfIcons;\n\n        const sizeData = isText ? bucket.textSizeData : bucket.iconSizeData;\n\n        if (!program) {\n            program = painter.useProgram(isSDF ? 'symbolSDF' : 'symbolIcon', programConfiguration);\n            size = symbolSize.evaluateSizeForZoom(sizeData, tr.zoom, symbolLayoutProperties.properties[isText ? 'text-size' : 'icon-size']);\n        }\n\n        context.activeTexture.set(gl.TEXTURE0);\n\n        let texSize: [number, number];\n        let atlasTexture;\n        let atlasInterpolation;\n        if (isText) {\n            atlasTexture = tile.glyphAtlasTexture;\n            atlasInterpolation = gl.LINEAR;\n            texSize = tile.glyphAtlasTexture.size;\n\n        } else {\n            const iconScaled = layer.layout.get('icon-size').constantOr(0) !== 1 || bucket.iconsNeedLinear;\n            const iconTransformed = pitchWithMap || tr.pitch !== 0;\n\n            atlasTexture = tile.imageAtlasTexture;\n            atlasInterpolation = isSDF || painter.options.rotating || painter.options.zooming || iconScaled || iconTransformed ?\n                gl.LINEAR :\n                gl.NEAREST;\n            texSize = tile.imageAtlasTexture.size;\n        }\n\n        const s = pixelsToTileUnits(tile, 1, painter.transform.zoom);\n        const labelPlaneMatrix = symbolProjection.getLabelPlaneMatrix(coord.posMatrix, pitchWithMap, rotateWithMap, painter.transform, s);\n        const glCoordMatrix = symbolProjection.getGlCoordMatrix(coord.posMatrix, pitchWithMap, rotateWithMap, painter.transform, s);\n\n        if (alongLine) {\n            symbolProjection.updateLineLabels(bucket, coord.posMatrix, painter, isText, labelPlaneMatrix, glCoordMatrix, pitchWithMap, keepUpright);\n        }\n\n        const matrix = painter.translatePosMatrix(coord.posMatrix, tile, translate, translateAnchor),\n            uLabelPlaneMatrix = alongLine ? identityMat4 : labelPlaneMatrix,\n            uglCoordMatrix = painter.translatePosMatrix(glCoordMatrix, tile, translate, translateAnchor, true);\n\n        const hasHalo = isSDF && layer.paint.get(isText ? 'text-halo-width' : 'icon-halo-width').constantOr(1) !== 0;\n\n        let uniformValues;\n        if (isSDF) {\n            uniformValues = symbolSDFUniformValues(sizeData.functionType,\n                size, rotateInShader, pitchWithMap, painter, matrix,\n                uLabelPlaneMatrix, uglCoordMatrix, isText, texSize, true);\n\n        } else {\n            uniformValues = symbolIconUniformValues(sizeData.functionType,\n                size, rotateInShader, pitchWithMap, painter, matrix,\n                uLabelPlaneMatrix, uglCoordMatrix, isText, texSize);\n        }\n\n        const state = {\n            program,\n            buffers,\n            uniformValues,\n            atlasTexture,\n            atlasInterpolation,\n            isSDF,\n            hasHalo\n        };\n\n        if (sortFeaturesByKey) {\n            const oldSegments = buffers.segments.get();\n            for (const segment of oldSegments) {\n                tileRenderState.push({\n                    segments: new SegmentVector([segment]),\n                    sortKey: ((segment.sortKey: any): number),\n                    state\n                });\n            }\n        } else {\n            tileRenderState.push({\n                segments: buffers.segments,\n                sortKey: 0,\n                state\n            });\n        }\n    }\n\n    if (sortFeaturesByKey) {\n        tileRenderState.sort((a, b) => a.sortKey - b.sortKey);\n    }\n\n    for (const segmentState of tileRenderState) {\n        const state = segmentState.state;\n\n        state.atlasTexture.bind(state.atlasInterpolation, gl.CLAMP_TO_EDGE);\n\n        if (state.isSDF) {\n            const uniformValues = ((state.uniformValues: any): UniformValues<SymbolSDFUniformsType>);\n            if (state.hasHalo) {\n                uniformValues['u_is_halo'] = 1;\n                drawSymbolElements(state.buffers, segmentState.segments, layer, painter, state.program, depthMode, stencilMode, colorMode, uniformValues);\n            }\n            uniformValues['u_is_halo'] = 0;\n        }\n        drawSymbolElements(state.buffers, segmentState.segments, layer, painter, state.program, depthMode, stencilMode, colorMode, state.uniformValues);\n    }\n}\n\nfunction drawSymbolElements(buffers, segments, layer, painter, program, depthMode, stencilMode, colorMode, uniformValues) {\n    const context = painter.context;\n    const gl = context.gl;\n    program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n        uniformValues, layer.id, buffers.layoutVertexBuffer,\n        buffers.indexBuffer, segments, layer.paint,\n        painter.transform.zoom, buffers.programConfigurations.get(layer.id),\n        buffers.dynamicLayoutVertexBuffer, buffers.opacityVertexBuffer);\n}\n\n","// @flow\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type StyleLayer from '../style/style_layer';\nimport type {OverscaledTileID} from '../source/tile_id';\nimport type SymbolBucket from '../data/bucket/symbol_bucket';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport { collisionUniformValues } from './program/collision_program';\n\nexport default drawCollisionDebug;\n\nfunction drawCollisionDebugGeometry(painter: Painter, sourceCache: SourceCache, layer: StyleLayer, coords: Array<OverscaledTileID>, drawCircles: boolean) {\n    const context = painter.context;\n    const gl = context.gl;\n    const program = drawCircles ? painter.useProgram('collisionCircle') : painter.useProgram('collisionBox');\n\n    for (let i = 0; i < coords.length; i++) {\n        const coord = coords[i];\n        const tile = sourceCache.getTile(coord);\n        const bucket: ?SymbolBucket = (tile.getBucket(layer): any);\n        if (!bucket) continue;\n        const buffers = drawCircles ? bucket.collisionCircle : bucket.collisionBox;\n        if (!buffers) continue;\n\n        program.draw(context, drawCircles ? gl.TRIANGLES : gl.LINES,\n            DepthMode.disabled, StencilMode.disabled,\n            painter.colorModeForRenderPass(),\n            CullFaceMode.disabled,\n            collisionUniformValues(\n                coord.posMatrix,\n                painter.transform,\n                tile),\n            layer.id, buffers.layoutVertexBuffer, buffers.indexBuffer,\n            buffers.segments, null, painter.transform.zoom, null, null,\n            buffers.collisionVertexBuffer);\n    }\n}\n\nfunction drawCollisionDebug(painter: Painter, sourceCache: SourceCache, layer: StyleLayer, coords: Array<OverscaledTileID>) {\n    drawCollisionDebugGeometry(painter, sourceCache, layer, coords, false);\n    drawCollisionDebugGeometry(painter, sourceCache, layer, coords, true);\n}\n","// @flow\n\nimport StencilMode from '../gl/stencil_mode';\nimport DepthMode from '../gl/depth_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport { circleUniformValues } from './program/circle_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type CircleStyleLayer from '../style/style_layer/circle_style_layer';\nimport type CircleBucket from '../data/bucket/circle_bucket';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawCircles;\n\nfunction drawCircles(painter: Painter, sourceCache: SourceCache, layer: CircleStyleLayer, coords: Array<OverscaledTileID>) {\n    if (painter.renderPass !== 'translucent') return;\n\n    const opacity = layer.paint.get('circle-opacity');\n    const strokeWidth = layer.paint.get('circle-stroke-width');\n    const strokeOpacity = layer.paint.get('circle-stroke-opacity');\n\n    if (opacity.constantOr(1) === 0 && (strokeWidth.constantOr(1) === 0 || strokeOpacity.constantOr(1) === 0)) {\n        return;\n    }\n\n    const context = painter.context;\n    const gl = context.gl;\n\n    const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n    // Turn off stencil testing to allow circles to be drawn across boundaries,\n    // so that large circles are not clipped to tiles\n    const stencilMode = StencilMode.disabled;\n    const colorMode = painter.colorModeForRenderPass();\n\n    for (let i = 0; i < coords.length; i++) {\n        const coord = coords[i];\n\n        const tile = sourceCache.getTile(coord);\n        const bucket: ?CircleBucket<*> = (tile.getBucket(layer): any);\n        if (!bucket) continue;\n\n        const programConfiguration = bucket.programConfigurations.get(layer.id);\n        const program = painter.useProgram('circle', programConfiguration);\n\n        program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n            circleUniformValues(painter, coord, tile, layer), layer.id,\n            bucket.layoutVertexBuffer, bucket.indexBuffer, bucket.segments,\n            layer.paint, painter.transform.zoom, programConfiguration);\n    }\n}\n","// @flow\n\nimport Texture from './texture';\nimport Color from '../style-spec/util/color';\nimport DepthMode from '../gl/depth_mode';\nimport StencilMode from '../gl/stencil_mode';\nimport ColorMode from '../gl/color_mode';\nimport CullFaceMode from '../gl/cull_face_mode';\nimport {\n    heatmapUniformValues,\n    heatmapTextureUniformValues\n} from './program/heatmap_program';\n\nimport type Painter from './painter';\nimport type SourceCache from '../source/source_cache';\nimport type HeatmapStyleLayer from '../style/style_layer/heatmap_style_layer';\nimport type HeatmapBucket from '../data/bucket/heatmap_bucket';\nimport type {OverscaledTileID} from '../source/tile_id';\n\nexport default drawHeatmap;\n\nfunction drawHeatmap(painter: Painter, sourceCache: SourceCache, layer: HeatmapStyleLayer, coords: Array<OverscaledTileID>) {\n    if (layer.paint.get('heatmap-opacity') === 0) {\n        return;\n    }\n\n    if (painter.renderPass === 'offscreen') {\n        const context = painter.context;\n        const gl = context.gl;\n\n        const depthMode = painter.depthModeForSublayer(0, DepthMode.ReadOnly);\n        // Allow kernels to be drawn across boundaries, so that\n        // large kernels are not clipped to tiles\n        const stencilMode = StencilMode.disabled;\n        // Turn on additive blending for kernels, which is a key aspect of kernel density estimation formula\n        const colorMode = new ColorMode([gl.ONE, gl.ONE], Color.transparent, [true, true, true, true]);\n\n        bindFramebuffer(context, painter, layer);\n\n        context.clear({ color: Color.transparent });\n\n        for (let i = 0; i < coords.length; i++) {\n            const coord = coords[i];\n\n            // Skip tiles that have uncovered parents to avoid flickering; we don't need\n            // to use complex tile masking here because the change between zoom levels is subtle,\n            // so it's fine to simply render the parent until all its 4 children are loaded\n            if (sourceCache.hasRenderableParent(coord)) continue;\n\n            const tile = sourceCache.getTile(coord);\n            const bucket: ?HeatmapBucket = (tile.getBucket(layer): any);\n            if (!bucket) continue;\n\n            const programConfiguration = bucket.programConfigurations.get(layer.id);\n            const program = painter.useProgram('heatmap', programConfiguration);\n            const {zoom} = painter.transform;\n\n            program.draw(context, gl.TRIANGLES, depthMode, stencilMode, colorMode, CullFaceMode.disabled,\n                heatmapUniformValues(coord.posMatrix,\n                    tile, zoom, layer.paint.get('heatmap-intensity')),\n                layer.id, bucket.layoutVertexBuffer, bucket.indexBuffer,\n                bucket.segments, layer.paint, painter.transform.zoom,\n                programConfiguration);\n        }\n\n        context.viewport.set([0, 0, painter.width, painter.height]);\n\n    } else if (painter.renderPass === 'translucent') {\n        painter.context.setColorMode(painter.colorModeForRenderPass());\n        renderTextureToMap(painter, layer);\n    }\n}\n\nfunction bindFramebuffer(context, painter, layer) {\n    const gl = context.gl;\n    context.activeTexture.set(gl.TEXTURE1);\n\n    // Use a 4x downscaled screen texture for better performance\n    context.viewport.set([0, 0, painter.width / 4, painter.height / 4]);\n\n    let fbo = layer.heatmapFbo;\n\n    if (!fbo) {\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n\n        fbo = layer.heatmapFbo = context.createFramebuffer(painter.width / 4, painter.height / 4);\n\n        bindTextureToFramebuffer(context, painter, texture, fbo);\n\n    } else {\n        gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());\n        context.bindFramebuffer.set(fbo.framebuffer);\n    }\n}\n\nfunction bindTextureToFramebuffer(context, painter, texture, fbo) {\n    const gl = context.gl;\n    // Use the higher precision half-float texture where available (producing much smoother looking heatmaps);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, painter.width / 4, painter.height / 4, 0, gl.RGBA,\n        context.extTextureHalfFloat ? context.extTextureHalfFloat.HALF_FLOAT_OES : gl.UNSIGNED_BYTE, null);\n\n    fbo.colorAttachment.set(texture);\n\n    // If using half-float texture as a render target is not supported, fall back to a low precision texture\n    if (context.extTextureHalfFloat && gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n        context.extTextureHalfFloat = null;\n        fbo.colorAttachment.setDirty();\n        bindTextureToFramebuffer(context, painter, texture, fbo);\n    }\n}\n\nfunction renderTextureToMap(painter, layer) {\n    const context = painter.context;\n    const gl = context.gl;\n\n    // Here we bind two different textures from which we'll sample in drawing\n    // heatmaps: the kernel texture, prepared in the offscreen pass, and a\n    // color ramp texture.\n    const fbo = layer.heatmapFbo;\n    if (!fbo) return;\n    context.activeTexture.set(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, fbo.colorAttachment.get());\n\n    context.activeTexture.set(gl.TEXTURE1);\n    let colorRampTexture = layer.colorRampTexture;\n    if (!colorRampTexture) {\n        colorRampTexture = layer.colorRampTexture = new Texture(context, layer.colorRamp, gl.RGBA);\n    }\n    colorRampTexture.bind(gl.LINEAR, gl.CLAMP_TO_EDGE);\n\n    painter.useProgram('heatmapTexture').draw(context, gl.TRIANGLES,\n        DepthMode.disabled, StencilMode.disabled, painter.colorModeForRenderPass(), CullFaceMode.disabled,\n        heatmapTextureUniformValues(painter, layer, 0, 1),\n        layer.id, painter.viewportBuffer, painter.quadTriangleIndexBuffer,\n        painter.viewportSegments, layer.paint, painter.transform.zoom);\n}\n","// @flow\n\nimport { extend, bindAll, warnOnce, uniqueId } from '../util/util';\n\nimport browser from '../util/browser';\nimport window from '../util/window';\nconst { HTMLImageElement, HTMLElement } = window;\nimport DOM from '../util/dom';\nimport { getImage, getJSON, ResourceType } from '../util/ajax';\nimport { normalizeStyleURL } from '../util/mapbox';\nimport Style from '../style/style';\nimport EvaluationParameters from '../style/evaluation_parameters';\nimport Painter from '../render/painter';\nimport Transform from '../geo/transform';\nimport Hash from './hash';\nimport bindHandlers from './bind_handlers';\nimport Camera from './camera';\nimport LngLat from '../geo/lng_lat';\nimport LngLatBounds from '../geo/lng_lat_bounds';\nimport Point from '@mapbox/point-geometry';\nimport AttributionControl from './control/attribution_control';\nimport LogoControl from './control/logo_control';\nimport isSupported from '@mapbox/mapbox-gl-supported';\nimport { RGBAImage } from '../util/image';\nimport { Event, ErrorEvent } from '../util/evented';\nimport { MapMouseEvent } from './events';\nimport TaskQueue from '../util/task_queue';\nimport webpSupported from '../util/webp_supported';\n\nimport type {PointLike} from '@mapbox/point-geometry';\nimport type {LngLatLike} from '../geo/lng_lat';\nimport type {LngLatBoundsLike} from '../geo/lng_lat_bounds';\nimport type {RequestParameters} from '../util/ajax';\nimport type {StyleOptions, StyleSetterOptions} from '../style/style';\nimport type {MapEvent, MapDataEvent} from './events';\nimport type {CustomLayerInterface} from '../style/style_layer/custom_style_layer';\n\nimport type ScrollZoomHandler from './handler/scroll_zoom';\nimport type BoxZoomHandler from './handler/box_zoom';\nimport type DragRotateHandler from './handler/drag_rotate';\nimport type DragPanHandler from './handler/drag_pan';\nimport type KeyboardHandler from './handler/keyboard';\nimport type DoubleClickZoomHandler from './handler/dblclick_zoom';\nimport type TouchZoomRotateHandler from './handler/touch_zoom_rotate';\nimport type {TaskID} from '../util/task_queue';\nimport type {Cancelable} from '../types/cancelable';\nimport type {\n    LayerSpecification,\n    FilterSpecification,\n    StyleSpecification,\n    LightSpecification,\n    SourceSpecification\n} from '../style-spec/types';\n\ntype ControlPosition = 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';\n/* eslint-disable no-use-before-define */\ntype IControl = {\n    onAdd(map: Map): HTMLElement;\n    onRemove(map: Map): void;\n\n    +getDefaultPosition?: () => ControlPosition;\n}\n/* eslint-enable no-use-before-define */\n\ntype ResourceTypeEnum = $Keys<typeof ResourceType>;\nexport type RequestTransformFunction = (url: string, resourceType?: ResourceTypeEnum) => RequestParameters;\n\ntype MapOptions = {\n    hash?: boolean,\n    interactive?: boolean,\n    container: HTMLElement | string,\n    bearingSnap?: number,\n    attributionControl?: boolean,\n    customAttribution?: string | Array<string>,\n    logoPosition?: ControlPosition,\n    failIfMajorPerformanceCaveat?: boolean,\n    preserveDrawingBuffer?: boolean,\n    refreshExpiredTiles?: boolean,\n    maxBounds?: LngLatBoundsLike,\n    scrollZoom?: boolean,\n    minZoom?: ?number,\n    maxZoom?: ?number,\n    boxZoom?: boolean,\n    dragRotate?: boolean,\n    dragPan?: boolean,\n    keyboard?: boolean,\n    doubleClickZoom?: boolean,\n    touchZoomRotate?: boolean,\n    trackResize?: boolean,\n    center?: LngLatLike,\n    zoom?: number,\n    bearing?: number,\n    pitch?: number,\n    renderWorldCopies?: boolean,\n    maxTileCacheSize?: number,\n    transformRequest?: RequestTransformFunction\n};\n\nconst defaultMinZoom = 0;\nconst defaultMaxZoom = 22;\nconst defaultOptions = {\n    center: [0, 0],\n    zoom: 0,\n    bearing: 0,\n    pitch: 0,\n\n    minZoom: defaultMinZoom,\n    maxZoom: defaultMaxZoom,\n\n    interactive: true,\n    scrollZoom: true,\n    boxZoom: true,\n    dragRotate: true,\n    dragPan: true,\n    keyboard: true,\n    doubleClickZoom: true,\n    touchZoomRotate: true,\n\n    bearingSnap: 7,\n    clickTolerance: 3,\n\n    hash: false,\n    attributionControl: true,\n\n    failIfMajorPerformanceCaveat: false,\n    preserveDrawingBuffer: false,\n    trackResize: true,\n    renderWorldCopies: true,\n    refreshExpiredTiles: true,\n    maxTileCacheSize: null,\n    transformRequest: null,\n    fadeDuration: 300,\n    crossSourceCollisions: true\n};\n\n/**\n * The `Map` object represents the map on your page. It exposes methods\n * and properties that enable you to programmatically change the map,\n * and fires events as users interact with it.\n *\n * You create a `Map` by specifying a `container` and other options.\n * Then Mapbox GL JS initializes the map on the page and returns your `Map`\n * object.\n *\n * @extends Evented\n * @param {Object} options\n * @param {HTMLElement|string} options.container The HTML element in which Mapbox GL JS will render the map, or the element's string `id`. The specified element must have no children.\n * @param {number} [options.minZoom=0] The minimum zoom level of the map (0-24).\n * @param {number} [options.maxZoom=22] The maximum zoom level of the map (0-24).\n * @param {Object|string} [options.style] The map's Mapbox style. This must be an a JSON object conforming to\n * the schema described in the [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to\n * such JSON.\n *\n * To load a style from the Mapbox API, you can use a URL of the form `mapbox://styles/:owner/:style`,\n * where `:owner` is your Mapbox account name and `:style` is the style ID. Or you can use one of the following\n * [the predefined Mapbox styles](https://www.mapbox.com/maps/):\n *\n *  * `mapbox://styles/mapbox/streets-v10`\n *  * `mapbox://styles/mapbox/outdoors-v10`\n *  * `mapbox://styles/mapbox/light-v9`\n *  * `mapbox://styles/mapbox/dark-v9`\n *  * `mapbox://styles/mapbox/satellite-v9`\n *  * `mapbox://styles/mapbox/satellite-streets-v10`\n *  * `mapbox://styles/mapbox/navigation-preview-day-v2`\n *  * `mapbox://styles/mapbox/navigation-preview-night-v2`\n *  * `mapbox://styles/mapbox/navigation-guidance-day-v2`\n *  * `mapbox://styles/mapbox/navigation-guidance-night-v2`\n *\n * Tilesets hosted with Mapbox can be style-optimized if you append `?optimize=true` to the end of your style URL, like `mapbox://styles/mapbox/streets-v9?optimize=true`.\n * Learn more about style-optimized vector tiles in our [API documentation](https://www.mapbox.com/api-documentation/maps/#retrieve-tiles).\n *\n * @param {boolean} [options.hash=false] If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.\n *   For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.\n * @param {boolean} [options.interactive=true] If `false`, no mouse, touch, or keyboard listeners will be attached to the map, so it will not respond to interaction.\n * @param {number} [options.bearingSnap=7] The threshold, measured in degrees, that determines when the map's\n *   bearing will snap to north. For example, with a `bearingSnap` of 7, if the user rotates\n *   the map within 7 degrees of north, the map will automatically snap to exact north.\n * @param {boolean} [options.pitchWithRotate=true] If `false`, the map's pitch (tilt) control with \"drag to rotate\" interaction will be disabled.\n * @param {number} [options.clickTolerance=3] The max number of pixels a user can shift the mouse pointer during a click for it to be considered a valid click (as opposed to a mouse drag).\n * @param {boolean} [options.attributionControl=true] If `true`, an {@link AttributionControl} will be added to the map.\n * @param {string | Array<string>} [options.customAttribution] String or strings to show in an {@link AttributionControl}. Only applicable if `options.attributionControl` is `true`.\n * @param {string} [options.logoPosition='bottom-left'] A string representing the position of the Mapbox wordmark on the map. Valid options are `top-left`,`top-right`, `bottom-left`, `bottom-right`.\n * @param {boolean} [options.failIfMajorPerformanceCaveat=false] If `true`, map creation will fail if the performance of Mapbox\n *   GL JS would be dramatically worse than expected (i.e. a software renderer would be used).\n * @param {boolean} [options.preserveDrawingBuffer=false] If `true`, the map's canvas can be exported to a PNG using `map.getCanvas().toDataURL()`. This is `false` by default as a performance optimization.\n * @param {boolean} [options.refreshExpiredTiles=true] If `false`, the map won't attempt to re-request tiles once they expire per their HTTP `cacheControl`/`expires` headers.\n * @param {LngLatBoundsLike} [options.maxBounds] If set, the map will be constrained to the given bounds.\n * @param {boolean|Object} [options.scrollZoom=true] If `true`, the \"scroll to zoom\" interaction is enabled. An `Object` value is passed as options to {@link ScrollZoomHandler#enable}.\n * @param {boolean} [options.boxZoom=true] If `true`, the \"box zoom\" interaction is enabled (see {@link BoxZoomHandler}).\n * @param {boolean} [options.dragRotate=true] If `true`, the \"drag to rotate\" interaction is enabled (see {@link DragRotateHandler}).\n * @param {boolean} [options.dragPan=true] If `true`, the \"drag to pan\" interaction is enabled (see {@link DragPanHandler}).\n * @param {boolean} [options.keyboard=true] If `true`, keyboard shortcuts are enabled (see {@link KeyboardHandler}).\n * @param {boolean} [options.doubleClickZoom=true] If `true`, the \"double click to zoom\" interaction is enabled (see {@link DoubleClickZoomHandler}).\n * @param {boolean|Object} [options.touchZoomRotate=true] If `true`, the \"pinch to rotate and zoom\" interaction is enabled. An `Object` value is passed as options to {@link TouchZoomRotateHandler#enable}.\n * @param {boolean} [options.trackResize=true]  If `true`, the map will automatically resize when the browser window resizes.\n * @param {LngLatLike} [options.center=[0, 0]] The inital geographical centerpoint of the map. If `center` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `[0, 0]` Note: Mapbox GL uses longitude, latitude coordinate order (as opposed to latitude, longitude) to match GeoJSON.\n * @param {number} [options.zoom=0] The initial zoom level of the map. If `zoom` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {number} [options.bearing=0] The initial bearing (rotation) of the map, measured in degrees counter-clockwise from north. If `bearing` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {number} [options.pitch=0] The initial pitch (tilt) of the map, measured in degrees away from the plane of the screen (0-60). If `pitch` is not specified in the constructor options, Mapbox GL JS will look for it in the map's style object. If it is not specified in the style, either, it will default to `0`.\n * @param {LngLatBoundsLike} [options.bounds] The initial bounds of the map. If `bounds` is specified, it overrides `center` and `zoom` constructor options.\n * @param {Object} [options.fitBoundsOptions] A [`fitBounds`](#Map#fitBounds) options object to use _only_ when fitting the initial `bounds` provided above.\n * @param {boolean} [options.renderWorldCopies=true]  If `true`, multiple copies of the world will be rendered, when zoomed out.\n * @param {number} [options.maxTileCacheSize=null]  The maximum number of tiles stored in the tile cache for a given source. If omitted, the cache will be dynamically sized based on the current viewport.\n * @param {string} [options.localIdeographFontFamily=null] If specified, defines a CSS font-family\n *   for locally overriding generation of glyphs in the 'CJK Unified Ideographs' and 'Hangul Syllables' ranges.\n *   In these ranges, font settings from the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).\n *   The purpose of this option is to avoid bandwidth-intensive glyph server requests. (see [Use locally generated ideographs](https://www.mapbox.com/mapbox-gl-js/example/local-ideographs))\n * @param {RequestTransformFunction} [options.transformRequest=null] A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.\n *   Expected to return an object with a `url` property and optionally `headers` and `credentials` properties.\n * @param {boolean} [options.collectResourceTiming=false] If `true`, Resource Timing API information will be collected for requests made by GeoJSON and Vector Tile web workers (this information is normally inaccessible from the main Javascript thread). Information will be returned in a `resourceTiming` property of relevant `data` events.\n * @param {number} [options.fadeDuration=300] Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds. This setting affects all symbol layers. This setting does not affect the duration of runtime styling transitions or raster tile cross-fading.\n * @param {boolean} [options.crossSourceCollisions=true] If `true`, symbols from multiple sources can collide with each other during collision detection. If `false`, collision detection is run separately for the symbols in each source.\n * @example\n * var map = new mapboxgl.Map({\n *   container: 'map',\n *   center: [-122.420679, 37.772537],\n *   zoom: 13,\n *   style: style_object,\n *   hash: true,\n *   transformRequest: (url, resourceType)=> {\n *     if(resourceType === 'Source' && url.startsWith('http://myHost')) {\n *       return {\n *        url: url.replace('http', 'https'),\n *        headers: { 'my-custom-header': true},\n *        credentials: 'include'  // Include cookies for cross-origin requests\n *      }\n *     }\n *   }\n * });\n * @see [Display a map](https://www.mapbox.com/mapbox-gl-js/examples/)\n */\nclass Map extends Camera {\n    style: Style;\n    painter: Painter;\n\n    _container: HTMLElement;\n    _missingCSSCanary: HTMLElement;\n    _canvasContainer: HTMLElement;\n    _controlContainer: HTMLElement;\n    _controlPositions: {[string]: HTMLElement};\n    _interactive: ?boolean;\n    _showTileBoundaries: ?boolean;\n    _showCollisionBoxes: ?boolean;\n    _showOverdrawInspector: boolean;\n    _repaint: ?boolean;\n    _vertices: ?boolean;\n    _canvas: HTMLCanvasElement;\n    _transformRequest: RequestTransformFunction;\n    _maxTileCacheSize: number;\n    _frame: ?Cancelable;\n    _styleDirty: ?boolean;\n    _sourcesDirty: ?boolean;\n    _placementDirty: ?boolean;\n    _loaded: boolean;\n    _trackResize: boolean;\n    _preserveDrawingBuffer: boolean;\n    _failIfMajorPerformanceCaveat: boolean;\n    _refreshExpiredTiles: boolean;\n    _hash: Hash;\n    _delegatedListeners: any;\n    _fadeDuration: number;\n    _crossSourceCollisions: boolean;\n    _crossFadingFactor: number;\n    _collectResourceTiming: boolean;\n    _renderTaskQueue: TaskQueue;\n    _controls: Array<IControl>;\n    _mapId: number;\n\n    /**\n     * The map's {@link ScrollZoomHandler}, which implements zooming in and out with a scroll wheel or trackpad.\n     */\n    scrollZoom: ScrollZoomHandler;\n\n    /**\n     * The map's {@link BoxZoomHandler}, which implements zooming using a drag gesture with the Shift key pressed.\n     */\n    boxZoom: BoxZoomHandler;\n\n    /**\n     * The map's {@link DragRotateHandler}, which implements rotating the map while dragging with the right\n     * mouse button or with the Control key pressed.\n     */\n    dragRotate: DragRotateHandler;\n\n    /**\n     * The map's {@link DragPanHandler}, which implements dragging the map with a mouse or touch gesture.\n     */\n    dragPan: DragPanHandler;\n\n    /**\n     * The map's {@link KeyboardHandler}, which allows the user to zoom, rotate, and pan the map using keyboard\n     * shortcuts.\n     */\n    keyboard: KeyboardHandler;\n\n    /**\n     * The map's {@link DoubleClickZoomHandler}, which allows the user to zoom by double clicking.\n     */\n    doubleClickZoom: DoubleClickZoomHandler;\n\n    /**\n     * The map's {@link TouchZoomRotateHandler}, which allows the user to zoom or rotate the map with touch gestures.\n     */\n    touchZoomRotate: TouchZoomRotateHandler;\n\n    constructor(options: MapOptions) {\n        options = extend({}, defaultOptions, options);\n\n        if (options.minZoom != null && options.maxZoom != null && options.minZoom > options.maxZoom) {\n            throw new Error(`maxZoom must be greater than minZoom`);\n        }\n\n        const transform = new Transform(options.minZoom, options.maxZoom, options.renderWorldCopies);\n        super(transform, options);\n\n        this._interactive = options.interactive;\n        this._maxTileCacheSize = options.maxTileCacheSize;\n        this._failIfMajorPerformanceCaveat = options.failIfMajorPerformanceCaveat;\n        this._preserveDrawingBuffer = options.preserveDrawingBuffer;\n        this._trackResize = options.trackResize;\n        this._bearingSnap = options.bearingSnap;\n        this._refreshExpiredTiles = options.refreshExpiredTiles;\n        this._fadeDuration = options.fadeDuration;\n        this._crossSourceCollisions = options.crossSourceCollisions;\n        this._crossFadingFactor = 1;\n        this._collectResourceTiming = options.collectResourceTiming;\n        this._renderTaskQueue = new TaskQueue();\n        this._controls = [];\n        this._mapId = uniqueId();\n\n        const transformRequestFn = options.transformRequest;\n        this._transformRequest = transformRequestFn ?\n            (url, type) => transformRequestFn(url, type) || ({ url }) :\n            (url) => ({ url });\n\n        if (typeof options.container === 'string') {\n            this._container = window.document.getElementById(options.container);\n            if (!this._container) {\n                throw new Error(`Container '${options.container}' not found.`);\n            }\n        } else if (options.container instanceof HTMLElement) {\n            this._container = options.container;\n        } else {\n            throw new Error(`Invalid type: 'container' must be a String or HTMLElement.`);\n        }\n\n        if (options.maxBounds) {\n            this.setMaxBounds(options.maxBounds);\n        }\n\n        bindAll([\n            '_onWindowOnline',\n            '_onWindowResize',\n            '_contextLost',\n            '_contextRestored'\n        ], this);\n\n        this._setupContainer();\n        this._setupPainter();\n        if (this.painter === undefined) {\n            throw new Error(`Failed to initialize WebGL.`);\n        }\n\n        this.on('move', () => this._update(false));\n        this.on('moveend', () => this._update(false));\n        this.on('zoom', () => this._update(true));\n\n        if (typeof window !== 'undefined') {\n            window.addEventListener('online', this._onWindowOnline, false);\n            window.addEventListener('resize', this._onWindowResize, false);\n        }\n\n        bindHandlers(this, options);\n\n        this._hash = options.hash && (new Hash()).addTo(this);\n        // don't set position from options if set through hash\n        if (!this._hash || !this._hash._onHashChange()) {\n            this.jumpTo({\n                center: options.center,\n                zoom: options.zoom,\n                bearing: options.bearing,\n                pitch: options.pitch\n            });\n\n            if (options.bounds) {\n                this.resize();\n                this.fitBounds(options.bounds, extend({}, options.fitBoundsOptions, { duration: 0 }));\n            }\n        }\n\n        this.resize();\n\n        if (options.style) this.setStyle(options.style, { localIdeographFontFamily: options.localIdeographFontFamily });\n\n        if (options.attributionControl)\n            this.addControl(new AttributionControl({ customAttribution: options.customAttribution }));\n\n        this.addControl(new LogoControl(), options.logoPosition);\n\n        this.on('style.load', () => {\n            if (this.transform.unmodified) {\n                this.jumpTo((this.style.stylesheet: any));\n            }\n        });\n        this.on('data', (event: MapDataEvent) => {\n            this._update(event.dataType === 'style');\n            this.fire(new Event(`${event.dataType}data`, event));\n        });\n        this.on('dataloading', (event: MapDataEvent) => {\n            this.fire(new Event(`${event.dataType}dataloading`, event));\n        });\n    }\n\n    /*\n    * Returns a unique number for this map instance which is used for the MapLoadEvent\n    * to make sure we only fire one event per instantiated map object.\n    * @private\n    * @returns {number}\n    */\n    _getMapId() {\n        return this._mapId;\n    }\n\n    /**\n     * Adds a {@link IControl} to the map, calling `control.onAdd(this)`.\n     *\n     * @param {IControl} control The {@link IControl} to add.\n     * @param {string} [position] position on the map to which the control will be added.\n     * Valid values are `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`. Defaults to `'top-right'`.\n     * @returns {Map} `this`\n     * @see [Display map navigation controls](https://www.mapbox.com/mapbox-gl-js/example/navigation/)\n     */\n    addControl(control: IControl, position?: ControlPosition) {\n        if (position === undefined && control.getDefaultPosition) {\n            position = control.getDefaultPosition();\n        }\n        if (position === undefined) {\n            position = 'top-right';\n        }\n        if (!control || !control.onAdd) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.')));\n        }\n        const controlElement = control.onAdd(this);\n        this._controls.push(control);\n\n        const positionContainer = this._controlPositions[position];\n        if (position.indexOf('bottom') !== -1) {\n            positionContainer.insertBefore(controlElement, positionContainer.firstChild);\n        } else {\n            positionContainer.appendChild(controlElement);\n        }\n        return this;\n    }\n\n    /**\n     * Removes the control from the map.\n     *\n     * @param {IControl} control The {@link IControl} to remove.\n     * @returns {Map} `this`\n     */\n    removeControl(control: IControl) {\n        if (!control || !control.onRemove) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.')));\n        }\n        const ci = this._controls.indexOf(control);\n        if (ci > -1) this._controls.splice(ci, 1);\n        control.onRemove(this);\n        return this;\n    }\n\n    /**\n     * Resizes the map according to the dimensions of its\n     * `container` element.\n     *\n     * This method must be called after the map's `container` is resized by another script,\n     * or when the map is shown after being initially hidden with CSS.\n     *\n     * @param eventData Additional properties to be added to event objects of events triggered by this method.\n     * @returns {Map} `this`\n     */\n    resize(eventData?: Object) {\n        const dimensions = this._containerDimensions();\n        const width = dimensions[0];\n        const height = dimensions[1];\n\n        this._resizeCanvas(width, height);\n        this.transform.resize(width, height);\n        this.painter.resize(width, height);\n\n        this.fire(new Event('movestart', eventData))\n            .fire(new Event('move', eventData))\n            .fire(new Event('resize', eventData))\n            .fire(new Event('moveend', eventData));\n        return this;\n    }\n\n    /**\n     * Returns the map's geographical bounds. When the bearing or pitch is non-zero, the visible region is not\n     * an axis-aligned rectangle, and the result is the smallest bounds that encompasses the visible region.\n     */\n    getBounds(): LngLatBounds {\n        return this.transform.getBounds();\n    }\n\n    /**\n     * Returns the maximum geographical bounds the map is constrained to, or `null` if none set.\n     */\n    getMaxBounds(): LngLatBounds | null {\n        return this.transform.getMaxBounds();\n    }\n\n    /**\n     * Sets or clears the map's geographical bounds.\n     *\n     * Pan and zoom operations are constrained within these bounds.\n     * If a pan or zoom is performed that would\n     * display regions outside these bounds, the map will\n     * instead display a position and zoom level\n     * as close as possible to the operation's request while still\n     * remaining within the bounds.\n     *\n     * @param {LngLatBoundsLike | null | undefined} bounds The maximum bounds to set. If `null` or `undefined` is provided, the function removes the map's maximum bounds.\n     * @returns {Map} `this`\n     */\n    setMaxBounds(bounds: LngLatBoundsLike) {\n        this.transform.setMaxBounds(LngLatBounds.convert(bounds));\n        return this._update();\n    }\n\n    /**\n     * Sets or clears the map's minimum zoom level.\n     * If the map's current zoom level is lower than the new minimum,\n     * the map will zoom to the new minimum.\n     *\n     * @param {number | null | undefined} minZoom The minimum zoom level to set (0-24).\n     *   If `null` or `undefined` is provided, the function removes the current minimum zoom (i.e. sets it to 0).\n     * @returns {Map} `this`\n     */\n    setMinZoom(minZoom?: ?number) {\n\n        minZoom = minZoom === null || minZoom === undefined ? defaultMinZoom : minZoom;\n\n        if (minZoom >= defaultMinZoom && minZoom <= this.transform.maxZoom) {\n            this.transform.minZoom = minZoom;\n            this._update();\n\n            if (this.getZoom() < minZoom) this.setZoom(minZoom);\n\n            return this;\n\n        } else throw new Error(`minZoom must be between ${defaultMinZoom} and the current maxZoom, inclusive`);\n    }\n\n    /**\n     * Returns the map's minimum allowable zoom level.\n     *\n     * @returns {number} minZoom\n     */\n    getMinZoom() { return this.transform.minZoom; }\n\n    /**\n     * Sets or clears the map's maximum zoom level.\n     * If the map's current zoom level is higher than the new maximum,\n     * the map will zoom to the new maximum.\n     *\n     * @param {number | null | undefined} maxZoom The maximum zoom level to set.\n     *   If `null` or `undefined` is provided, the function removes the current maximum zoom (sets it to 22).\n     * @returns {Map} `this`\n     */\n    setMaxZoom(maxZoom?: ?number) {\n\n        maxZoom = maxZoom === null || maxZoom === undefined ? defaultMaxZoom : maxZoom;\n\n        if (maxZoom >= this.transform.minZoom) {\n            this.transform.maxZoom = maxZoom;\n            this._update();\n\n            if (this.getZoom() > maxZoom) this.setZoom(maxZoom);\n\n            return this;\n\n        } else throw new Error(`maxZoom must be greater than the current minZoom`);\n    }\n\n    /**\n     * Returns the state of renderWorldCopies.\n     *\n     * @returns {boolean} renderWorldCopies\n     */\n    getRenderWorldCopies() { return this.transform.renderWorldCopies; }\n\n    /**\n     * Sets the state of renderWorldCopies.\n     *\n     * @param {boolean} renderWorldCopies If `true`, multiple copies of the world will be rendered, when zoomed out. `undefined` is treated as `true`, `null` is treated as `false`.\n     * @returns {Map} `this`\n     */\n    setRenderWorldCopies(renderWorldCopies?: ?boolean) {\n        this.transform.renderWorldCopies = renderWorldCopies;\n        return this._update();\n    }\n\n    /**\n     * Returns the map's maximum allowable zoom level.\n     *\n     * @returns {number} maxZoom\n     */\n    getMaxZoom() { return this.transform.maxZoom; }\n\n    /**\n     * Returns a {@link Point} representing pixel coordinates, relative to the map's `container`,\n     * that correspond to the specified geographical location.\n     *\n     * @param {LngLatLike} lnglat The geographical location to project.\n     * @returns {Point} The {@link Point} corresponding to `lnglat`, relative to the map's `container`.\n     */\n    project(lnglat: LngLatLike) {\n        return this.transform.locationPoint(LngLat.convert(lnglat));\n    }\n\n    /**\n     * Returns a {@link LngLat} representing geographical coordinates that correspond\n     * to the specified pixel coordinates.\n     *\n     * @param {PointLike} point The pixel coordinates to unproject.\n     * @returns {LngLat} The {@link LngLat} corresponding to `point`.\n     * @see [Show polygon information on click](https://www.mapbox.com/mapbox-gl-js/example/polygon-popup-on-click/)\n     */\n    unproject(point: PointLike) {\n        return this.transform.pointLocation(Point.convert(point));\n    }\n\n    /**\n     * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.\n     */\n    isMoving(): boolean {\n        return this._moving ||\n            this.dragPan.isActive() ||\n            this.dragRotate.isActive() ||\n            this.scrollZoom.isActive();\n    }\n\n    /**\n     * Returns true if the map is zooming due to a camera animation or user gesture.\n     */\n    isZooming(): boolean {\n        return this._zooming ||\n            this.scrollZoom.isZooming();\n    }\n\n    /**\n     * Returns true if the map is rotating due to a camera animation or user gesture.\n     */\n    isRotating(): boolean {\n        return this._rotating ||\n            this.dragRotate.isActive();\n    }\n\n    /**\n     * Adds a listener for events of a specified type.\n     *\n     * @method\n     * @name on\n     * @memberof Map\n     * @instance\n     * @param {string} type The event type to add a listen for.\n     * @param {Function} listener The function to be called when the event is fired.\n     *   The listener function is called with the data object passed to `fire`,\n     *   extended with `target` and `type` properties.\n     * @returns {Map} `this`\n     */\n\n    /**\n     * Adds a listener for events of a specified type occurring on features in a specified style layer.\n     *\n     * @param {string} type The event type to listen for; one of `'mousedown'`, `'mouseup'`, `'click'`, `'dblclick'`,\n     * `'mousemove'`, `'mouseenter'`, `'mouseleave'`, `'mouseover'`, `'mouseout'`, `'contextmenu'`, `'touchstart'`,\n     * `'touchend'`, or `'touchcancel'`. `mouseenter` and `mouseover` events are triggered when the cursor enters\n     * a visible portion of the specified layer from outside that layer or outside the map canvas. `mouseleave`\n     * and `mouseout` events are triggered when the cursor leaves a visible portion of the specified layer, or leaves\n     * the map canvas.\n     * @param {string} layer The ID of a style layer. Only events whose location is within a visible\n     * feature in this layer will trigger the listener. The event will have a `features` property containing\n     * an array of the matching features.\n     * @param {Function} listener The function to be called when the event is fired.\n     * @returns {Map} `this`\n     */\n    on(type: MapEvent, layer: any, listener: any) {\n        if (listener === undefined) {\n            return super.on(type, layer);\n        }\n\n        const delegatedListener = (() => {\n            if (type === 'mouseenter' || type === 'mouseover') {\n                let mousein = false;\n                const mousemove = (e) => {\n                    const features = this.getLayer(layer) ? this.queryRenderedFeatures(e.point, {layers: [layer]}) : [];\n                    if (!features.length) {\n                        mousein = false;\n                    } else if (!mousein) {\n                        mousein = true;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent, {features}));\n                    }\n                };\n                const mouseout = () => {\n                    mousein = false;\n                };\n                return {layer, listener, delegates: {mousemove, mouseout}};\n            } else if (type === 'mouseleave' || type === 'mouseout') {\n                let mousein = false;\n                const mousemove = (e) => {\n                    const features = this.getLayer(layer) ? this.queryRenderedFeatures(e.point, {layers: [layer]}) : [];\n                    if (features.length) {\n                        mousein = true;\n                    } else if (mousein) {\n                        mousein = false;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent));\n                    }\n                };\n                const mouseout = (e) => {\n                    if (mousein) {\n                        mousein = false;\n                        listener.call(this, new MapMouseEvent(type, this, e.originalEvent));\n                    }\n                };\n                return {layer, listener, delegates: {mousemove, mouseout}};\n            } else {\n                const delegate = (e) => {\n                    const features = this.getLayer(layer) ? this.queryRenderedFeatures(e.point, {layers: [layer]}) : [];\n                    if (features.length) {\n                        // Here we need to mutate the original event, so that preventDefault works as expected.\n                        e.features = features;\n                        listener.call(this, e);\n                        delete e.features;\n                    }\n                };\n                return {layer, listener, delegates: {[type]: delegate}};\n            }\n        })();\n\n        this._delegatedListeners = this._delegatedListeners || {};\n        this._delegatedListeners[type] = this._delegatedListeners[type] || [];\n        this._delegatedListeners[type].push(delegatedListener);\n\n        for (const event in delegatedListener.delegates) {\n            this.on((event: any), delegatedListener.delegates[event]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Removes an event listener previously added with `Map#on`.\n     *\n     * @method\n     * @name off\n     * @memberof Map\n     * @instance\n     * @param {string} type The event type previously used to install the listener.\n     * @param {Function} listener The function previously installed as a listener.\n     * @returns {Map} `this`\n     */\n\n    /**\n     * Removes an event listener for layer-specific events previously added with `Map#on`.\n     *\n     * @param {string} type The event type previously used to install the listener.\n     * @param {string} layer The layer ID previously used to install the listener.\n     * @param {Function} listener The function previously installed as a listener.\n     * @returns {Map} `this`\n     */\n    off(type: MapEvent, layer: any, listener: any) {\n        if (listener === undefined) {\n            return super.off(type, layer);\n        }\n\n        if (this._delegatedListeners && this._delegatedListeners[type]) {\n            const listeners = this._delegatedListeners[type];\n            for (let i = 0; i < listeners.length; i++) {\n                const delegatedListener = listeners[i];\n                if (delegatedListener.layer === layer && delegatedListener.listener === listener) {\n                    for (const event in delegatedListener.delegates) {\n                        this.off((event: any), delegatedListener.delegates[event]);\n                    }\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns an array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2)\n     * representing visible features that satisfy the query parameters.\n     *\n     * @param {PointLike|Array<PointLike>} [geometry] - The geometry of the query region:\n     * either a single point or southwest and northeast points describing a bounding box.\n     * Omitting this parameter (i.e. calling {@link Map#queryRenderedFeatures} with zero arguments,\n     * or with only a `options` argument) is equivalent to passing a bounding box encompassing the entire\n     * map viewport.\n     * @param {Object} [options]\n     * @param {Array<string>} [options.layers] An array of style layer IDs for the query to inspect.\n     *   Only features within these layers will be returned. If this parameter is undefined, all layers will be checked.\n     * @param {Array} [options.filter] A [filter](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter)\n     *   to limit query results.\n     *\n     * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)\n     * [feature objects](https://tools.ietf.org/html/rfc7946#section-3.2).\n     *\n     * The `properties` value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only\n     * string and numeric property values are supported (i.e. `null`, `Array`, and `Object` values are not supported).\n     *\n     * Each feature includes top-level `layer`, `source`, and `sourceLayer` properties. The `layer` property is an object\n     * representing the style layer to  which the feature belongs. Layout and paint properties in this object contain values\n     * which are fully evaluated for the given zoom level and feature.\n     *\n     * Features from layers whose `visibility` property is `\"none\"`, or from layers whose zoom range excludes the\n     * current zoom level are not included. Symbol features that have been hidden due to text or icon collision are\n     * not included. Features from all other layers are included, including features that may have no visible\n     * contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to\n     * 0.\n     *\n     * The topmost rendered feature appears first in the returned array, and subsequent features are sorted by\n     * descending z-order. Features that are rendered multiple times (due to wrapping across the antimeridian at low\n     * zoom levels) are returned only once (though subject to the following caveat).\n     *\n     * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature\n     * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple\n     * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.\n     * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding\n     * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile\n     * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple\n     * tiles due to tile buffering.\n     *\n     * @example\n     * // Find all features at a point\n     * var features = map.queryRenderedFeatures(\n     *   [20, 35],\n     *   { layers: ['my-layer-name'] }\n     * );\n     *\n     * @example\n     * // Find all features within a static bounding box\n     * var features = map.queryRenderedFeatures(\n     *   [[10, 20], [30, 50]],\n     *   { layers: ['my-layer-name'] }\n     * );\n     *\n     * @example\n     * // Find all features within a bounding box around a point\n     * var width = 10;\n     * var height = 20;\n     * var features = map.queryRenderedFeatures([\n     *   [point.x - width / 2, point.y - height / 2],\n     *   [point.x + width / 2, point.y + height / 2]\n     * ], { layers: ['my-layer-name'] });\n     *\n     * @example\n     * // Query all rendered features from a single layer\n     * var features = map.queryRenderedFeatures({ layers: ['my-layer-name'] });\n     * @see [Get features under the mouse pointer](https://www.mapbox.com/mapbox-gl-js/example/queryrenderedfeatures/)\n     * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n     * @see [Center the map on a clicked symbol](https://www.mapbox.com/mapbox-gl-js/example/center-on-symbol/)\n     */\n    queryRenderedFeatures(geometry?: PointLike | [PointLike, PointLike], options?: Object) {\n        // The first parameter can be omitted entirely, making this effectively an overloaded method\n        // with two signatures:\n        //\n        //     queryRenderedFeatures(geometry: PointLike | [PointLike, PointLike], options?: Object)\n        //     queryRenderedFeatures(options?: Object)\n        //\n        // There no way to express that in a way that's compatible with both flow and documentation.js.\n        // Related: https://github.com/facebook/flow/issues/1556\n\n        if (!this.style) {\n            return [];\n        }\n\n        if (options === undefined && geometry !== undefined && !(geometry instanceof Point) && !Array.isArray(geometry)) {\n            options = (geometry: Object);\n            geometry = undefined;\n        }\n\n        options = options || {};\n        geometry = geometry || [[0, 0], [this.transform.width, this.transform.height]];\n\n        let queryGeometry;\n        if (geometry instanceof Point || typeof geometry[0] === 'number') {\n            queryGeometry = [Point.convert(geometry)];\n        } else {\n            const tl = Point.convert(geometry[0]);\n            const br = Point.convert(geometry[1]);\n            queryGeometry = [tl, new Point(br.x, tl.y), br, new Point(tl.x, br.y), tl];\n        }\n\n        return this.style.queryRenderedFeatures(queryGeometry, options, this.transform);\n    }\n\n    /**\n     * Returns an array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2)\n     * representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.\n     *\n     * @param {string} sourceID The ID of the vector tile or GeoJSON source to query.\n     * @param {Object} [parameters]\n     * @param {string} [parameters.sourceLayer] The name of the vector tile layer to query. *For vector tile\n     *   sources, this parameter is required.* For GeoJSON sources, it is ignored.\n     * @param {Array} [parameters.filter] A [filter](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter)\n     *   to limit query results.\n     *\n     * @returns {Array<Object>} An array of [GeoJSON](http://geojson.org/)\n     * [Feature objects](https://tools.ietf.org/html/rfc7946#section-3.2).\n     *\n     * In contrast to {@link Map#queryRenderedFeatures}, this function\n     * returns all features matching the query parameters,\n     * whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded\n     * vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently\n     * visible viewport.\n     *\n     * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature\n     * geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple\n     * times in query results. For example, suppose there is a highway running through the bounding rectangle of a query.\n     * The results of the query will be those parts of the highway that lie within the map tiles covering the bounding\n     * rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile\n     * will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple\n     * tiles due to tile buffering.\n     * @see [Filter features within map view](https://www.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/)\n     * @see [Highlight features containing similar data](https://www.mapbox.com/mapbox-gl-js/example/query-similar-features/)\n     */\n    querySourceFeatures(sourceID: string, parameters: ?{sourceLayer: ?string, filter: ?Array<any>}) {\n        return this.style.querySourceFeatures(sourceID, parameters);\n    }\n\n    /**\n     * Updates the map's Mapbox style object with a new value. If a style already is set and options.diff is true,\n     * this compares the style against the map's current state and performs only the changes necessary to make\n     * the map style match the desired state.\n     *\n     * @param style A JSON object conforming to the schema described in the\n     *   [Mapbox Style Specification](https://mapbox.com/mapbox-gl-style-spec/), or a URL to such JSON.\n     * @param {Object} [options]\n     * @param {boolean} [options.diff=true] If false, force a 'full' update, removing the current style\n     *   and building the given one instead of attempting a diff-based update.\n     * @param {string} [options.localIdeographFontFamily=null] If non-null, defines a css font-family\n     *   for locally overriding generation of glyphs in the 'CJK Unified Ideographs' and 'Hangul Syllables'\n     *   ranges. Forces a full update.\n     * @returns {Map} `this`\n     * @see [Change a map's style](https://www.mapbox.com/mapbox-gl-js/example/setstyle/)\n     */\n    setStyle(style: StyleSpecification | string | null, options?: {diff?: boolean} & StyleOptions) {\n        if ((!options || (options.diff !== false && !options.localIdeographFontFamily)) && this.style && style) {\n            this._diffStyle(style, options);\n            return this;\n        } else {\n            return this._updateStyle(style, options);\n        }\n    }\n\n    _updateStyle(style: StyleSpecification | string | null,  options?: {diff?: boolean} & StyleOptions) {\n        if (this.style) {\n            this.style.setEventedParent(null);\n            this.style._remove();\n        }\n\n        if (!style) {\n            delete this.style;\n            return this;\n        } else {\n            this.style = new Style(this, options || {});\n        }\n\n        this.style.setEventedParent(this, {style: this.style});\n\n        if (typeof style === 'string') {\n            this.style.loadURL(style);\n        } else {\n            this.style.loadJSON(style);\n        }\n\n        return this;\n    }\n\n    _diffStyle(style: StyleSpecification | string,  options?: {diff?: boolean} & StyleOptions) {\n        if (typeof style === 'string') {\n            const url = normalizeStyleURL(style);\n            const request = this._transformRequest(url, ResourceType.Style);\n            getJSON(request, (error: ?Error, json: ?Object) => {\n                if (error) {\n                    this.fire(new ErrorEvent(error));\n                } else if (json) {\n                    this._updateDiff(json, options);\n                }\n            });\n        } else if (typeof style === 'object') {\n            this._updateDiff(style, options);\n        }\n    }\n\n    _updateDiff(style: StyleSpecification,  options?: {diff?: boolean} & StyleOptions) {\n        try {\n            if (this.style.setState(style)) {\n                this._update(true);\n            }\n        } catch (e) {\n            warnOnce(\n                `Unable to perform style diff: ${e.message || e.error || e}.  Rebuilding the style from scratch.`\n            );\n            this._updateStyle(style, options);\n        }\n    }\n\n    /**\n     * Returns the map's Mapbox style object, which can be used to recreate the map's style.\n     *\n     * @returns {Object} The map's style object.\n     */\n    getStyle() {\n        if (this.style) {\n            return this.style.serialize();\n        }\n    }\n\n    /**\n     * Returns a Boolean indicating whether the map's style is fully loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether the style is fully loaded.\n     */\n    isStyleLoaded() {\n        if (!this.style) return warnOnce('There is no style added to the map.');\n        return this.style.loaded();\n    }\n\n    /**\n     * Adds a source to the map's style.\n     *\n     * @param {string} id The ID of the source to add. Must not conflict with existing sources.\n     * @param {Object} source The source object, conforming to the\n     * Mapbox Style Specification's [source definition](https://www.mapbox.com/mapbox-gl-style-spec/#sources) or\n     * {@link CanvasSourceOptions}.\n     * @fires source.add\n     * @returns {Map} `this`\n     * @see [Draw GeoJSON points](https://www.mapbox.com/mapbox-gl-js/example/geojson-markers/)\n     * @see [Style circles using data-driven styling](https://www.mapbox.com/mapbox-gl-js/example/data-driven-circle-colors/)\n     * @see [Set a point after Geocoder result](https://www.mapbox.com/mapbox-gl-js/example/point-from-geocoder-result/)\n     */\n    addSource(id: string, source: SourceSpecification) {\n        this.style.addSource(id, source);\n        return this._update(true);\n    }\n\n    /**\n     * Returns a Boolean indicating whether the source is loaded.\n     *\n     * @param {string} id The ID of the source to be checked.\n     * @returns {boolean} A Boolean indicating whether the source is loaded.\n     */\n    isSourceLoaded(id: string) {\n        const source = this.style && this.style.sourceCaches[id];\n        if (source === undefined) {\n            this.fire(new ErrorEvent(new Error(`There is no source with ID '${id}'`)));\n            return;\n        }\n        return source.loaded();\n    }\n\n    /**\n     * Returns a Boolean indicating whether all tiles in the viewport from all sources on\n     * the style are loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether all tiles are loaded.\n     */\n\n    areTilesLoaded() {\n        const sources = this.style && this.style.sourceCaches;\n        for (const id in sources) {\n            const source = sources[id];\n            const tiles = source._tiles;\n            for (const t in tiles) {\n                const tile = tiles[t];\n                if (!(tile.state === 'loaded' || tile.state === 'errored')) return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Adds a [custom source type](#Custom Sources), making it available for use with\n     * {@link Map#addSource}.\n     * @private\n     * @param {string} name The name of the source type; source definition objects use this name in the `{type: ...}` field.\n     * @param {Function} SourceType A {@link Source} constructor.\n     * @param {Function} callback Called when the source type is ready or with an error argument if there is an error.\n     */\n    addSourceType(name: string, SourceType: any, callback: Function) {\n        return this.style.addSourceType(name, SourceType, callback);\n    }\n\n    /**\n     * Removes a source from the map's style.\n     *\n     * @param {string} id The ID of the source to remove.\n     * @returns {Map} `this`\n     */\n    removeSource(id: string) {\n        this.style.removeSource(id);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the source with the specified ID in the map's style.\n     *\n     * @param {string} id The ID of the source to get.\n     * @returns {?Object} The style source with the specified ID, or `undefined`\n     *   if the ID corresponds to no existing sources.\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     * @see [Animate a point](https://www.mapbox.com/mapbox-gl-js/example/animate-point-along-line/)\n     * @see [Add live realtime data](https://www.mapbox.com/mapbox-gl-js/example/live-geojson/)\n     */\n    getSource(id: string) {\n        return this.style.getSource(id);\n    }\n\n    /**\n     * Add an image to the style. This image can be used in `icon-image`,\n     * `background-pattern`, `fill-pattern`, and `line-pattern`. An\n     * {@link Map#error} event will be fired if there is not enough space in the\n     * sprite to add this image.\n     *\n     * @see [Add an icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image/)\n     * @see [Add a generated icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image-generated/)\n     * @param id The ID of the image.\n     * @param image The image as an `HTMLImageElement`, `ImageData`, or object with `width`, `height`, and `data`\n     * properties with the same format as `ImageData`.\n     * @param options\n     * @param options.pixelRatio The ratio of pixels in the image to physical pixels on the screen\n     * @param options.sdf Whether the image should be interpreted as an SDF image\n     */\n    addImage(id: string,\n             image: HTMLImageElement | ImageData | {width: number, height: number, data: Uint8Array | Uint8ClampedArray},\n             {pixelRatio = 1, sdf = false}: {pixelRatio?: number, sdf?: boolean} = {}) {\n        if (image instanceof HTMLImageElement) {\n            const {width, height, data} = browser.getImageData(image);\n            this.style.addImage(id, { data: new RGBAImage({width, height}, data), pixelRatio, sdf });\n        } else if (image.width === undefined || image.height === undefined) {\n            return this.fire(new ErrorEvent(new Error(\n                'Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, ' +\n                'or object with `width`, `height`, and `data` properties with the same format as `ImageData`')));\n        } else {\n            const {width, height, data} = image;\n            this.style.addImage(id, { data: new RGBAImage({width, height}, new Uint8Array(data)), pixelRatio, sdf });\n        }\n    }\n\n    /**\n     * Define wether the image has been added or not\n     *\n     * @param id The ID of the image.\n     */\n    hasImage(id: string): boolean {\n        if (!id) {\n            this.fire(new ErrorEvent(new Error('Missing required image id')));\n            return false;\n        }\n\n        return !!this.style.getImage(id);\n    }\n\n    /**\n     * Remove an image from the style (such as one used by `icon-image` or `background-pattern`).\n     *\n     * @param id The ID of the image.\n     */\n    removeImage(id: string) {\n        this.style.removeImage(id);\n    }\n\n    /**\n     * Load an image from an external URL for use with `Map#addImage`. External\n     * domains must support [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).\n     *\n     * @param {string} url The URL of the image file. Image file must be in png, webp, or jpg format.\n     * @param {Function} callback Expecting `callback(error, data)`. Called when the image has loaded or with an error argument if there is an error.\n     * @see [Add an icon to the map](https://www.mapbox.com/mapbox-gl-js/example/add-image/)\n     */\n    loadImage(url: string, callback: Function) {\n        getImage(this._transformRequest(url, ResourceType.Image), callback);\n    }\n\n    /**\n    * Returns an Array of strings containing the names of all sprites/images currently available in the map\n    *\n    * @returns {Array<string>} An Array of strings containing the names of all sprites/images currently available in the map\n    *\n    */\n    listImages() {\n        return this.style.listImages();\n    }\n\n    /**\n     * Adds a [Mapbox style layer](https://www.mapbox.com/mapbox-gl-style-spec/#layers)\n     * to the map's style.\n     *\n     * A layer defines styling for data from a specified source.\n     *\n     * @param {Object | CustomLayerInterface} layer The style layer to add, conforming to the Mapbox Style Specification's\n     *   [layer definition](https://www.mapbox.com/mapbox-gl-style-spec/#layers).\n     * @param {string} [before] The ID of an existing layer to insert the new layer before.\n     *   If this argument is omitted, the layer will be appended to the end of the layers array.\n     * @returns {Map} `this`\n     * @see [Create and style clusters](https://www.mapbox.com/mapbox-gl-js/example/cluster/)\n     * @see [Add a vector tile source](https://www.mapbox.com/mapbox-gl-js/example/vector-source/)\n     * @see [Add a WMS source](https://www.mapbox.com/mapbox-gl-js/example/wms/)\n     */\n    addLayer(layer: LayerSpecification | CustomLayerInterface, before?: string) {\n        this.style.addLayer(layer, before);\n        return this._update(true);\n    }\n\n    /**\n     * Moves a layer to a different z-position.\n     *\n     * @param {string} id The ID of the layer to move.\n     * @param {string} [beforeId] The ID of an existing layer to insert the new layer before.\n     *   If this argument is omitted, the layer will be appended to the end of the layers array.\n     * @returns {Map} `this`\n     */\n    moveLayer(id: string, beforeId?: string) {\n        this.style.moveLayer(id, beforeId);\n        return this._update(true);\n    }\n\n    /**\n     * Removes the layer with the given id from the map's style.\n     *\n     * If no such layer exists, an `error` event is fired.\n     *\n     * @param {string} id id of the layer to remove\n     * @fires error\n     */\n    removeLayer(id: string) {\n        this.style.removeLayer(id);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the layer with the specified ID in the map's style.\n     *\n     * @param {string} id The ID of the layer to get.\n     * @returns {?Object} The layer with the specified ID, or `undefined`\n     *   if the ID corresponds to no existing layers.\n     * @see [Filter symbols by toggling a list](https://www.mapbox.com/mapbox-gl-js/example/filter-markers/)\n     * @see [Filter symbols by text input](https://www.mapbox.com/mapbox-gl-js/example/filter-markers-by-input/)\n     */\n    getLayer(id: string) {\n        return this.style.getLayer(id);\n    }\n\n    /**\n     * Sets the filter for the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to which the filter will be applied.\n     * @param {Array | null | undefined} filter The filter, conforming to the Mapbox Style Specification's\n     *   [filter definition](https://www.mapbox.com/mapbox-gl-js/style-spec/#other-filter).  If `null` or `undefined` is provided, the function removes any existing filter from the layer.\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if the filter conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     *\n     * @returns {Map} `this`\n     * @example\n     * map.setFilter('my-layer', ['==', 'name', 'USA']);\n     * @see [Filter features within map view](https://www.mapbox.com/mapbox-gl-js/example/filter-features-within-map-view/)\n     * @see [Highlight features containing similar data](https://www.mapbox.com/mapbox-gl-js/example/query-similar-features/)\n     * @see [Create a timeline animation](https://www.mapbox.com/mapbox-gl-js/example/timeline-animation/)\n     */\n    setFilter(layer: string, filter: ?FilterSpecification,  options: StyleSetterOptions = {}) {\n        this.style.setFilter(layer, filter, options);\n        return this._update(true);\n    }\n\n    /**\n     * Sets the zoom extent for the specified style layer.\n     *\n     * @param {string} layerId The ID of the layer to which the zoom extent will be applied.\n     * @param {number} minzoom The minimum zoom to set (0-24).\n     * @param {number} maxzoom The maximum zoom to set (0-24).\n     * @returns {Map} `this`\n     * @example\n     * map.setLayerZoomRange('my-layer', 2, 5);\n     */\n    setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number) {\n        this.style.setLayerZoomRange(layerId, minzoom, maxzoom);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the filter applied to the specified style layer.\n     *\n     * @param {string} layer The ID of the style layer whose filter to get.\n     * @returns {Array} The layer's filter.\n     */\n    getFilter(layer: string) {\n        return this.style.getFilter(layer);\n    }\n\n    /**\n     * Sets the value of a paint property in the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to set the paint property in.\n     * @param {string} name The name of the paint property to set.\n     * @param {*} value The value of the paint propery to set.\n     *   Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if `value` conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     * @example\n     * map.setPaintProperty('my-layer', 'fill-color', '#faafee');\n     * @see [Change a layer's color with buttons](https://www.mapbox.com/mapbox-gl-js/example/color-switcher/)\n     * @see [Adjust a layer's opacity](https://www.mapbox.com/mapbox-gl-js/example/adjust-layer-opacity/)\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     */\n    setPaintProperty(layer: string, name: string, value: any, options: StyleSetterOptions = {}) {\n        this.style.setPaintProperty(layer, name, value, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of a paint property in the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to get the paint property from.\n     * @param {string} name The name of a paint property to get.\n     * @returns {*} The value of the specified paint property.\n     */\n    getPaintProperty(layer: string, name: string) {\n        return this.style.getPaintProperty(layer, name);\n    }\n\n    /**\n     * Sets the value of a layout property in the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to set the layout property in.\n     * @param {string} name The name of the layout property to set.\n     * @param {*} value The value of the layout propery. Must be of a type appropriate for the property, as defined in the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if `value` conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     * @example\n     * map.setLayoutProperty('my-layer', 'visibility', 'none');\n     */\n    setLayoutProperty(layer: string, name: string, value: any, options: StyleSetterOptions = {}) {\n        this.style.setLayoutProperty(layer, name, value, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of a layout property in the specified style layer.\n     *\n     * @param {string} layer The ID of the layer to get the layout property from.\n     * @param {string} name The name of the layout property to get.\n     * @returns {*} The value of the specified layout property.\n     */\n    getLayoutProperty(layer: string, name: string) {\n        return this.style.getLayoutProperty(layer, name);\n    }\n\n    /**\n     * Sets the any combination of light values.\n     *\n     * @param light Light properties to set. Must conform to the [Mapbox Style Specification](https://www.mapbox.com/mapbox-gl-style-spec/#light).\n     * @param {Object} [options]\n     * @param {boolean} [options.validate=true] Whether to check if the filter conforms to the Mapbox GL Style Specification. Disabling validation is a performance optimization that should only be used if you have previously validated the values you will be passing to this function.\n     * @returns {Map} `this`\n     */\n    setLight(light: LightSpecification, options: StyleSetterOptions = {}) {\n        this.style.setLight(light, options);\n        return this._update(true);\n    }\n\n    /**\n     * Returns the value of the light object.\n     *\n     * @returns {Object} light Light properties of the style.\n     */\n    getLight() {\n        return this.style.getLight();\n    }\n\n    /**\n     * Sets the state of a feature. The `state` object is merged in with the existing state of the feature.\n     *\n     * @param {Object} feature Feature identifier. Feature objects returned from\n     * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.\n     * @param {string | number} feature.id Unique id of the feature.\n     * @param {string} feature.source The Id of the vector source or GeoJSON source for the feature.\n     * @param {string} [feature.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is\n     *  required.*\n     * @param {Object} state A set of key-value pairs. The values should be valid JSON types.\n     *\n     * This method requires the `feature.id` attribute on data sets. For GeoJSON sources without\n     * feature ids, set the `generateIds` option in the `GeoJSONSourceSpecification` to auto-assign them. This\n     * option assigns ids based on a feature's index in the source data. If you change feature data using\n     * `map.getSource('some id').setData(..)`, you may need to re-apply state taking into account updated `id` values.\n     */\n    setFeatureState(feature: { source: string; sourceLayer?: string; id: string | number; }, state: Object) {\n        this.style.setFeatureState(feature, state);\n        return this._update();\n    }\n\n    /**\n     * Removes feature state, setting it back to the default behavior. If only\n     * source is specified, removes all states of that source. If\n     * target.id is also specified, removes all keys for that feature's state.\n     * If key is also specified, removes that key from that feature's state.\n     *\n     * @param {Object} target Identifier of where to set state: can be a source, a feature, or a specific key of feature.\n     * Feature objects returned from {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.\n     * @param {string | number} target.id (optional) Unique id of the feature. Optional if key is not specified.\n     * @param {string} target.source The Id of the vector source or GeoJSON source for the feature.\n     * @param {string} [target.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is\n     *  required.*\n     * @param {string} key (optional) The key in the feature state to reset.\n    */\n    removeFeatureState(target: { source: string; sourceLayer?: string; id?: string | number; }, key?: string) {\n        this.style.removeFeatureState(target, key);\n        return this._update();\n    }\n\n    /**\n     * Gets the state of a feature.\n     *\n     * @param {Object} feature Feature identifier. Feature objects returned from\n     * {@link Map#queryRenderedFeatures} or event handlers can be used as feature identifiers.\n     * @param {string | number} feature.id Unique id of the feature.\n     * @param {string} feature.source The Id of the vector source or GeoJSON source for the feature.\n     * @param {string} [feature.sourceLayer] (optional)  *For vector tile sources, the sourceLayer is\n     *  required.*\n     *\n     * @returns {Object} The state of the feature.\n     */\n    getFeatureState(feature: { source: string; sourceLayer?: string; id: string | number; }): any {\n        return this.style.getFeatureState(feature);\n    }\n\n    /**\n     * Returns the map's containing HTML element.\n     *\n     * @returns {HTMLElement} The map's container.\n     */\n    getContainer() {\n        return this._container;\n    }\n\n    /**\n     * Returns the HTML element containing the map's `<canvas>` element.\n     *\n     * If you want to add non-GL overlays to the map, you should append them to this element.\n     *\n     * This is the element to which event bindings for map interactivity (such as panning and zooming) are\n     * attached. It will receive bubbled events from child elements such as the `<canvas>`, but not from\n     * map controls.\n     *\n     * @returns {HTMLElement} The container of the map's `<canvas>`.\n     * @see [Create a draggable point](https://www.mapbox.com/mapbox-gl-js/example/drag-a-point/)\n     * @see [Highlight features within a bounding box](https://www.mapbox.com/mapbox-gl-js/example/using-box-queryrenderedfeatures/)\n     */\n    getCanvasContainer() {\n        return this._canvasContainer;\n    }\n\n    /**\n     * Returns the map's `<canvas>` element.\n     *\n     * @returns {HTMLCanvasElement} The map's `<canvas>` element.\n     * @see [Measure distances](https://www.mapbox.com/mapbox-gl-js/example/measure/)\n     * @see [Display a popup on hover](https://www.mapbox.com/mapbox-gl-js/example/popup-on-hover/)\n     * @see [Center the map on a clicked symbol](https://www.mapbox.com/mapbox-gl-js/example/center-on-symbol/)\n     */\n    getCanvas() {\n        return this._canvas;\n    }\n\n    _containerDimensions() {\n        let width = 0;\n        let height = 0;\n\n        if (this._container) {\n            width = this._container.clientWidth || 400;\n            height = this._container.clientHeight || 300;\n        }\n\n        return [width, height];\n    }\n\n    _detectMissingCSS(): void {\n        const computedColor = window.getComputedStyle(this._missingCSSCanary).getPropertyValue('background-color');\n        if (computedColor !== 'rgb(250, 128, 114)') {\n            warnOnce('This page appears to be missing CSS declarations for ' +\n                'Mapbox GL JS, which may cause the map to display incorrectly. ' +\n                'Please ensure your page includes mapbox-gl.css, as described ' +\n                'in https://www.mapbox.com/mapbox-gl-js/api/.');\n        }\n    }\n\n    _setupContainer() {\n        const container = this._container;\n        container.classList.add('mapboxgl-map');\n\n        const missingCSSCanary = this._missingCSSCanary = DOM.create('div', 'mapboxgl-canary', container);\n        missingCSSCanary.style.visibility = 'hidden';\n        this._detectMissingCSS();\n\n        const canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);\n        if (this._interactive) {\n            canvasContainer.classList.add('mapboxgl-interactive');\n        }\n\n        this._canvas = DOM.create('canvas', 'mapboxgl-canvas', canvasContainer);\n        this._canvas.style.position = 'absolute';\n        this._canvas.addEventListener('webglcontextlost', this._contextLost, false);\n        this._canvas.addEventListener('webglcontextrestored', this._contextRestored, false);\n        this._canvas.setAttribute('tabindex', '0');\n        this._canvas.setAttribute('aria-label', 'Map');\n\n        const dimensions = this._containerDimensions();\n        this._resizeCanvas(dimensions[0], dimensions[1]);\n\n        const controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);\n        const positions = this._controlPositions = {};\n        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach((positionName) => {\n            positions[positionName] = DOM.create('div', `mapboxgl-ctrl-${positionName}`, controlContainer);\n        });\n    }\n\n    _resizeCanvas(width: number, height: number) {\n        const pixelRatio = window.devicePixelRatio || 1;\n\n        // Request the required canvas size taking the pixelratio into account.\n        this._canvas.width = pixelRatio * width;\n        this._canvas.height = pixelRatio * height;\n\n        // Maintain the same canvas size, potentially downscaling it for HiDPI displays\n        this._canvas.style.width = `${width}px`;\n        this._canvas.style.height = `${height}px`;\n    }\n\n    _setupPainter() {\n        const attributes = extend({\n            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,\n            preserveDrawingBuffer: this._preserveDrawingBuffer\n        }, isSupported.webGLContextAttributes);\n\n        const gl = this._canvas.getContext('webgl', attributes) ||\n            this._canvas.getContext('experimental-webgl', attributes);\n\n        if (!gl) {\n            this.fire(new ErrorEvent(new Error('Failed to initialize WebGL')));\n            return;\n        }\n\n        this.painter = new Painter(gl, this.transform);\n\n        webpSupported.testSupport(gl);\n    }\n\n    _contextLost(event: *) {\n        event.preventDefault();\n        if (this._frame) {\n            this._frame.cancel();\n            this._frame = null;\n        }\n        this.fire(new Event('webglcontextlost', {originalEvent: event}));\n    }\n\n    _contextRestored(event: *) {\n        this._setupPainter();\n        this.resize();\n        this._update();\n        this.fire(new Event('webglcontextrestored', {originalEvent: event}));\n    }\n\n    /**\n     * Returns a Boolean indicating whether the map is fully loaded.\n     *\n     * Returns `false` if the style is not yet fully loaded,\n     * or if there has been a change to the sources or style that\n     * has not yet fully loaded.\n     *\n     * @returns {boolean} A Boolean indicating whether the map is fully loaded.\n     */\n    loaded() {\n        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();\n    }\n\n    /**\n     * Update this map's style and sources, and re-render the map.\n     *\n     * @param {boolean} updateStyle mark the map's style for reprocessing as\n     * well as its sources\n     * @returns {Map} this\n     * @private\n     */\n    _update(updateStyle?: boolean) {\n        if (!this.style) return this;\n\n        this._styleDirty = this._styleDirty || updateStyle;\n        this._sourcesDirty = true;\n        this.triggerRepaint();\n\n        return this;\n    }\n\n    /**\n     * Request that the given callback be executed during the next render\n     * frame.  Schedule a render frame if one is not already scheduled.\n     * @returns An id that can be used to cancel the callback\n     * @private\n     */\n    _requestRenderFrame(callback: () => void): TaskID {\n        this._update();\n        return this._renderTaskQueue.add(callback);\n    }\n\n    _cancelRenderFrame(id: TaskID) {\n        this._renderTaskQueue.remove(id);\n    }\n\n    /**\n     * Call when a (re-)render of the map is required:\n     * - The style has changed (`setPaintProperty()`, etc.)\n     * - Source data has changed (e.g. tiles have finished loading)\n     * - The map has is moving (or just finished moving)\n     * - A transition is in progress\n     *\n     * @returns {Map} this\n     * @private\n     */\n    _render() {\n        // A custom layer may have used the context asynchronously. Mark the state as dirty.\n        this.painter.context.setDirty();\n        this.painter.setBaseState();\n\n        this._renderTaskQueue.run();\n\n        let crossFading = false;\n\n        // If the style has changed, the map is being zoomed, or a transition or fade is in progress:\n        //  - Apply style changes (in a batch)\n        //  - Recalculate paint properties.\n        if (this.style && this._styleDirty) {\n            this._styleDirty = false;\n\n            const zoom = this.transform.zoom;\n            const now = browser.now();\n            this.style.zoomHistory.update(zoom, now);\n\n            const parameters = new EvaluationParameters(zoom, {\n                now,\n                fadeDuration: this._fadeDuration,\n                zoomHistory: this.style.zoomHistory,\n                transition: this.style.getTransition()\n            });\n\n            const factor = parameters.crossFadingFactor();\n            if (factor !== 1 || factor !== this._crossFadingFactor) {\n                crossFading = true;\n                this._crossFadingFactor = factor;\n            }\n\n            this.style.update(parameters);\n        }\n\n        // If we are in _render for any reason other than an in-progress paint\n        // transition, update source caches to check for and load any tiles we\n        // need for the current transform\n        if (this.style && this._sourcesDirty) {\n            this._sourcesDirty = false;\n            this.style._updateSources(this.transform);\n        }\n\n        this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions);\n\n        // Actually draw\n        this.painter.render(this.style, {\n            showTileBoundaries: this.showTileBoundaries,\n            showOverdrawInspector: this._showOverdrawInspector,\n            rotating: this.isRotating(),\n            zooming: this.isZooming(),\n            moving: this.isMoving(),\n            fadeDuration: this._fadeDuration\n        });\n\n        this.fire(new Event('render'));\n\n        if (this.loaded() && !this._loaded) {\n            this._loaded = true;\n            this.fire(new Event('load'));\n        }\n\n        if (this.style && (this.style.hasTransitions() || crossFading)) {\n            this._styleDirty = true;\n        }\n\n        if (this.style && !this._placementDirty) {\n            // Since no fade operations are in progress, we can release\n            // all tiles held for fading. If we didn't do this, the tiles\n            // would just sit in the SourceCaches until the next render\n            this.style._releaseSymbolFadeTiles();\n        }\n\n        // Schedule another render frame if it's needed.\n        //\n        // Even though `_styleDirty` and `_sourcesDirty` are reset in this\n        // method, synchronous events fired during Style#update or\n        // Style#_updateSources could have caused them to be set again.\n        if (this._sourcesDirty || this._repaint || this._styleDirty || this._placementDirty) {\n            this.triggerRepaint();\n        } else if (!this.isMoving() && this.loaded()) {\n            this.fire(new Event('idle'));\n        }\n        return this;\n    }\n\n    /**\n     * Clean up and release all internal resources associated with this map.\n     *\n     * This includes DOM elements, event bindings, web workers, and WebGL resources.\n     *\n     * Use this method when you are done using the map and wish to ensure that it no\n     * longer consumes browser resources. Afterwards, you must not call any other\n     * methods on the map.\n     */\n    remove() {\n        if (this._hash) this._hash.remove();\n\n        for (const control of this._controls) control.onRemove(this);\n        this._controls = [];\n\n        if (this._frame) {\n            this._frame.cancel();\n            this._frame = null;\n        }\n        this._renderTaskQueue.clear();\n        this.setStyle(null);\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('resize', this._onWindowResize, false);\n            window.removeEventListener('online', this._onWindowOnline, false);\n        }\n\n        const extension = this.painter.context.gl.getExtension('WEBGL_lose_context');\n        if (extension) extension.loseContext();\n        removeNode(this._canvasContainer);\n        removeNode(this._controlContainer);\n        removeNode(this._missingCSSCanary);\n        this._container.classList.remove('mapboxgl-map');\n        this.fire(new Event('remove'));\n    }\n\n    /**\n     * Trigger the rendering of a single frame. Use this method with custom layers to\n     * repaint the map when the layer changes. Calling this multiple times before the\n     * next frame is rendered will still result in only a single frame being rendered.\n     */\n    triggerRepaint() {\n        if (this.style && !this._frame) {\n            this._frame = browser.frame(() => {\n                this._frame = null;\n                this._render();\n            });\n        }\n    }\n\n    _onWindowOnline() {\n        this._update();\n    }\n\n    _onWindowResize() {\n        if (this._trackResize) {\n            this.resize()._update();\n        }\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will render an outline\n     * around each tile. These tile boundaries are useful for debugging.\n     *\n     * @name showTileBoundaries\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showTileBoundaries(): boolean { return !!this._showTileBoundaries; }\n    set showTileBoundaries(value: boolean) {\n        if (this._showTileBoundaries === value) return;\n        this._showTileBoundaries = value;\n        this._update();\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will render boxes\n     * around all symbols in the data source, revealing which symbols\n     * were rendered or which were hidden due to collisions.\n     * This information is useful for debugging.\n     *\n     * @name showCollisionBoxes\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showCollisionBoxes(): boolean { return !!this._showCollisionBoxes; }\n    set showCollisionBoxes(value: boolean) {\n        if (this._showCollisionBoxes === value) return;\n        this._showCollisionBoxes = value;\n        if (value) {\n            // When we turn collision boxes on we have to generate them for existing tiles\n            // When we turn them off, there's no cost to leaving existing boxes in place\n            this.style._generateCollisionBoxes();\n        } else {\n            // Otherwise, call an update to remove collision boxes\n            this._update();\n        }\n    }\n\n    /*\n     * Gets and sets a Boolean indicating whether the map should color-code\n     * each fragment to show how many times it has been shaded.\n     * White fragments have been shaded 8 or more times.\n     * Black fragments have been shaded 0 times.\n     * This information is useful for debugging.\n     *\n     * @name showOverdraw\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get showOverdrawInspector(): boolean { return !!this._showOverdrawInspector; }\n    set showOverdrawInspector(value: boolean) {\n        if (this._showOverdrawInspector === value) return;\n        this._showOverdrawInspector = value;\n        this._update();\n    }\n\n    /**\n     * Gets and sets a Boolean indicating whether the map will\n     * continuously repaint. This information is useful for analyzing performance.\n     *\n     * @name repaint\n     * @type {boolean}\n     * @instance\n     * @memberof Map\n     */\n    get repaint(): boolean { return !!this._repaint; }\n    set repaint(value: boolean) {\n        if (this._repaint !== value) {\n            this._repaint = value;\n            this.triggerRepaint();\n        }\n    }\n    // show vertices\n    get vertices(): boolean { return !!this._vertices; }\n    set vertices(value: boolean) { this._vertices = value; this._update(); }\n}\n\nexport default Map;\n\nfunction removeNode(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\n\n/**\n * Interface for interactive controls added to the map. This is an\n * specification for implementers to model: it is not\n * an exported method or class.\n *\n * Controls must implement `onAdd` and `onRemove`, and must own an\n * element, which is often a `div` element. To use Mapbox GL JS's\n * default control styling, add the `mapboxgl-ctrl` class to your control's\n * node.\n *\n * @interface IControl\n * @example\n * // Control implemented as ES6 class\n * class HelloWorldControl {\n *     onAdd(map) {\n *         this._map = map;\n *         this._container = document.createElement('div');\n *         this._container.className = 'mapboxgl-ctrl';\n *         this._container.textContent = 'Hello, world';\n *         return this._container;\n *     }\n *\n *     onRemove() {\n *         this._container.parentNode.removeChild(this._container);\n *         this._map = undefined;\n *     }\n * }\n *\n * // Control implemented as ES5 prototypical class\n * function HelloWorldControl() { }\n *\n * HelloWorldControl.prototype.onAdd = function(map) {\n *     this._map = map;\n *     this._container = document.createElement('div');\n *     this._container.className = 'mapboxgl-ctrl';\n *     this._container.textContent = 'Hello, world';\n *     return this._container;\n * };\n *\n * HelloWorldControl.prototype.onRemove = function () {\n *      this._container.parentNode.removeChild(this._container);\n *      this._map = undefined;\n * };\n */\n\n/**\n * Register a control on the map and give it a chance to register event listeners\n * and resources. This method is called by {@link Map#addControl}\n * internally.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name onAdd\n * @param {Map} map the Map this control will be added to\n * @returns {HTMLElement} The control's container element. This should\n * be created by the control and returned by onAdd without being attached\n * to the DOM: the map will insert the control's element into the DOM\n * as necessary.\n */\n\n/**\n * Unregister a control on the map and give it a chance to detach event listeners\n * and resources. This method is called by {@link Map#removeControl}\n * internally.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name onRemove\n * @param {Map} map the Map this control will be removed from\n * @returns {undefined} there is no required return value for this method\n */\n\n/**\n * Optionally provide a default position for this control. If this method\n * is implemented and {@link Map#addControl} is called without the `position`\n * parameter, the value returned by getDefaultPosition will be used as the\n * control's position.\n *\n * @function\n * @memberof IControl\n * @instance\n * @name getDefaultPosition\n * @returns {string} a control position, one of the values valid in addControl.\n */\n\n/**\n * A [`Point` geometry](https://github.com/mapbox/point-geometry) object, which has\n * `x` and `y` properties representing screen coordinates in pixels.\n *\n * @typedef {Object} Point\n */\n\n/**\n * A {@link Point} or an array of two numbers representing `x` and `y` screen coordinates in pixels.\n *\n * @typedef {(Point | Array<number>)} PointLike\n */\n","'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n  var dict;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      // Convert data if needed\n      if (typeof dictionary === 'string') {\n        dict = strings.string2buf(dictionary);\n      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(dictionary);\n      } else {\n        dict = dictionary;\n      }\n\n      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","import VectorTileSource from 'mapbox-gl/src/source/vector_tile_source'\nimport pako from 'pako/lib/inflate'\nimport base64js from 'base64-js'\n\nclass MBTilesSource extends VectorTileSource {\n\n    constructor(id, options, dispatcher, eventedParent) {\n        super(id, options, dispatcher, eventedParent);\n        this.type = \"mbtiles\";\n        this.db = this.openDatabase(options.path);\n    }\n\n    openDatabase(dbLocation) {\n        const dbName = dbLocation.split(\"/\").slice(-1)[0]; // Get the DB file basename\n        const source = this;\n        if ('sqlitePlugin' in self) {\n            if('device' in self) {\n                return new Promise(function (resolve, reject) {\n                    if(device.platform === 'Android') {\n                        resolveLocalFileSystemURL(cordova.file.applicationStorageDirectory, function (dir) {\n                            dir.getDirectory('databases', {create: true}, function (subdir) {\n                                resolve(subdir);\n                            });\n                        }, reject);\n                    } else if(device.platform === 'iOS') {\n                        resolveLocalFileSystemURL(cordova.file.documentsDirectory, resolve, reject);\n                    } else {\n                        reject(\"Platform not supported\");\n                    }\n                }).then(function (targetDir) {\n                    return new Promise(function (resolve, reject) {\n                        targetDir.getFile(dbName, {}, resolve, reject);\n                    }).catch(function () {\n                        return source.copyDatabaseFile(dbLocation, dbName, targetDir)\n                    });\n                }).then(function () {\n                    var params = {name: dbName};\n                    if(device.platform === 'iOS') {\n                        params.iosDatabaseLocation = 'Documents';\n                    } else {\n                        params.location = 'default';\n                    }\n                    return sqlitePlugin.openDatabase(params);\n                });\n            } else {\n                return Promise.reject(new Error(\"cordova-plugin-device not available. \" +\n                    \"Please install the plugin and make sure this code is run after onDeviceReady event\"));\n            }\n        } else {\n            return Promise.reject(new Error(\"cordova-sqlite-ext plugin not available. \" +\n                \"Please install the plugin and make sure this code is run after onDeviceReady event\"));\n        }\n    }\n\n    copyDatabaseFile(dbLocation, dbName, targetDir) {\n        console.log(\"Copying database to application storage directory\");\n        return new Promise(function (resolve, reject) {\n            const absPath =  cordova.file.applicationDirectory + 'www/' + dbLocation;\n            resolveLocalFileSystemURL(absPath, resolve, reject);\n        }).then(function (sourceFile) {\n            return new Promise(function (resolve, reject) {\n                sourceFile.copyTo(targetDir, dbName, resolve, reject);\n            }).then(function () {\n                console.log(\"Database copied\");\n            });\n        });\n    }\n\n    readTile(z, x, y, callback) {\n        const query = 'SELECT BASE64(tile_data) AS base64_tile_data FROM tiles WHERE zoom_level=? AND tile_column=? AND tile_row=?';\n        const params = [z, x, y];\n        this.db.then(function(db) {\n            db.transaction(function (txn) {\n                txn.executeSql(query, params, function (tx, res) {\n                    if (res.rows.length) {\n                        const base64Data = res.rows.item(0).base64_tile_data;\n                        const rawData = pako.inflate(base64js.toByteArray(base64Data));\n                        callback(undefined, base64js.fromByteArray(rawData)); // Tile contents read, callback success.\n                    } else {\n                        callback(new Error('tile ' + params.join(',') + ' not found'));\n                    }\n                });\n            }, function (error) {\n                callback(error); // Error executing SQL\n            });\n        }).catch(function(err) {\n            callback(err);\n        });\n    }\n\n    loadTile(tile, callback) {\n        const coord = tile.tileID.canonical;\n        const overscaling = coord.z > this.maxzoom ? Math.pow(2, coord.z - this.maxzoom) : 1;\n\n        const z = Math.min(coord.z, this.maxzoom || coord.z); // Don't try to get data over maxzoom\n        const x = coord.x;\n        const y = Math.pow(2,z)-coord.y-1; // Tiles on database are tms (inverted y axis)\n\n        this.readTile(z, x, y, dispatch.bind(this));\n\n        function dispatch(err, base64Data) {\n            if (err) {\n                return callback(err);\n            }\n            if (base64Data === undefined) {\n              return callback(new Error(\"empty data\"));\n            }\n\n            const params = {\n                request: { url: \"data:application/x-protobuf;base64,\" + base64Data },\n                uid: tile.uid,\n                tileID: tile.tileID,\n                zoom: coord.z,\n                tileSize: this.tileSize * overscaling,\n                type: this.type,\n                source: this.id,\n                pixelRatio: window.devicePixelRatio || 1,\n                overscaling: overscaling,\n                showCollisionBoxes: this.map.showCollisionBoxes\n            };\n\n            if (!tile.workerID || tile.state === 'expired') {\n                tile.workerID = this.dispatcher.send('loadTile', params, done.bind(this));\n            } else if (tile.state === 'loading') {\n                // schedule tile reloading after it has been loaded\n                tile.reloadCallback = callback;\n            } else {\n                this.dispatcher.send('reloadTile', params, done.bind(this), tile.workerID);\n            }\n\n            function done(err, data) {\n                if (tile.aborted)\n                    return;\n\n                if (err) {\n                    return callback(err);\n                }\n\n                if (this.map._refreshExpiredTiles) tile.setExpiryData(data);\n                tile.loadVectorData(data, this.map.painter);\n\n                callback(null);\n\n                if (tile.reloadCallback) {\n                    this.loadTile(tile, tile.reloadCallback);\n                    tile.reloadCallback = null;\n                }\n            }\n        }\n    }\n}\n\nexport default MBTilesSource;\n","// @flow\n\n'use strict';\n\nimport MBTilesSource from './mbtiles_source'\nimport Map from 'mapbox-gl/src/ui/map'\nimport {extend} from 'mapbox-gl/src/util/util'\nimport window from 'mapbox-gl/src/util/window'\n\nconst readJSON = (url) => new Promise((resolve, reject) => {\n    const xhr = new window.XMLHttpRequest();\n    xhr.open('GET', url, true);\n    xhr.setRequestHeader('Accept', 'application/json');\n    xhr.onerror = (e) => reject(e);\n    xhr.onload = () => {\n        const isFile = xhr.responseURL.indexOf('file://') === 0;\n        if (((xhr.status >= 200 && xhr.status < 300) || isFile) && xhr.response) {\n            try {\n                resolve(JSON.parse(xhr.response));\n            } catch (err) {\n                reject(err);\n            }\n        } else {\n            reject(new Error(xhr.statusText, xhr.status));\n        }\n    };\n    xhr.send();\n    return xhr;\n});\n\nconst dereferenceStyle = (options) => {\n    if (typeof options.style === 'string' || options.style instanceof String) {\n        return readJSON(options.style).then((style) => extend({}, options, {style: style}));\n    } else {\n        return Promise.resolve(options);\n    }\n};\n\nconst absoluteSpriteUrl = (options) => {\n    const style = options.style;\n    const hasProtocol = /^.+:\\/\\//;\n    const path = window.location.origin + window.location.pathname.split('/').slice(0, -1).join('/');\n\n    if (('sprite' in style) && !style.sprite.match(hasProtocol) &&\n        ('glyphs' in style) && !style.glyphs.match(hasProtocol)) {\n        style.sprite = path + '/' +  style.sprite; // eslint-disable-line prefer-template\n        style.glyphs = path + '/' +  style.glyphs; // eslint-disable-line prefer-template\n    }\n    return options;\n};\n\nconst createEmptyMap = (options) => new Promise((resolve) => {\n    const emptyMapStyle = extend({}, options.style, {\n        sources: {},\n        layers: []\n    });\n    const emptyMapOptions = extend({}, options, {style: emptyMapStyle});\n    const map = new Map(emptyMapOptions);\n    map.once('load', () => map.addSourceType('mbtiles', MBTilesSource, () => resolve(map)));\n});\n\nconst loadSources = (style) => (map) => {\n    Object.keys(style.sources).map((sourceName) => map.addSource(sourceName, style.sources[sourceName]));\n    return map;\n};\n\nconst loadLayers = (style) => (map) => {\n    style.layers.map((layer) => map.addLayer(layer));\n    return map;\n};\n\nconst OfflineMap = (options) =>\n    dereferenceStyle(options).then(absoluteSpriteUrl).then((newOptions) =>\n        createEmptyMap(newOptions)\n            .then(loadSources(newOptions.style))\n            .then(loadLayers(newOptions.style))\n    );\n\nexport default OfflineMap\n","//\n// Our custom intro provides a specialized \"define()\" function, called by the\n// AMD modules below, that sets up the worker blob URL and then executes the\n// main module, storing its exported value as 'mapboxgl'\n\n// The three \"chunks\" imported here are produced by a first Rollup pass,\n// which outputs them as AMD modules.\n\n// Shared dependencies, i.e.:\n/*\ndefine(['exports'], function (exports) {\n    // Code for all common dependencies\n    // Each module's exports are attached attached to 'exports' (with\n    // names rewritten to avoid collisions, etc.)\n})\n*/\nimport './build/mapboxgl/shared';\n\n// Worker and its unique dependencies, i.e.:\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for worker script and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n});\n*/\n// When this wrapper function is passed to our custom define() above,\n// it gets stringified, together with the shared wrapper (using\n// Function.toString()), and the resulting string of code is made into a\n// Blob URL that gets used by the main module to create the web workers.\nimport './build/mapboxgl/worker';\n\n// Main module and its unique dependencies\n/*\ndefine(['./shared.js'], function (__shared__js) {\n    //  Code for main GL JS module and its unique dependencies.\n    //  Expects the output of 'shared' module to be passed in as an argument,\n    //  since all references to common deps look like, e.g.,\n    //  __shared__js.shapeText().\n    //\n    //  Returns the actual mapboxgl (i.e. src/index.js)\n});\n*/\nimport './build/mapboxgl/index';\n\nexport default mapboxgl;\n"],"names":["val","low","high","Error","realloc","pos","buf","pbf","lsb","writeBigVarintHigh","writeBigVarint","this","str","String","i","length","charCodeAt","c","lead","startPos","makeRoomForExtraLength","writeVarint","writeFloat","buffer","len","fn","obj","writeMessage","Bytes","writePackedVarint","arr","tag","writePackedSVarint","writePackedBoolean","writePackedFloat","writePackedDouble","writePackedFixed32","writePackedSFixed32","writePackedFixed64","writePackedSFixed64","writeTag","Fixed32","writeFixed32","writeFixed64Field","Fixed64","writeFixed64","Pbf","writeSFixed64","writeVarintField","Varint","writeSVarint","writeDouble","Boolean","glyphs","id","advance","bitmap","AlphaImage","width","border","height","left","readVarint","glyph","top","target","parent","mapId","callbacks","callbackID","getMercCoords","Math","PI","x","Actor","targetMapId","callback","const","buffers","postMessage","sourceMapId","type","data","receive","message","error","cancelable","keys","split","deserialize","getWorkerSource","source","params","done","setSouthWest","ne","sw","LngLat","lat","LngLatBounds","sw2","ne2","isArray","every","convert","extend","_sw","lng","min","max","_ne","getSouthWest","getNorth","getEast","toString","input","constructor","isNaN","circumferenceAtLatitude","latitude","mercatorYfromLat","latFromMercatorY","y2","atan","exp","latAccuracy","radius","cos","Number","y","z","lngLatLike","altitude","toLngLat","MercatorCoordinate","quadkey","urls","replace","pow","coord","tilesAtZoom","EXTENT","canonical","OverscaledTileID","wrap","overscaledZ","calculateKey","dim","equals","targetZ","zDifference","sourceMaxZoom","rhs","unwrapTo","getTilePoint","uid","stride","Int32Array","encoding","j","pixels","set","get","value","DEMData","_idx","g","b","_unpackTerrarium","r","dx","yMin","dy","yMax","ox","oy","xMin","xMax","borderTile","register","_stringToNumber","string","_numberToString","DictionaryCoder","encode","decode","Feature","_vectorTileFeature","vectorTileFeature","_z","_x","properties","undefined","_geometry","geometry","toJSON","state","deletedStates","SourceFeatureState","updateState","featureId","newState","feature","stateChanges","sourceLayer","ft","prop","key","changes","reconciledState","featureDeletions","initializeTileState","tiles","layerStates","featuresChanged","FeatureIndex","featureIndexArray","tileID","grid","let","Infinity","maxX","maxY","p","minX","minY","featureIndex","is3D","grid3D","bbox","insert","loadVTLayers","vtLayers","VectorTile","layers","sourceLayerCoder","Object","sort","sourceFeatureState","args","pixelsToTileUnits","filter","queryGeometry","queryPadding","bounds","query","getBounds","cameraBounds","by1","cameraQueryGeometry","previousIndex","index","matching","featureGeometry","result","match","loadGeometry","styleLayer","featureState","pixelPosMatrix","k","loadMatchingFeature","filterLayerIDs","styleLayers","bucketLayerIDs","l","layerIDs","sourceLayerName","indexOf","intersectionTest","layerResult","featureFilter","sourceLayerIndex","duration","timeAdded","fadeEndTime","wasRequested","painter","latestFeatureIndex","rawTileData","latestRawTileData","collisionBoxArray","bucket","stateDependentLayerIds","lId","layer","style","buckets","imageAtlas","destroy","glyphAtlasTexture","unloadDEMData","Texture","ALPHA","Tile","scale","tileSize","_geojsonTileLayer","EvaluationParameters","GeoJSONFeature","segments","context","mask","RasterBoundsArray","vertexExtent","tlVertex","maskCoord","brVertex","offset","indexArray","emplaceBack","vertexLength","primitiveLength","maskedBoundsBuffer","createVertexBuffer","hasData","setExpiryData","expirationTime","cacheControl","$2","$3","toLowerCase","header","expires","Date","getTime","delta","expiredRequestCount","sourceLayerStates","states","queryRadius","now","clearFadeHold","setHoldDuration","browser","horizontal","TaggedString","text","sectionIndex","fromFeature","section","push","sections","nextCharCode","output","verticalizePunctuation","whitespace","trailingWhitespace","beginningWhitespace","substring","start","getMaxScale","lineWidth","targetWidth","abs","nextCodePoint","penalty","codePoint","breakX","calculateBadness","potentialBreak","breakBadness","bestBreakBadness","determineLineBreaks","logicalInput","maxWidth","getSection","stringify","JSON","Array","getKey","refProperties","StyleLayerIndex","layerConfigs","checkMaxAngle","line","anchor","labelLength","windowSize","maxAngle","segment","anchorDistance","dist","recentCorners","recentAngleDelta","prev","current","next","angleDelta","angleTo","distance","shift","getLineLength","lineLength","getAngleWindowSize","shapedText","glyphSize","boxScale","getShapedLabelLength","shapedIcon","right","getCenterAnchor","angleWindowSize","prevDistance","centerDistance","a","segmentDistance","t","interpolate","Anchor","_round","getAnchors","spacing","overscaling","tileExtent","shapedLabelLength","isLineContinued","resample","placeAtMiddle","halfLabelLength","markedDistance","anchors","segmentDist","angle","_layerConfigs","_layers","update","removedIds","layerConfig","createStyleLayer","_featureFilter","familiesBySource","groups","group","groupByLayout","values","map","visibility","sourceId","sourceGroup","sourceLayerId","sourceLayerFamilies","CollisionFeature","bucketIndex","shaped","padding","alignLine","rotate","y1","bottom","x1","x2","boxStartIndex","_addLineCollisionCircles","tl","Point","tr","bl","br","rotateRadians","_rotate","boxEndIndex","boxSize","step","nBoxes","floor","overscalingPaddingFactor","log","LN2","nPitchPaddingBoxes","firstBoxOffset","labelStartDistance","paddingStartDistance","segmentLength","boxOffset","boxDistanceToAnchor","segmentBoxDistance","p0","boxAnchorPoint","sub","_unit","_mult","_add","paddedAnchorDistance","TinyQueue","compare","defaultCompare","_down","polygon","area","points","f","Cell","compareMax","h","d","inside","minDistSq","ring","distToSegmentSquared","sqrt","pointToPolygonDist","SQRT2","item","_up","pop","peek","halfLength","best","module","seed","remainder","bytes","h1","h1b","c1","c2","k1","murmur3","murmur2","performSymbolLayout","glyphMap","glyphPositions","imageMap","imagePositions","showCollisionBoxes","createArrays","tilePixelRatio","compareText","iconsNeedLinear","layout","unevaluatedLayoutValues","_unevaluatedLayout","_values","sizes","textSizeData","functionType","zoomRange","compositeTextSizes","possiblyEvaluate","iconSizeData","compositeIconSizes","layoutTextSize","zoom","layoutIconSize","textMaxSize","lineHeight","textAlongLine","keepUpright","features","fontstack","evaluate","join","glyphPositionMap","shapedTextOrientations","unformattedText","textOffset","spacingIfAllowed","allowsLetterSpacing","textAnchor","textJustify","shapeText","WritingMode","allowsVerticalWritingMode","vertical","icon","image","shapeIcon","sdfIcons","sdf","warnOnce","pixelRatio","constantOr","addFeature","generateCollisionDebugBuffers","iconOffset","fontScale","textBoxScale","textMaxBoxScale","iconBoxScale","symbolMinDistance","textPadding","iconPadding","textMaxAngle","iconAlongLine","symbolPlacement","textRepeatDistance","addSymbolAtAnchor","textCollisionFeature","iconCollisionFeature","lineArray","addToLineVertexArray","numIconVertices","numGlyphVertices","numVerticalGlyphVertices","placedTextSymbolIndices","textRotate","addTextVertices","horizontalOnly","textBoxStartIndex","textBoxEndIndex","iconQuads","alongLine","iconWidth","iconHeight","size","textLeft","textRight","textTop","textWidth","textHeight","padT","padR","padB","padL","offsetY","offsetX","sin","matrix","_matMult","tex","paddedRect","writingMode","glyphOffset","getIconQuads","iconRotate","sizeData","SIZE_PACK_FACTOR","MAX_PACKED_SIZE","layerIds","addSymbols","lineStartIndex","iconBoxStartIndex","iconBoxEndIndex","glyphOffsetArray","SymbolBucket","MAX_GLYPHS","symbolInstances","addSymbol","lines","clippedLines","clippedLine","p1","clipLine","anchorIsTooClose","classifyRings","poi","findPoleOfInaccessibility","point","glyphQuads","shaping","positions","positionedGlyphs","quads","positionedGlyph","fontStack","rect","rectBuffer","GLYPH_PBF_BORDER","halfAdvance","metrics","builtInOffset","w","center","verticalRotation","xOffsetCorrection","_rotateAround","getGlyphQuads","placedSymbolArray","repeatDistance","otherAnchors","GlyphAtlas","stacks","bins","stack","stackPositions","src","bin","potpack","copy","WorkerTile","overscaleFactor","collectResourceTiming","returnDependencies","recalculateLayers","parameters","recalculate","parse","layerIndex","actor","status","CollisionBoxArray","iconMap","patternMap","options","layerFamilies","version","family","minzoom","maxzoom","createBucket","sourceID","populate","mapObject","glyphDependencies","send","err","maybePrepare","call","icons","iconDependencies","patterns","patternDependencies","glyphAtlas","ImageAtlas","iconPositions","hasPattern","LineBucket","FillBucket","FillExtrusionBucket","addFeatures","patternPositions","isEmpty","glyphAtlasImage","performanceExists","performance","wrapper","url","getEntriesByName","name","mark","startMark","endMark","measure","clearMarks","clearMeasures","Performance","request","_marks","end","loadVectorTile","getArrayBuffer","vectorTile","vt","Protobuf","rawData","cancel","finish","resourceTimingData","VectorTileWorkerSource","loadVectorData","loading","loaded","loadTile","perf","workerTile","abort","response","resourceTiming","slice","reloadTile","vtSource","reloadCallback","abortTile","removeTile","RasterDEMTileWorkerSource","rawImageData","dem","polygonArea","coords","ringArea","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","wgs84","RADIUS","_","coordinates","geometries","rewind","gj","outer","curryOuter","correctRings","correct","wind","dir","geojsonArea","cw","reverse","toGeoJSON","mvt","VectorTileFeature","prototype","FeatureWrapper","_feature","extent","tags","parseInt","newRing","GeoJSONWrapper","_features","require","rawGeometry","rings","fromVectorTileJs","tile","out","writeLayer","writeTile","writeStringField","keycache","valuecache","writeFeature","R","S","T","Z","]","`","e","m","s","u","}","draw","renderPass","disabled","colorModeForRenderPass","drawLayerSymbols","paint","colorMode","sourceCache","drawCollisionDebugGeometry","opacity","strokeWidth","strokeOpacity","gl","depthMode","ReadOnly","stencilMode","StencilMode","programConfigurations","indexBuffer","programConfiguration","DepthMode","ONE","Color","activeTexture","TEXTURE1","fbo","Inflate","utils","chunkSize","windowBits","opt","ended","ZStream","strm","avail_out","zlib_inflate","Z_OK","GZheader","inflateGetHeader","inflator","msg","mode","_mode","utf8str","dict","dictionary","Z_NO_FLUSH","Buf8","Uint8Array","allowBufError","Z_STREAM_END","avail_in","Z_FINISH","next_out","tail","next_out_utf8","strings","arraySet","onData","shrinkBuf","inflateEnd","onEnd","Z_SYNC_FLUSH","chunk","inflate","getLens","b64","lens","validLen","tmp","placeHoldersLen","_byteLength","curByte","revLookup","uint8","extraBytes","parts","encodeChunk","len2","lookup","code","num","eventedParent","openDatabase","path","dbName","self","reject","platform","file","getDirectory","cordova","documentsDirectory","Promise","resolve","targetDir","catch","copyDatabaseFile","dbLocation","then","console","copyTo","db","transaction","executeSql","res","rows","toByteArray","base64js","window","devicePixelRatio","workerID","_refreshExpiredTiles","VectorTileSource","dereferenceStyle","xhr","XMLHttpRequest","open","setRequestHeader","onerror","responseURL","statusText","hasProtocol","emptyMapOptions","emptyMapStyle","addSourceType","MBTilesSource","sources","sourceName"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;8BA8PeA,8BAoKSA,SAChBC,EAAKC,QAGLD,IAAc,WAAe,EAC7BC,eAA6B,WAGb,+BADA,aAIZD,EAAOA,SAED,EACNC,IAAe,SAInBF,GAAO,qBAAuBA,GAAO,oBACrC,MAAM,IAAIG,kDAGVC,qCAOQC,YAASJ,eACjBK,IAAIC,EAAIF,OAAe,IAANJ,EAAa,WAClCM,yBAAwCN,QACxCM,MAAQA,EAAIF,OAAe,MAAO,WAClCE,EAAID,WAAuB,uBAGHJ,YACN,SAE8C,SAAxDK,EAAIF,QAAUG,IAAgBN,YAAsB,sBACpDK,aAAcL,SAA0B,GAAK,IAAO,IAASA,SACL,KAA5DI,MAAQD,OAAiB,IAAPH,YAA+B,IAAO,aACI,GAAhEK,EAAID,MAAQD,OAAiB,gBAAwB,4BACzCA,OAAiB,IAAPH,IAAgBA,QAAe,QAAgBA,EAAM,QAC3EK,EAAID,MAAQD,WAAUH,EAnBtBO,GAAyBF,GA1LjBG,CAAeV,EAAKW,gCAMfA,YAA8B,IAANX,KAAqB,IAAO,IAAO,GAAQA,SAC5EW,KAAKL,IAAIK,KAAKN,OAAyB,eAASL,EAAM,yBACjDM,IAAIK,YAA8B,cAASX,gBAAmC,MACnFW,SAASA,YAAiBX,IAAQ,kCAGfA,oBACFA,EAAM,KAAKA,MAAcA,uDAIjBA,iBAGhB,SAASY,GAClBA,EAAMC,QAAOD,SACRR,8CAMLO,oBAkSgBC,EAAKP,QACpB,YAAoBS,IAAQC,oBACrBC,eAEA,QAAUC,EAAI,aAYX,CACCA,SAAeH,EAAI,IAAMF,EAAIG,SAC7BT,EAAID,UACJC,OAAa,IACbA,EAAID,UAEJa,EAAOD,EAEX,YAlBIA,QAAY,CACZX,EAAID,WACAA,SACJC,EAAID,SACJa,aAGAD,WAAqB,KAAS,YAC9BC,YAYDA,MACHb,SACJC,EAAID,gBACS,YAIbY,QACIZ,KAASY,GAETA,cACaA,GAAK,OAEdA,UACIZ,QAAc,GAAM,YAEXY,UACbX,EAAID,QAAc,aAElBA,aAA2B,eAEtBY,4CAhVPN,SAAWQ,UAEJC,aAGjBT,SAAWQ,SACNE,eACLV,aAGJW,oCACiB,6BACgC,GAAI,aACrC,eAGH,YACTX,KAAKP,mBACcE,IAAKN,OAAUK,UAAe,GACjDM,iCAGiBY,uBAEZF,YAAYG,QACZpB,yBACeoB,oBAAwBnB,OAASkB,+BAG/BE,UACjBpB,uBAIFqB,cACOf,SAAWQ,KAEV,QAA6BA,EAAUK,EAAKb,MAGvDA,WAAsB,EACtBA,iBAAiBa,QACZnB,KAAOmB,GAGhBG,0BAAgCD,sBACLE,8BACEF,IAG7BG,6BAAmCC,GAAWA,EAAIf,4BAA+Bc,0BAC5D,SAASE,mCAAmDC,GAAoBF,qCACvDA,4BAA8BC,EAAKE,GAAoBH,8BACvEC,OAAoBhB,0BAA0BgB,EAAKG,OACjFC,gCAA8CL,EAAIf,QAAQJ,oBAAuBwB,GAAmBL,IACpGM,mBAAqB,cAAyBN,EAAIf,QAAQJ,2BAC1D0B,6BAA8BN,EAAKD,KAAef,+BAAoDe,IACtGQ,mBAAqB,gBAA6BvB,0BAA0BgB,EAAKO,OACjFC,6BAA8BR,EAAKD,GAAWA,UAAYnB,KAAKgB,eAAkBY,uBAEhE,cACb5B,KAAK6B,2DAGU,SAAST,KACxBpB,mBAAuB8B,SACvB9B,KAAK+B,aAAa1C,uBAEF,mBACXwC,SAAST,KAASU,gCAG3BE,kBAAmB,WAAc3C,GAC7BW,mBAAuBiC,SACvBjC,KAAKkC,oCAEW,4BACFd,EAAKe,iBACdC,cAAc/C,IAEvBgD,iBAAkB,SAASjB,EAAK/B,GAC5BW,KAAK6B,WAAcM,GAAIG,aAClB5B,2CAEmBU,mBACVA,KAASkB,aAClBC,aAAalD,qBAEJ,SAAS+B,mBACTA,iDAGD,SAASA,EAAK/B,QACtBwC,SAAST,KAASU,cAClBnB,gCAES,mBACTkB,WAAcM,GAAIF,SACvBjC,KAAKwC,kCAEU,WAAcnD,yBACP+B,EAAKqB,QAAQpD,aC9X5B,EAIf,YAAwB+B,EAAasB,EAA2B9C,GAChD,IAARwB,oBAC+BsB,GAIvC,gBAA+D9C,GAC3D,GAAY,KAARwB,SACwDxB,qBAAjD+C,wDAAsCC,uBAEzCD,EACAE,WAAYC,GAAW,CACnBC,MAAOA,IAAYC,GACnBC,SAAiB,wBAEXF,gBAAeG,iGAQhB,cAAiBtD,EAAIuD,qBACZF,OAASrD,mBAC1BwB,GAAWgC,GAAMF,0BACjB9B,IAAiBiC,oBACT,QAAGD,EAAMR,UAAcO,qBAOZH,eChBhBM,EAAaC,KACrBvD,YAAcsD,EACdtD,KAAKuD,OAASA,EACdvD,WAAawD,EACbxD,KAAKyD,aACLzD,KAAK0D,gBACI,WAAY1D,MACrBA,KAAKsD,wBAAwB,4BCqCrC,SAASK,kBACiBC,KAAKC,GAAK,YAAiBD,cAIjD,MAAO,CAHOE,cAAgC,gBACXF,gBAAqB,GDvDhDG,mCA0B6CC,cAC3CrB,EAAKsB,EAAcjE,eAAcA,KAAK0D,aAAiB,cAC1CD,gBACnBS,IAAMC,EAA+B,MACrCnE,YAAYoE,YAAY,aACpBJ,EACAK,YAAarE,KAAKwD,WAClBc,YACW3B,WACK4B,MACjBJ,GACCF,QACO,0BACWjE,EAAKsD,gCACfU,iBACkBR,WACZ,qBACKb,qBAM3B6B,iBAAQC,yBAEA9B,EAAK4B,SAGLA,sEAIOvE,EAAKyD,qEAIF,uBACKd,8BAEK4B,+DAKJd,YAAed,WACxB3C,2BACc0E,WACIH,UACdN,KACE,8BAEa,MAAPtB,SAA2BY,eAAmB,+BAI3DoB,gBAA8BL,MAAMC,sCACxBvE,eAAeuE,EAAK5B,uBAGdA,YAErB,QAAuB,MAAPA,SAA2BY,uBAAwB,KAEhEqB,EAAOL,OAAUM,aACPC,WACM9E,YAAkB+E,qCAAkDC,QAC7EJ,EAAK,IAAIK,EAAQC,oBAElBX,0DAKXjB,qCAAsCtD,kDEtFlCmF,6BAA8BC,OAC5BC,uEAGFF,8FAWEC,2FAUFC,gCACgBC,GAAS,IAAIA,WAAkBC,yBAnC7CC,8BA6CRzE,GACHmD,IAEIuB,EAAKC,EAFHL,WACFD,EAAKpF,SAGT,gBAAmBsF,eAIZ,CAAA,kBAAmBE,IAOtB,aAAUG,aACEC,iCACeJ,GAAaK,iBAEpBC,OAAOR,WAAevE,KAGnCf,QAbPyF,EAAM1E,EAAIgF,aAGLN,IAAQC,EAAK,QAAO1F,YAaxBqF,GAAOD,KAKLY,SAAWC,mBACXV,SAAWU,YAAgBV,KAC9BH,EAAGY,SAAWE,KAAIR,EAAIM,sBACRE,IAAIR,OAASN,EAAGG,yKAewCY,SAAW,IA9F1EX,aAsGfY,wBAAyB,YAAYL,iDAOL/F,KAAKmG,0CAOZ,OAAO,OAAWnG,oBAAqBqG,gEAOrBrG,KAAKsG,UAAWtG,wGActC,4DAOMA,SAASgG,KAhJrBR,4FAmKJ,CAACxF,mBAAoBA,KAAKmG,gFAaDI,gBAAevG,yBAhLpCwF,6DAAAA,uBA2MX,WAAcgB,yBACUA,WCxM5BC,WAAyBlB,MACjBmB,MAAMV,IAAQU,MAAMnB,qDAC+BA,UAEvDvF,UAAYgG,OACPT,gBACU,gGCzBvB,SAASoB,GAAwBC,iBACE/C,GAAK,QACbD,mBAA8B,iBAGxBoC,GAC7B,kBAGG,SAASa,iBACG,YAAgBjD,SAASA,iBAAmB,EAAI2B,EAAM3B,QAAU,yBAG3B2B,YAClCoB,GAAwBpB,YAO9BuB,MACZ5C,IAAM6C,EAAK,qBACEnD,KAAKC,QAAUmD,UAAUC,IAAIF,UAAe,UDRhDzB,wCAyBMA,KAAYtF,KAAKgG,SAAW,KAAMhG,iDAYtC,eAAgBuF,mBAW3BgB,kHAa2B,OAEjBW,MAAoBC,EADkB,aAEZvD,KAAKwD,qBAA2B7B,0BAE7BvF,WAAwBA,8BACpBA,cAnElCsF,GAmFFO,oBACH,0BACWW,4BAEkBA,EAAMpG,cAAsBA,eAC9C,gBAAwB,kBAEnC,0DACW,IAAIkF,UAEA,uBACP+B,qBAGF,IAAI7H,MAAM,0KC5DxB,OAKIiH,4CAEIzG,KAAKsH,KACLtH,KAAKuH,6BAaSC,oBAA2C,oDAKzBjC,QACFkC,wBAWlCC,mDAGYZ,GAAiB9G,UAzCR2H,0CA1BaJ,SAAWD,WAClCX,GAAwBG,GAAiBQ,IADjD,MAA0CA,uBClBXA,GAI9BtH,cACK8D,EAAIA,OACJwD,IACLtH,gBAA8B8D,EAAGwD,iCAG9B3E,UACI3C,SAAW2C,UAAamB,gEJ6B/BmC,OAJanC,gBIpByBwD,EJoBnBC,EIpBsBvH,KAAKuH,EJwB9CtB,EAAMtC,OAAcG,EAAa,uCACZA,KAAwB,KAATwD,UAE7B,GAAK,sBAAoCpB,MI1B1C0B,WAyIML,EAAGzD,eACf8D,KACKzH,EAAIoH,EAAGpH,EAAI,EAAGA,aACZ,GAAMA,EAAI,eACgC,IAErD,gBA/IoCoH,cAAgBD,UAEzCO,kBAAyBA,EAAKzH,2DACuBkH,oBACvDQ,cAAe5H,aAAYqH,IAC3BO,cAAe5H,YAAY4D,kBACZ5D,oCAAiDF,cAAmBsH,2BAEnFQ,qEAIL5D,WAAyB6D,IAAI,EAAG/H,wBAErB8D,IAAkB9D,YACxBgI,IAAUC,OAAmBX,IAAKY,YAS3CzB,0BAEIzG,KAAKmI,UAAYA,oBAC0BA,EAAUrE,IAAawD,IAI7Dc,cAOwBC,MAAoCf,oBAE9CgB,EACnBtI,KAAKqI,sBACY,OAAoBd,GAAIzD,GAAIwD,iBACfgB,iBAsF7BC,GAAaF,IAAyBvE,gBAE7BuE,OAAmB,GACjCnE,MAAY,YAC+B,IAAlCsE,UAA6B1E,GAAWyD,EAtGvBa,aAe1BK,kBAAO9F,+BAC4B2F,iCAAwCtI,gBAAeyI,SAAUN,yDAKvEA,YAAcO,+CAEa1I,eAAeuH,mBAAqBvH,eAAesH,iBAEzDe,OAAerI,kBAAoB2I,wBAzB3DP,gDA8BFpI,KAAKqI,mCAIUd,cAAqBA,aAEjDhE,eACHA,kCACW4E,6BAAgCrE,GAAK6E,eAC3BrB,IAAOtH,KAAKmI,gBAvCfC,kCA2CtB,qBAAwBQ,EAEpB,MAAO,CAAC,OAAqB5I,KAAKsI,YAAc,EAAGtI,gCAAkCmI,UAAUrE,gCAGpFqE,YAAc,EACvBrE,EAAuB,EAAnB9D,iBACJsH,mBAAmBA,EACzB,MAAO,CACH,IAAIc,KAAoBpI,UAAWuH,IAAMD,WACpBC,OAAQc,OAASvE,EAAI,YACrByD,gBAAoBD,EAAI,iBAChBe,sDAKjC,YAASA,oBACAA,OAAOQ,EAAIR,QAEhBrI,uCACKsI,6BAELtI,KAAKmI,wBAA4BrE,wBACVqE,mBAElBA,wEAKEC,2BAA2CD,2BAA4BrE,OAAQqE,UAAUb,iBAGxGwB,+JAKgBf,MAAO/H,KAAKsI,iBAAmBH,UAAUZ,gDAI9C,YAAyBc,uDAIhC,4BAA8BrI,qBAAoBA,kBA1F5BoI,6CA8FfpI,KAAKmI,UAAUY,oBAAoCf,EAAMlE,EAAI9D,qBAqBnE,qFC7JOgJ,OAER,GADAhJ,aACSiD,qNAIcsB,cAClB0E,gBAAoB,OACpB1E,SAAW2E,WAAWlJ,yBAI3B,UAFeuE,SACa,cAAb4E,EAA2BnJ,6DAE7B8D,QAAgBA,SAEfsF,KADI9B,gBAEDxD,EAAGwD,cAAgC,GAAI+B,EAAOD,OAO/D,QAAStF,IAAOA,0CAIPwF,MAASxF,WAAY0E,EAAM,EAAG1E,aAE1BA,UAAYyF,IAAIzF,WAEpBwF,IAAIxF,SAAayF,QAAa,IAGvCvJ,eAAiBA,WAAY,iBACd,EAAGA,2BACR,aAAiB,aACtBsJ,QAActJ,aAAkBwI,EAAM,kCAGhClB,EAAWkC,aACZxJ,YAAasH,cA/CFmC,4BAkDVnC,UACJtH,KAAKuE,KAAKvE,UAAU8D,aAnDN2F,aAsDzBC,yBACa,MAAU1J,eAAsB,GAAKsH,QAAUkB,YAAe,sEAC/DlB,KAAStH,mBAxDIyJ,sCA2DAE,EAAWC,UAGnB,mBAA6B,GAAO,mBAGrDC,4CAGaC,iEAIY,CAAC/G,0EAxED0G,+CA4EjBzJ,KAAKwI,QAAmBA,UAAW,4CAEvBxI,WACL+J,GAAK/J,SAAWA,SACvBgK,EAAOC,EAAKjK,KAAKwI,IACjB0B,kBAA4B1B,mBAG1B,mBAGD,wBAMC,EACFwB,EAAOE,qBAGO,EAMlB,SAFMC,KAAWnK,SACXoK,kBACa9C,QACf,UAAa+C,EAAMvG,EAAIwG,EAAMxG,eACbwD,EAAGiD,EAAWhB,QAAYjC,EAAI8C,KAM1DI,wHC3HA,OAII/D,oCAEIzG,qBAAuB,WACdG,oCAEAsK,iBAAgBC,UAChBC,mBAAqBD,IAVhBE,aAclBC,gBAAOH,gDAKPI,mBAEI,oCCtBFC,cAQgDxD,EAAWzD,UACpDQ,KAAO,WAEZtE,KAAKgL,mBAAqBC,IACDC,GAAK3D,EAC7B0D,EAAwBE,GAAKrH,SAG9B9D,kBAAoCoL,gCAGtBH,EAAkBtI,iEAWhC,YANuB0I,SAAdC,2IAI8BJ,IAAIK,UAEpCvL,KAAKsL,uCAIZtL,kBAlCM+K,aAqCVS,uCAEuBD,mKClBdE,2BACe,GACpBzL,KAAK0L,cAAgB,IARJC,aAWrBC,wBAAiCC,EAAmBC,OAC1CC,SAAiBF,WAClBG,aAAaC,GAAejM,KAAKgM,aAAaC,IAAgB,sBACjDA,GAAaF,qBAA6BE,OAAyB,KAC9EjM,KAAKgM,iBAA0BD,GAAUD,UAE5C9L,KAAK0L,cAAcO,mCACAA,GAAe,kBAE1BC,aAAqBR,qDAGoBO,gBAAqBP,sCAE7DA,cAAcO,uBACwBF,KACzBI,UAAYT,iBAA2BK,iBAGzD,aAAkBD,+BACkDJ,iBAA2BK,IAA8D,6BAAlBA,mBACtGL,cAAcO,GAAaF,wDAQxE,KAD+D,mCAGzDA,EAAU7L,UAIhB,8BAFuCwL,qBAEnCU,iBACSV,2BACAA,oBAAsC1L,KAAK0L,oDACA,WAEjD,GAAIG,EAAW,SACSG,iBAA6BhM,KAAKgM,cAAaC,GAAaF,yFAGWK,GAAO,6BAGlFH,MAAwB,gCAGb,QA7DrBN,wCAmEXI,EAAU7L,OAAO2L,KACV7L,kBACPqM,wBAA4C,GAE5CC,IAAyB,6BAGtBZ,wBAA4C,yBACzBO,eACMP,8BAC1Ba,QAAkC,qCAGnCD,gBAGXE,yGAIgBC,6CAIiC,MACpChB,2BACLvH,wCACwC+H,QAC1BR,mBAAkCA,MAAMQ,MAAwB,oBAC3CF,qBAA4BE,OAC3DS,gBAAkCT,GAAaF,KAEnCE,2CAIXR,MAAMQ,QAAqBR,MAAMQ,+BAG7BP,cAAcO,oCACyC,iBAClC,wCAEeA,OACwC,qCAC3CR,mDAEKC,0CAAxBU,mBACKX,MAAMQ,iCAOlBA,GAAeU,EAAgBV,IAAgB,UAC1BS,6FASlB/J,8BC9GzBiK,gBAiBUC,GACR7M,KAAK8M,OAASA,OACThJ,EAAIgJ,YAAiBhJ,SACjBgJ,uBACO3E,sBACJ4E,UAAiB7E,4BACNA,MAAY,oDAyMvC,IAJA8E,QAAWC,MACAA,EACPC,GAAQD,IACRE,GAAQF,4BACc,KAAfG,SACAxJ,SAASyJ,EAAMD,uBAEtBF,WAAgBA,EAAME,YACVlH,MAAUkH,wBAEXE,iBAGnB,cAAqC1D,GACjC,0CA/MmC2B,iBACnBvL,KAAK6M,yBACjB7M,mCAAmCuN,OAInC,UAFaC,EAAOxN,KAAKyN,yBAEIrN,WAAa,aAChB0J,QAERmD,EAAUA,EAAAA,QAAsBA,KACrC9M,+BAELuN,KAAU9J,SAAS8J,YACd,iBAAuBN,OACvB,YAAcM,OAAW5J,KACzB,GAAKF,KAAKsC,IAAIwH,OAAWpG,QAGpBY,aAEVwF,eACW,KACNC,SAAYD,EAAK,kCAKlCE,oCACcC,yBACU,OAAOC,kBAAwB9N,mBAAmB+N,YAC7DC,wBAAuChO,cAAgBiO,YAAYjO,eAAekO,QAAU,uBAE9FlO,+CAIuDmO,0CAGxDlJ,EAASmJ,aACXC,KAA6BD,mBAC7BE,KAAuBrJ,cAEAsJ,cACrBC,mBAEAC,UACWzO,KAAK+M,KAAK2B,MAAMD,gBAA0CD,kBAAwDA,KAE9GG,4CACUD,QACVrB,OAAqBuB,SAAkCA,OAAoBJ,IAA2BrB,kBAC7G0B,iBAC0BT,EAAKU,sBAA2BN,IAAoBA,QAAwCA,0BAGzHpC,cACOA,cAOlB,QADI2C,yBAEMC,EAAQC,iDAM2BD,GACrCE,6BAEAC,EACAC,+EAQQF,EAAkBG,uBAGlBtD,EAAQpJ,iCAE6D,oBAAqBoJ,EAAQpJ,KAE/F2M,6BAA0DC,QAAuCnB,cAAmCA,EAAKoB,sBA1B/I,EAAGC,8BA3FL7C,aA6Hf8C,uCAMIC,EACAC,gBAGsBC,sBAClBF,cCsIoC/F,WACnCkG,EAAI,MAAS1P,+BACK,EAAG,OAAO,cDxIsB2P,QAGjDC,EAAkBhQ,KAAKgO,iBAAiBlD,iBACrB+C,YACG9B,cAEvBuC,SAAgCtO,4BAGrC,UAAa,IAAO+P,aAAsB,OACtBA,eAEqBE,mBAI/BX,UACDA,UAEkBY,GAAoBA,0BAMDnE,qBAA8BzE,yCAGpD+D,IAAhB8E,WACgC,gHAYvBR,SAEXR,KACNnP,8BAEeoQ,uEAMPC,uDAYR,mBAA4BR,qGAWhC,yBAES,cAAe,6BExJxBpJ,cACIzG,YAAc8M,2BAGd9M,gBACAA,aAAe,4BAEfA,KAAKwO,aAAe,EACpBxO,8HAYoBsQ,OAAgBC,UAChCC,oCACuCA,cAE3CxQ,kCAGJyQ,wBACI,kBAAOzQ,YAA2C,gBAAVyL,qBAAsBzL,mDAa3B0Q,QAC/B1Q,gBACAA,mCAGS,yBAQTuE,EAAKgJ,oBACAoD,8GAKuBC,yDAInBD,mBAAmBC,iBAAmBC,oBAGnD7Q,KAAK8Q,iEC9ET5M,eAIY,mEAIEvB,qBAAsBA,YACpBF,SAEZ,OAAIsL,UAMHgD,+DAEsDC,oCAA4BC,4BAAuBnB,qBAAoB,oDAGnHoB,iBAhBM1K,gCDyEgBjC,YAAsB4M,qCAGjCC,4BACUzO,iDAEA,iFAWtBoO,iEACkDI,eAAexO,mBAGvE4B,EAAK8M,aACLrR,8MAca2C,aAEjB3C,wCAGIA,uBAAuBsR,eAGlBD,mCAILrR,6BACKuR,kBAAkBD,kCAGD,yCAI9BE,kCACe,2BACa,oJASO,sDAO/BtN,gBACSmN,wCACLrR,uBAAyB,IAAIyR,KAAiBzR,kFAK9CA,uDAAuE0R,mCArMxEC,kDA+Me7C,yBAMR6B,gFAGqBjC,qBAC3BH,8BAEAqD,EACAC,iGAKO1D,GAXA,sDAeNnO,yBAA4BA,KAAK2Q,2CAEhBA,yDAGR9C,EAASiE,0CAIM7M,2BACCkD,sBAAjBb,gDAIO4J,sBACDa,eAAiCzJ,aAAcyD,GAAU,WACzCiG,OAA2BlO,YACzBkE,gBAtPlC2J,uDA8PMM,0BACEjS,iEAGiBsR,iBACjBtR,yEAGgBsR,0EAKXY,cAGGC,UAEnBnS,gCAKcmS,sBAEgBC,KACX,qBAEH,4EAMchS,sBACOD,IAC3BkS,UACAC,EAAW,YAAsCC,EAAUjL,EAAI+K,WAC1CC,QAAoChL,EAAI+K,6DAKhB/K,MAAegL,yBACfhL,EAAGkL,EAAS1O,EAAGwO,uBACxBE,EAASlL,yBACrBkL,EAAS1O,YAAoCwD,OAErEmL,0CAINC,EAAWC,cAAqB,MAAeF,OAEvCG,cAAgB,IAChBC,iBAAmB,OAG1BC,qBAA6BC,iFAxT/BpB,aA4TPqB,yBAC0B,gBAAVvH,OAAqC,2CAAoBA,wEAIzCwC,OAAOrJ,4DAGvCqO,qCACuBC,eAEnB,yBDsCD,YAEHhP,SASA,GANAiP,kLAAkCC,cACVC,oBACOC,gCAIR,CACnBpP,eAAwBqP,8CAEnBA,EAAO,qFClD0E,yBACtEC,eACPN,mBAAqBO,gBAAmBC,cAG7C1T,oBAAqB,OACTyT,gBAGZ,QAASP,oBACO,mDASNS,EAAQ3T,wBAWVA,sBAA4B4D,WA1Yf,kBAwXL,gCAyBZ5D,+FAQJA,gCACS4T,iCACoB3N,+BAAkC,mBAGtCiN,mDAAyD,4CAK9CxC,oEAGL,WAAxB9L,sBAIM5E,8IAOP6T,EAAoBC,KACrB7H,MAA+E,WAAnCrH,0BAEnCiP,0BAAwDxC,oCACvDX,eACNlC,0CAAmD2C,kBAAmB4C,YAAYhD,SAnZ5FY,mDAyZiCtG,8BAzZjCsG,4EA6ZiC3R,2BAAmCgU,OA7ZpErC,aAgaPsC,uDAC+B5I,gBAG/B6I,yBAAgB5D,4BACe6D,WE1dnC,OCYoB,CAChBC,WAAY,+BA8BVC,mBAMOC,KAAO,QACPC,qCAIFC,kCACGrF,qCACyC,qCAEtB,gBACO,+BAGrBmF,MAAQG,iBACF,EAAGrL,gBAAyBA,mBACjBsL,eAGrBvF,yCAIAnP,kBA5BIqU,gDAgCCM,cAAcJ,kBAhCfF,iEAoCiBrF,IApCjBqF,oDAwCNC,qBCSTtH,MAAa,WAEa5M,OAAQD,IAAK,SACRE,aAAe,mCAIpCuU,yCACuG,eAMzGC,cAFmCrO,EAAMrG,WAM1C0U,ED3BSC,MAA4BR,oCAKxC,gBACInU,EAAIH,KAAKsU,aAAeS,oCAK5B,QADIC,OAA0BV,wBACPlU,YACd,iBAAiDkU,4BAI1DtU,gCAAqDgV,qBACjChV,wBAAwBiV,MAzDjCZ,aA4Dfa,wBACIhR,2BACiBlE,2BACPuU,kBAAoBA,mBAAmBY,yEAM1CnV,wBAGXoV,gGAC6DlP,gBAA0B0L,QAAQ,WAgG3D,gBAG5B,YAEA,YAI2B,GAuCvC,YAA0ByD,SAItBnR,iBAAwCoR,gBAGpBA,iBAOKC,uBAGgBC,GACzCxI,wBAGIyI,aAGAC,WAAsBA,gBAKtBF,sBAGGC,gBAWYE,4BAWIC,OAAsCH,kCAElDI,SAGHD,SAA4BN,iBAC5BQ,WAEAC,EAAmBD,8CAmB/B,SAASE,GAAoBC,IAEAC,KAEzB,kCAMAhS,WACMoR,EA/GV,kBAMI,UAFiB,EAERtG,IAAWA,wBACAiH,EAAaE,kBACF1B;;gDEvPnC,SAAS2B,EAAUrV,GACfmD,IAAMI,SAAcvD,EACpB,GAAa,WAATuD,GAA8B,YAATA,GAA+B,WAATA,GAA3CA,MAAgEvD,EAChE,OAAOsV,KAAKD,UAAUrV,GAE1B,GAAIuV,MAAM3Q,QAAQ5E,GAAM,CAEpB,IADAiM,IAAI/M,EAAM,UACQc,kBAAK,CACnBd,GAAUmW,aAEd,OAAUnW,MAMd,IAHAiE,IAAMU,EAAOqJ,OAAOrJ,KAAK7D,GAAKmN,OAE1BjO,EAAM,IACDE,EAAI,EAAGA,EAAIyE,EAAKxE,OAAQD,IAC7BF,GAAUoW,KAAKD,UAAUxR,EAAKzE,QAAOiW,EAAUrV,EAAI6D,EAAKzE,SAE5D,OAAUF,MAGd,SAASsW,EAAOrF,GAEZ,IADAlE,IAAIZ,EAAM,SACMoK,gCAAe,CAC3BpK,GAAO,IAAIgK,EAAUlF,UAEzB,OAAO9E,ECfX,IAAMqK,EAMFhQ,SAAYiQ,GACJA,GACA1W,KAAK8H,QAAQ4O,KCHzB,SAASC,EAAcC,EAAoBC,EAAgBC,EAAqBC,EAAoBC,GAGhG,QAAuB3L,IAAnBwL,EAAOI,QAAuB,QAAO,EAOzC,IALAjK,IAAII,EAAIyJ,EACJ7H,EAAQ6H,EAAOI,QAAU,EACzBC,EAAiB,EAGdA,GAAkBJ,EAAc,GAAG,CAItC,KAHA9H,EAGY,EAAG,QAAO,EAEtBkI,GAAkBN,EAAK5H,GAAOmI,KAAK/J,GACnCA,EAAIwJ,EAAK5H,IAGbkI,GAAkBN,EAAK5H,GAAOmI,KAAKP,EAAK5H,EAAQ,IAChDA,IAOA,IAJA9K,IAAMkT,EAAgB,GAClBC,EAAmB,EAGhBH,EAAiBJ,EAAc,GAAG,CACrC5S,IAAMoT,EAAOV,EAAK5H,EAAQ,GACpBuI,EAAUX,EAAK5H,GACfwI,EAAOZ,EAAK5H,EAAQ,GAG1B,IAAKwI,EAAM,QAAO,EAElBxK,IAAIyK,EAAaH,EAAKI,QAAQH,GAAWA,EAAQG,QAAQF,GAWzD,IATAC,EAAa7T,KAAK2R,KAAMkC,EAAa,EAAI7T,KAAKC,KAAiB,EAAVD,KAAKC,IAAWD,KAAKC,IAE1EuT,EAAc1C,KAAK,CACfiD,SAAUT,aACVO,IAEJJ,GAAoBI,EAGbP,EAAiBE,EAAc,GAAGO,SAAWZ,GAChDM,GAAoBD,EAAcQ,QAAQH,WAI9C,GAAIJ,EAAmBL,EAAU,QAAO,EAExChI,IACAkI,GAAkBK,EAAQJ,KAAKK,IAInC,QAAO,ECnEX,SAASK,EAAcjB,GAEnB,IADA5J,IAAI8K,EAAa,EACRrI,EAAI,EAAGA,EAAImH,EAAKxW,OAAS,EAAGqP,IACjCqI,GAAclB,EAAKnH,GAAG0H,KAAKP,EAAKnH,EAAI,IAExC,OAAOqI,EAGX,SAASC,EAAmBC,EACAC,EACAC,GACxB,OAAOF,EACH,GAAQC,EAAYC,EACpB,EAGR,SAASC,EAAqBH,EAAsBI,GAChD,OAAOxU,KAAKsC,IACR8R,EAAaA,EAAWK,MAAQL,EAAW9U,KAAO,EAClDkV,EAAaA,EAAWC,MAAQD,EAAWlV,KAAO,GAG1D,SAASoV,EAAgB1B,EACAI,EACAgB,EACAI,EACAH,EACAC,GAOrB,IANAhU,IAAMqU,EAAkBR,EAAmBC,EAAYC,EAAWC,GAC5DpB,EAAcqB,EAAqBH,EAAYI,GAAcF,EAE/DM,EAAe,EACbC,EAAiBZ,EAAcjB,GAAQ,EAEpCzW,EAAI,EAAGA,EAAIyW,EAAKxW,OAAS,EAAGD,IAAK,CAEtC+D,IAAMwU,EAAI9B,EAAKzW,GACXyJ,EAAIgN,EAAKzW,EAAI,GAEXwY,EAAkBD,EAAEvB,KAAKvN,GAE/B,GAAI4O,EAAeG,EAAkBF,EAAgB,CAEjDvU,IAAM0U,GAAKH,EAAiBD,GAAgBG,EACxC7U,EAAI+U,SAAYH,EAAE5U,EAAG8F,EAAE9F,EAAG8U,GAC1BtR,EAAIuR,SAAYH,EAAEpR,EAAGsC,EAAEtC,EAAGsR,GAExB/B,EAAS,IAAIiC,SAAOhV,EAAGwD,EAAGsC,EAAE8N,QAAQgB,GAAIvY,GAE9C,OADA0W,EAAOkC,UACFR,GAAmB5B,EAAcC,EAAMC,EAAQC,EAAayB,EAAiBvB,GACvEH,OAEP,EAIR2B,GAAgBG,IAIxB,SAASK,EAAWpC,EACAqC,EACAjC,EACAgB,EACAI,EACAH,EACAC,EACAgB,EACAC,GAMhBjV,IAAMqU,EAAkBR,EAAmBC,EAAYC,EAAWC,GAC5DkB,EAAoBjB,EAAqBH,EAAYI,GACrDtB,EAAcsC,EAAoBlB,EAGlCmB,EAAgC,IAAdzC,EAAK,GAAG9S,GAAW8S,EAAK,GAAG9S,IAAMqV,GAA4B,IAAdvC,EAAK,GAAGtP,GAAWsP,EAAK,GAAGtP,IAAM6R,EAmBxG,OAfIF,EAAUnC,EAAcmC,EAAU,IAClCA,EAAUnC,EAAcmC,EAAU,GAkB1C,SAASK,EAAS1C,EAAMnE,EAAQwG,EAASV,EAAiBvB,EAAUF,EAAauC,EAAiBE,EAAeJ,GAE7GjV,IAAMsV,EAAkB1C,EAAc,EACtC5S,IAAM4T,EAAaD,EAAcjB,GAEjC5J,IAAI2K,EAAW,EACX8B,EAAiBhH,EAASwG,EAE9BjM,IAAI0M,EAAU,GAEd,IAAK1M,IAAI7M,EAAI,EAAGA,EAAIyW,EAAKxW,OAAS,EAAGD,IAAK,CAQtC,IANA+D,IAAMwU,EAAI9B,EAAKzW,GACXyJ,EAAIgN,EAAKzW,EAAI,GAEXwZ,EAAcjB,EAAEvB,KAAKvN,GACvBgQ,EAAQhQ,EAAE8N,QAAQgB,GAEfe,EAAiBR,EAAUtB,EAAWgC,GAAa,CAGtDzV,IAAM0U,IAFNa,GAAkBR,GAEUtB,GAAYgC,EACpC7V,EAAI+U,SAAYH,EAAE5U,EAAG8F,EAAE9F,EAAG8U,GAC1BtR,EAAIuR,SAAYH,EAAEpR,EAAGsC,EAAEtC,EAAGsR,GAK9B,GAAI9U,GAAK,GAAKA,EAAIqV,GAAc7R,GAAK,GAAKA,EAAI6R,GACtCM,EAAiBD,GAAmB,GACpCC,EAAiBD,GAAmB1B,EAAY,CACpD5T,IAAM2S,EAAS,IAAIiC,SAAOhV,EAAGwD,EAAGsS,EAAOzZ,GACvC0W,EAAOkC,SAEFR,IAAmB5B,EAAcC,EAAMC,EAAQC,EAAayB,EAAiBvB,IAC9E0C,EAAQhF,KAAKmC,KAKzBc,GAAYgC,GAGXJ,GAAkBG,EAAQtZ,QAAWiZ,IAMtCK,EAAUJ,EAAS1C,EAAMe,EAAW,EAAGsB,EAASV,EAAiBvB,EAAUF,EAAauC,GAAiB,EAAMF,IAGnH,OAAOO,EAxDAJ,CAAS1C,EAJAyC,EAEXJ,EAAU,EAAIC,EAAeD,GAD5BG,EAAoB,EAHW,EAAZnB,GAGyBC,EAAWgB,EAAeD,EAG9CA,EAASV,EAAiBvB,EAAUF,EAAauC,GAAiB,EAAOF,GF/FrF1C,YAYlB3O,iBAAQ4O,GACJ1W,KAAK6Z,cAAgB,GACrB7Z,KAAK8Z,QAAU,QACVC,OAAOrD,EAAc,MAfZD,YAkBlBsD,gBAAOrD,EAAyCsD,wBAClBtD,kBAAc,KAA7BuD,OACPja,EAAK6Z,cAAcI,EAAYtX,IAAMsX,EAErC/V,IAAMgN,EAAQlR,EAAK8Z,QAAQG,EAAYtX,IAAMuX,mBAAiBD,KACxDE,eAAiB/J,gBAAcc,EAAM5C,uBAE9B0L,kBAAY,KAAlBrX,cACA3C,EAAK6Z,cAAclX,UACnB3C,EAAK8Z,QAAQnX,IAGxB3C,KAAKoa,iBAAmB,OAExBlW,UDER,SAAuB6J,GAGnB,IAFA7J,IAAMmW,EAAS,GAENla,EAAI,EAAGA,EAAI4N,EAAO3N,OAAQD,IAAK,CACpC+D,IAAMuL,EAAI8G,EAAOxI,EAAO5N,IACpBma,EAAQD,EAAO5K,GACd6K,IACDA,EAAQD,EAAO5K,GAAK,IAExB6K,EAAM5F,KAAK3G,EAAO5N,KAGtB+D,IAAMiL,EAAS,GAEf,QAAWM,KAAK4K,EACZlL,EAAOuF,KAAK2F,EAAO5K,IAGvB,OAAON,ECpBYoL,CAAcC,SAAOxa,KAAK6Z,gCAEN,KACzB9L,OAAsB0M,aAAKR,UAAgBja,EAAK8Z,QAAQG,EAAYtX,MAEpEuO,EAAQnD,EAAO,GACrB,GAAyB,SAArBmD,EAAMwJ,WAAV,KAIMC,EAAWzJ,EAAMlM,QAAU,GAC7B4V,EAAc5a,EAAKoa,iBAAiBO,GACnCC,MACa5a,EAAKoa,iBAAiBO,GAAY,QAG9CE,EAAgB3J,EAAMjF,aAAe,oBACvC6O,EAAsBF,EAAYC,GACjCC,MACqBF,EAAYC,GAAiB,IAGvDC,EAAoBpG,KAAK3G,OGvDrC,IAAMgN,EAcFtU,SAAYqK,EACA8F,EACAC,EACAtJ,EACA8C,EACA2K,EACAC,EACA/C,EACAgD,EACAC,EACAjC,EACAkC,OACJC,EAAKJ,EAAO5X,IAAM6U,EAAWgD,EAC7BnU,EAAKkU,EAAOK,OAASpD,EAAWgD,EAChCK,EAAKN,EAAO/X,KAAOgV,EAAWgD,EAC9BM,EAAKP,EAAO5C,MAAQH,EAAWgD,KAEnClb,KAAKyb,cAAgB3K,EAAkB1Q,OAEnC+a,EAAW,CAEXnO,IAAI/J,EAAS8D,EAAKsU,EACZjb,EAASob,EAAKD,EAEhBtY,EAAS,IAETA,EAASW,KAAKsC,IAAI,GAAKgS,EAAUjV,QAE5ByY,yBAAyB5K,EAAmB8F,EAAMC,EAASA,EAAOI,QAAe7W,EAAQ6C,EAAQsK,EAAc8C,EAAkB2K,EAAa9B,SAGpJ,IACCkC,EAAQ,KAKFO,EAAK,IAAIC,QAAML,EAAIF,GACnBQ,EAAK,IAAID,QAAMJ,EAAIH,GACnBS,EAAK,IAAIF,QAAML,EAAIxU,GACnBgV,EAAK,IAAIH,QAAMJ,EAAIzU,GAEnBiV,EAAgBZ,EAASxX,KAAKC,GAAK,IAEzC8X,EAAGM,QAAQD,GACXH,EAAGI,QAAQD,GACXF,EAAGG,QAAQD,GACXD,EAAGE,QAAQD,KAKNpY,KAAKqC,IAAI0V,EAAG7X,EAAG+X,EAAG/X,EAAGgY,EAAGhY,EAAGiY,EAAGjY,KAC9BF,KAAKsC,IAAIyV,EAAG7X,EAAG+X,EAAG/X,EAAGgY,EAAGhY,EAAGiY,EAAGjY,KAC9BF,KAAKqC,IAAI0V,EAAGrU,EAAGuU,EAAGvU,EAAGwU,EAAGxU,EAAGyU,EAAGzU,KAC9B1D,KAAKsC,IAAIyV,EAAGrU,EAAGuU,EAAGvU,EAAGwU,EAAGxU,EAAGyU,EAAGzU,IAEvCwJ,EAAkB6B,YAAYkE,EAAO/S,EAAG+S,EAAOvP,EAAGiU,EAAIF,EAAIG,EAAIzU,EAAIwG,EAAc8C,EAAkB2K,EAC9F,EAAG,IAGXhb,KAAKkc,YAAcpL,EAAkB1Q,SA3EtB2a,YAsFnBW,kCAAyB5K,EACF8F,EACAC,EACAI,EACAH,EACAqF,EACA5O,EACA8C,EACA2K,EACA9B,GACnBhV,IAAMkY,EAAOD,EAAU,EACjBE,EAASzY,KAAK0Y,MAAMxF,EAAcsF,IAAS,EAS3CG,EAA2B,EAAI,GAAK3Y,KAAK4Y,IAAItD,GAAetV,KAAK6Y,IACjEC,EAAqB9Y,KAAK0Y,MAAMD,EAASE,EAA2B,GAIpEI,GAAkBR,EAAU,EAE9B/O,EAAIyJ,EACJ7H,EAAQiI,EAAU,EAClBC,EAAiByF,EACfC,GAAsB9F,EAAc,EACpC+F,EAAuBD,EAAqB9F,EAAc,EAEhE,EAAG,CAGC,OAAY,EAAG,CACX,GAAII,EAAiB0F,EAGjB,SAIQ,EACR,SAGchG,EAAK5H,GAAOmI,KAAK/J,GACnCA,EAAIwJ,EAAK5H,UAERkI,EAAiB2F,GAI1B,IAFA7P,IAAI8P,EAAgBlG,EAAK5H,GAAOmI,KAAKP,EAAK5H,EAAQ,IAEzC7O,GAAKuc,EAAoBvc,EAAIkc,EAASK,EAAoBvc,IAAK,CAGpE+D,IAAM6Y,EAAY5c,EAAIic,EAClBY,EAAsBJ,EAAqBG,EAM/C,GAHIA,EAAY,IAAGC,GAAuBD,GACtCA,EAAYjG,IAAakG,GAAuBD,EAAYjG,KAE5DkG,EAAsB9F,GAA1B,CAOA,KAAOA,EAAiB4F,EAAgBE,GAAqB,OACvCF,MAIN,GAAKlG,EAAKxW,OAClB,OAGJ0c,EAAgBlG,EAAK5H,GAAOmI,KAAKP,EAAK5H,EAAQ,KAIlD9K,IAAM+Y,EAAqBD,EAAsB9F,EAE3CgG,EAAKtG,EAAK5H,GAEVmO,EADKvG,EAAK5H,EAAQ,GACEoO,IAAIF,GAAIG,QAAQC,MAAML,GAAoBM,KAAKL,GAAInE,SAMvEyE,EAAuB5Z,KAAK2R,IAAIyH,EAAsBL,GAAkBP,EAC1E,EACyC,IAAxCY,EAAsBL,GAE3B7L,EAAkB6B,YAAYwK,EAAerZ,EAAGqZ,EAAe7V,GAC1D6U,EAAU,GAAIA,EAAU,EAAGA,EAAU,EAAGA,EAAU,EACnD5O,EAAc8C,EAAkB2K,EAChCmB,EAAU,EAAGqB,OCzMd,IAAMC,EACjBhX,SAAYlC,EAAWmZ,GAKnB,kBALe,mBAAcC,GAC7B3d,KAAKuE,KAAOA,OACPnE,OAASJ,KAAKuE,KAAKnE,OACxBJ,KAAK0d,QAAUA,EAEX1d,KAAKI,OAAS,MACT4M,IAAI7M,QAAUC,QAAU,GAAK,EAAGD,GAAK,EAAGA,SAAUyd,MAAMzd,KAoEzE,SAASwd,EAAejF,EAAG9O,GACvB,OAAO8O,EAAI9O,GAAK,EAAI8O,EAAI9O,EAAI,EAAI,0XCqCpC,SAAyBiU,GAKrB,IAJA7Q,IAAI8Q,EAAO,EACPha,EAAI,EACJwD,EAAI,EACFyW,EAASF,EAAQ,GACd1d,EAAI,EAAGU,EAAMkd,EAAO3d,OAAQgJ,EAAIvI,EAAM,EAAGV,EAAIU,EAAKuI,EAAIjJ,IAAK,CAChE+D,IAAMwU,EAAIqF,EAAO5d,GACXyJ,EAAImU,EAAO3U,GACX4U,EAAItF,EAAE5U,EAAI8F,EAAEtC,EAAIsC,EAAE9F,EAAI4U,EAAEpR,EAC9BxD,IAAM4U,EAAE5U,EAAI8F,EAAE9F,GAAKka,EACnB1W,IAAMoR,EAAEpR,EAAIsC,EAAEtC,GAAK0W,EACnBF,GAAY,EAAJE,GAEZ,OAAO,IAAIC,EAAKna,EAAIga,EAAMxW,EAAIwW,EAAM,EAAGD,uYA/C3C,SAASK,EAAWxF,EAAG9O,GACnB,OAAOA,EAAE1D,IAAMwS,EAAExS,IAGrB,SAAS+X,EAAKna,EAAGwD,EAAG6W,EAAGN,GACnB7d,KAAKoN,EAAI,IAAIwO,QAAM9X,EAAGwD,GACtBtH,KAAKme,EAAIA,EACTne,KAAKoe,EAKT,SAA4BhR,EAAGyQ,GAI3B,IAHA7Q,IAAIqR,GAAS,EACTC,EAAYrR,EAAAA,EAEPwC,EAAI,EAAGA,EAAIoO,EAAQzd,OAAQqP,IAGhC,IAFAvL,IAAMqa,EAAOV,EAAQpO,GAEZtP,EAAI,EAAGU,EAAM0d,EAAKne,OAAQgJ,EAAIvI,EAAM,EAAGV,EAAIU,EAAKuI,EAAIjJ,IAAK,CAC9D+D,IAAMwU,EAAI6F,EAAKpe,GACTyJ,EAAI2U,EAAKnV,GAEVsP,EAAEpR,EAAI8F,EAAE9F,GAAMsC,EAAEtC,EAAI8F,EAAE9F,GACtB8F,EAAEtJ,GAAK8F,EAAE9F,EAAI4U,EAAE5U,IAAMsJ,EAAE9F,EAAIoR,EAAEpR,IAAMsC,EAAEtC,EAAIoR,EAAEpR,GAAKoR,EAAE5U,IAAIua,GAAUA,GAErEC,EAAY1a,KAAKqC,IAAIqY,EAAWE,uBAAqBpR,EAAGsL,EAAG9O,KAInE,QAAQyU,EAAS,GAAK,GAAKza,KAAK6a,KAAKH,GAvB5BI,CAAmB1e,KAAKoN,EAAGyQ,GACpC7d,KAAKkG,IAAMlG,KAAKoe,EAAIpe,KAAKme,EAAIva,KAAK+a,ODvFPlB,YAW3B/I,cAAKkK,QACIra,KAAKmQ,KAAKkK,GACf5e,KAAKI,cACAye,IAAI7e,KAAKI,OAAS,KAdAqd,YAiB3BqB,eACI,GAAoB,IAAhB9e,KAAKI,OAAT,KAEMiD,EAAMrD,KAAKuE,KAAK,UACtBvE,KAAKI,SAEDJ,KAAKI,OAAS,IACdJ,KAAKuE,KAAK,GAAKvE,KAAKuE,KAAKvE,KAAKI,QAC9BJ,KAAK4d,MAAM,IAEf5d,KAAKuE,KAAKua,MAEHzb,IA7BgBoa,YAgC3BsB,gBACI,OAAO/e,KAAKuE,KAAK,IAjCMkZ,YAoC3BoB,aAAInf,GAIA,QAHO6E,EAAiBvE,UAAX0d,EAAW1d,aAClB4e,EAAOra,EAAK7E,GAEXA,EAAM,GAAG,KACN6D,EAAU7D,EAAM,GAAM,EACtB6X,EAAUhT,EAAKhB,MACjBma,EAAQkB,EAAMrH,IAAY,EAAG,MACjChT,EAAK7E,GAAO6X,IACNhU,GAGVgB,EAAK7E,GAAOkf,IAhDWnB,YAmD3BG,eAAMle,GAKF,QAJO6E,EAAiBvE,UAAX0d,EAAW1d,aAClBgf,EAAahf,KAAKI,QAAU,EAC5Bwe,EAAOra,EAAK7E,GAEXA,EAAMsf,GAAY,KACjB9b,EAAoB,GAAZxD,GAAO,GACfuf,EAAO1a,EAAKrB,GACVmV,EAAQnV,EAAO,KAEjBmV,OAAajY,QAAUsd,EAAQnZ,EAAK8T,GAAQ4G,GAAQ,MAC7C5G,EACP4G,EAAO1a,EAAK8T,IAEZqF,EAAQuB,EAAML,IAAS,EAAG,MAE9Bra,EAAK7E,GAAOuf,IACN/b,GAGVqB,EAAK7E,GAAOkf,6CENlBM,UArDF,SAA2B9S,EAAK+S,GAC/B,IAAIC,EAAWC,EAAOC,EAAIC,EAAKC,EAASC,EAASC,EAAIvf,EASrD,IAPAif,EAAyB,EAAbhT,EAAIhM,OAChBif,EAAQjT,EAAIhM,OAASgf,EACrBE,EAAKH,EACLK,EAAK,WACLC,EAAK,UACLtf,EAAI,EAEGA,EAAIkf,GACRK,EACwB,IAApBtT,EAAI/L,WAAWF,IACO,IAAtBiM,EAAI/L,aAAaF,KAAc,GACT,IAAtBiM,EAAI/L,aAAaF,KAAc,IACT,IAAtBiM,EAAI/L,aAAaF,KAAc,KACnCA,EASFmf,EAAwB,OAAV,OADdC,EAAyB,GAAV,OADTD,GADNA,GAFAI,GAAc,OADdA,GADAA,GAAc,MAALA,GAAeF,KAAUE,IAAO,IAAMF,EAAM,QAAW,IAAQ,aAC5D,GAAOE,IAAO,KACFD,KAAUC,IAAO,IAAMD,EAAM,QAAW,IAAQ,aAGtD,GAAOH,IAAO,OACe,GAAbA,IAAO,IAAW,QAAW,IAAQ,eACnB,OAAdC,IAAQ,IAAgB,QAAW,IAK1E,OAFAG,EAAK,EAEGN,GACP,KAAK,EAAGM,IAA+B,IAAxBtT,EAAI/L,WAAWF,EAAI,KAAc,GAChD,KAAK,EAAGuf,IAA+B,IAAxBtT,EAAI/L,WAAWF,EAAI,KAAc,EAChD,KAAK,EAKLmf,GADAI,GAAa,OADbA,GADAA,GAAa,OAFLA,GAA2B,IAApBtT,EAAI/L,WAAWF,KAEPqf,KAAUE,IAAO,IAAMF,EAAM,QAAW,IAAO,aAC1D,GAAOE,IAAO,KACHD,KAAUC,IAAO,IAAMD,EAAM,QAAW,IAAO,YAYvE,OARAH,GAAMlT,EAAIhM,OAGVkf,EAAuB,YAAV,OADbA,GAAMA,IAAO,OACyC,YAAbA,IAAO,IAAoB,QAAW,IAAO,WAEtFA,EAAwB,YAAV,OADdA,GAAMA,IAAO,OAC0C,YAAbA,IAAO,IAAoB,QAAW,IAAQ,YACxFA,GAAMA,IAAO,MAEC,2CCVbJ,UAvCF,SAA2Bjf,EAAKkf,GAO9B,IANA,IAIE1P,EAHAK,EAAI7P,EAAIG,OACR+d,EAAIgB,EAAOrP,EACX3P,EAAI,EAGC2P,GAAK,GAOVL,EAAqB,YAAV,OANZA,EACwB,IAApBxP,EAAII,WAAWF,IACO,IAAtBF,EAAII,aAAaF,KAAc,GACT,IAAtBF,EAAII,aAAaF,KAAc,IACT,IAAtBF,EAAII,aAAaF,KAAc,OAEiB,YAAZsP,IAAM,IAAoB,QAAW,IAI/E0O,EAAqB,YAAV,MAAJA,KAA4C,YAAZA,IAAM,IAAoB,QAAW,KAFzE1O,EAAqB,YAAV,OADXA,GAAKA,IAAM,OACwC,YAAZA,IAAM,IAAoB,QAAW,KAI5EK,GAAK,IACH3P,EAGJ,OAAQ2P,GACR,KAAK,EAAGqO,IAA8B,IAAxBle,EAAII,WAAWF,EAAI,KAAc,GAC/C,KAAK,EAAGge,IAA8B,IAAxBle,EAAII,WAAWF,EAAI,KAAc,EAC/C,KAAK,EACGge,EAAqB,YAAV,OADXA,GAA0B,IAApBle,EAAII,WAAWF,OAC8B,YAAZge,IAAM,IAAoB,QAAW,KAOpF,OAHAA,EAAqB,YAAV,OADXA,GAAKA,IAAM,OACwC,YAAZA,IAAM,IAAoB,QAAW,KAC5EA,GAAKA,IAAM,MAEE,QC7CEwB,IACQA,IACAC,ECmDlB,SAASC,EAAoB9O,EACP+O,EACAC,EACAC,EACAC,EACAC,GACzBnP,EAAOoP,eAEPjc,IAAM2N,EAAW,IAAMd,EAAOmI,YAC9BnI,EAAOqP,eAAiBlY,SAAS2J,EACjCd,EAAOsP,YAAc,GACrBtP,EAAOuP,iBAAkB,EAEzBpc,IAAMqc,EAASxP,EAAOhD,OAAO,GAAGwS,OAC1BC,EAA0BzP,EAAOhD,OAAO,GAAG0S,mBAAmBC,QAE9DC,EAAQ,GAEd,GAAyC,cAArC5P,EAAO6P,aAAaC,aAA8B,CAClD,MAAmB9P,EAAO6P,aAAaE,UAAhC7a,QAAKC,QACZya,EAAMI,mBAAqB,CACvBP,EAAwB,aAAaQ,iBAAiB,IAAIjP,uBAAqB9L,IAC/Eua,EAAwB,aAAaQ,iBAAiB,IAAIjP,uBAAqB7L,MAIvF,GAAyC,cAArC6K,EAAOkQ,aAAaJ,aAA8B,CAClD,MAAmB9P,EAAOkQ,aAAaH,UAAhC7a,QAAKC,QACZya,EAAMO,mBAAqB,CACvBV,EAAwB,aAAaQ,iBAAiB,IAAIjP,uBAAqB9L,IAC/Eua,EAAwB,aAAaQ,iBAAiB,IAAIjP,uBAAqB7L,MAIvFya,EAAMQ,eAAiBX,EAAwB,aAAaQ,iBAAiB,IAAIjP,uBAAqBhB,EAAOqQ,KAAO,IACpHT,EAAMU,eAAiBb,EAAwB,aAAaQ,iBAAiB,IAAIjP,uBAAqBhB,EAAOqQ,KAAO,IACpHT,EAAMW,YAAcd,EAAwB,aAAaQ,iBAAiB,IAAIjP,uBAAqB,KAQnG,IANA7N,IACMqd,EADQ,GACKhB,EAAOhX,IAAI,oBACxBiY,EAA0D,QAA1CjB,EAAOhX,IAAI,4BAA2E,UAAnCgX,EAAOhX,IAAI,oBAC9EkY,EAAclB,EAAOhX,IAAI,2BAGTwH,EAAO2Q,yBAAU,KAA5B3V,OACD4V,EAAYpB,EAAOhX,IAAI,aAAaqY,SAAS7V,EAAS,IAAI8V,KAAK,KAC/DC,EAAmB/B,EAEnBgC,EAAyB,GACzBzN,EAAOvI,EAAQuI,KACrB,GAAIA,EAAM,CACNpQ,IAAM8d,EAAkB1N,EAAK/N,WACvB0b,EAAgC1B,EAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IAAI0O,aAAK7B,UAdrF,GAc2FA,IAC3FK,EAfA,GAeUsH,EAAOhX,IAAI,uBAAuBqY,SAAS7V,EAAS,IAC9DmW,EAAmBC,sBAAoBH,GAAmB/I,EAAU,EACpEmJ,EAAa7B,EAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IACzDsW,EAAc9B,EAAOhX,IAAI,gBAAgBqY,SAAS7V,EAAS,IAC3DmK,EAA8C,UAAnCqK,EAAOhX,IAAI,oBAnBtB,GAoBFgX,EAAOhX,IAAI,kBAAkBqY,SAAS7V,EAAS,IAC/C,EAEJgW,EAAuB3N,WAAakO,YAAUhO,EAAMwL,EAAU6B,EAAWzL,EAAUqL,EAAYa,EAAYC,EAAaH,EAAkBD,EAvBpI,GAuBuJM,cAAYnO,YACrKoO,4BAA0BR,IAAoBR,GAAiBC,IAC/DM,EAAuBU,SAAWH,YAAUhO,EAAMwL,EAAU6B,EAAWzL,EAAUqL,EAAYa,EAAYC,EAAaH,EAAkBD,EAzBtI,GAyByJM,cAAYE,YAI/KzV,IAAIoL,SACJ,GAAIrM,EAAQ2W,KAAM,CACdxe,IAAMye,EAAQ3C,EAASjU,EAAQ2W,MAC3BC,IACAvK,EAAawK,YACT3C,EAAelU,EAAQ2W,MACvBnC,EAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IAC5CwU,EAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,UACxBV,IAApB0F,EAAO8R,SACP9R,EAAO8R,SAAWF,EAAMG,IACjB/R,EAAO8R,WAAaF,EAAMG,KACjCC,WAAS,uEAETJ,EAAMK,aAAejS,EAAOiS,WAC5BjS,EAAOuP,iBAAkB,EAC0B,IAA5CC,EAAOhX,IAAI,eAAe0Z,WAAW,KAC5ClS,EAAOuP,iBAAkB,MAKjCyB,EAAuB3N,YAAcgE,IACrC8K,EAAWnS,EAAQhF,EAASgW,EAAwB3J,EAAY0J,EAAkBnB,IAItFT,GACAnP,EAAOoS,iCAYf,SAASD,EAAWnS,EACAhF,EACAgW,EACA3J,EACA0J,EACAnB,GAChBzc,IAAMid,EAAiBR,EAAMQ,eAAeS,SAAS7V,EAAS,IACxDsV,EAAiBV,EAAMU,eAAeO,SAAS7V,EAAS,IAM1DuV,EAAcX,EAAMW,YAAYM,SAAS7V,EAAS,SAClCV,IAAhBiW,IACAA,EAAcH,GAGlBjd,IAAMqc,EAASxP,EAAOhD,OAAO,GAAGwS,OAC1B0B,EAAa1B,EAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IACzDqX,EAAa7C,EAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IAG3DsX,EAAYlC,EADE,GAEdmC,EAAevS,EAAOqP,eAAiBiD,EACvCE,EAAkBxS,EAAOqP,eAAiBkB,EAH5B,GAIdkC,EAAezS,EAAOqP,eAAiBiB,EACvCoC,EAAoB1S,EAAOqP,eAAiBG,EAAOhX,IAAI,kBACvDma,EAAcnD,EAAOhX,IAAI,gBAAkBwH,EAAOqP,eAClDuD,EAAcpD,EAAOhX,IAAI,gBAAkBwH,EAAOqP,eAClDwD,EAAerD,EAAOhX,IAAI,kBAAoB,IAAM3F,KAAKC,GACzD2d,EAA0D,QAA1CjB,EAAOhX,IAAI,4BAA2E,UAAnCgX,EAAOhX,IAAI,oBAC9Esa,EAA0D,QAA1CtD,EAAOhX,IAAI,4BAA2E,UAAnCgX,EAAOhX,IAAI,oBAC9Eua,EAAkBvD,EAAOhX,IAAI,oBAC7Bwa,EAAqBN,EAAoB,EAEvCO,WAAqBpN,EAAMC,GACzBA,EAAO/S,EAAI,GAAK+S,EAAO/S,GAAKoE,UAAU2O,EAAOvP,EAAI,GAAKuP,EAAOvP,GAAKY,UAqI9E,SAAmB6I,EACA8F,EACAD,EACAmL,EACA3J,EACAlH,EACAJ,EACAvD,EACA8C,EACA2K,EACAsI,EACAI,EACAlC,EACAS,EACAuB,EACAG,EACAE,EACAT,EACArX,EACA+V,EACAnB,GACfzc,IAEI+f,EAAsBC,EAFpBC,EAAYpT,EAAOqT,qBAAqBvN,EAAQD,GAIlDyN,EAAkB,EAClBC,EAAmB,EACnBC,EAA2B,EACzBnY,EAAMuT,EAAQoC,EAAuB3N,WAAa2N,EAAuB3N,WAAWE,KAAO,IAC3FkQ,EAA0B,GAChC,GAAIzC,EAAuB3N,WAAY,CAGnClQ,IAAMugB,EAAavT,EAAMqP,OAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IACrEkY,EAAuB,IAAIlJ,EAAiBjK,EAAmB8F,EAAMC,EAAQtJ,EAAc8C,EAAkB2K,EAAa+G,EAAuB3N,WAAYkP,EAAcI,EAAalC,EAAezQ,EAAOmI,YAAauL,GAC3NH,GAAoBI,EAAgB3T,EAAQ8F,EAAQkL,EAAuB3N,WAAYlD,EAAOsQ,EAAezV,EAASkW,EAAYkC,EAAWpC,EAAuBU,SAAWF,cAAYnO,WAAamO,cAAYoC,eAAgBH,EAAyB1C,EAAkBnB,GAE3QoB,EAAuBU,WACvB8B,GAA4BG,EAAgB3T,EAAQ8F,EAAQkL,EAAuBU,SAAUvR,EAAOsQ,EAAezV,EAASkW,EAAYkC,EAAW5B,cAAYE,SAAU+B,EAAyB1C,EAAkBnB,KAI5Nzc,IAAM0gB,EAAoBX,EAAuBA,EAAqBxI,cAAgB1K,EAAOD,kBAAkB1Q,OACzGykB,EAAkBZ,EAAuBA,EAAqB/H,YAAcnL,EAAOD,kBAAkB1Q,OAE3G,GAAIgY,EAAY,CACZlU,IAAM4gB,EC9UP,SAAsBjO,EACPuB,EACAlH,EACA6T,EACA/M,EACAjM,GAClB7H,IAYIyX,EAAIE,EAAIE,EAAID,EAZV6G,EAAQvK,EAAWuK,MACnBpC,EAASrP,EAAMqP,OAOfld,EAAM+U,EAAW/U,IAFR,EAEuBsf,EAAMK,WACtC9f,EAAOkV,EAAWlV,KAHT,EAGyByf,EAAMK,WACxC1H,EAASlD,EAAWkD,OAJX,EAI6BqH,EAAMK,WAC5C3K,EAAQD,EAAWC,MALV,EAK2BsK,EAAMK,WAIhD,GAAoC,SAAhCzC,EAAOhX,IAAI,kBAA+ByO,EAAY,CACtD9T,IAAM8gB,EAAa3M,EAAQnV,EACvB+hB,EAAc3J,EAASjY,EACvB6hB,EAAO3E,EAAOhX,IAAI,aAAaqY,SAAS7V,EAAS,IAAM,GACvDoZ,EAAWnN,EAAW9U,KAAOgiB,EAC7BE,EAAYpN,EAAWK,MAAQ6M,EAC/BG,EAAUrN,EAAW3U,IAAM6hB,EAE3BI,EAAYF,EAAYD,EACxBI,EAFavN,EAAWsD,OAAS4J,EAEPG,EAC1BG,EAAOjF,EAAOhX,IAAI,yBAAyB,GAC3Ckc,EAAOlF,EAAOhX,IAAI,yBAAyB,GAC3Cmc,EAAOnF,EAAOhX,IAAI,yBAAyB,GAC3Coc,EAAOpF,EAAOhX,IAAI,yBAAyB,GAC3Cqc,EAA0C,UAAhCrF,EAAOhX,IAAI,iBAA2D,IAA3Bgc,EAAaN,GAAoB,EACtFY,EAA0C,WAAhCtF,EAAOhX,IAAI,iBAA0D,IAAzB+b,EAAYN,GAAmB,EACrFjiB,EAAwC,UAAhCwd,EAAOhX,IAAI,kBAAgE,SAAhCgX,EAAOhX,IAAI,iBAA8B+b,EAAYN,EACxG/hB,EAAyC,WAAhCsd,EAAOhX,IAAI,kBAAiE,SAAhCgX,EAAOhX,IAAI,iBAA8Bgc,EAAaN,EAC/GtJ,EAAK,IAAIC,QAAMuJ,EAAWU,EAAUF,EAAcN,EAAUO,EAAUJ,GACtE3J,EAAK,IAAID,QAAMuJ,EAAWU,EAAUJ,EAAO1iB,EAAOsiB,EAAUO,EAAUJ,GACtEzJ,EAAK,IAAIH,QAAMuJ,EAAWU,EAAUJ,EAAO1iB,EAAOsiB,EAAUO,EAAUF,EAAOziB,GAC7E6Y,EAAK,IAAIF,QAAMuJ,EAAWU,EAAUF,EAAcN,EAAUO,EAAUF,EAAOziB,SAG7E0Y,EAAK,IAAIC,QAAM1Y,EAAMG,GACrBwY,EAAK,IAAID,QAAMvD,EAAOhV,GACtB0Y,EAAK,IAAIH,QAAMvD,EAAOiD,GACtBQ,EAAK,IAAIF,QAAM1Y,EAAMoY,GAGzBpX,IAAM0V,EAAQ1I,EAAMqP,OAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IAAMnI,KAAKC,GAAK,IAEhF,GAAI+V,EAAO,CACP1V,IAAM4hB,EAAMliB,KAAKkiB,IAAIlM,GACjBxS,EAAMxD,KAAKwD,IAAIwS,GACfmM,EAAS,CAAC3e,GAAM0e,EAAKA,EAAK1e,GAE9BuU,EAAGqK,SAASD,GACZlK,EAAGmK,SAASD,GACZjK,EAAGkK,SAASD,GACZhK,EAAGiK,SAASD,IAIhB,OAAO,CAAC,IAACpK,KAAIE,KAAIC,KAAIC,EAAIkK,IAAKtD,EAAMuD,WAAYC,iBAAa9a,EAAW+a,YAAa,CAAC,EAAG,KD6QnEC,CAAaxP,EAAQuB,EAAYlH,EAC/B2S,EAAe9B,EAAuB3N,WACtCrI,GACdua,EAAapV,EAAMqP,OAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IACrEmY,EAAuB,IAAInJ,EAAiBjK,EAAmB8F,EAAMC,EAAQtJ,EAAc8C,EAAkB2K,EAAa5C,EAAYoL,EAAcG,GAAoC,EAAO5S,EAAOmI,YAAaoN,GAEnNjC,EAAqC,EAAnBS,EAAU1kB,OAE5B8D,IAAMqiB,EAAWxV,EAAOkQ,aACpBA,EAAe,KAEW,WAA1BsF,EAAS1F,cACTI,EAAe,CACXuF,mBAAmBtV,EAAMqP,OAAOhX,IAAI,aAAaqY,SAAS7V,EAAS,MAEtD,GAAK0a,GAClB1D,WAAYhS,EAAO2V,SAAS,kEAEC,cAA1BH,EAAS1F,gBAChBI,EAAe,CACXuF,mBAAmB7F,EAAMO,mBAAmB,GAAGU,SAAS7V,EAAS,IACjEya,mBAAmB7F,EAAMO,mBAAmB,GAAGU,SAAS7V,EAAS,MAEpD,GAAK0a,GAAmBxF,EAAa,GAAKwF,IACvD1D,WAAYhS,EAAO2V,SAAS,kEAIpC3V,EAAO4V,WACH5V,EAAO2R,KACPoC,EACA7D,EACAmC,EACAS,EACA9X,GACA,EACA8K,EACAsN,EAAUyC,eACVzC,EAAUrM,aAGlB5T,IAAM2iB,EAAoB3C,EAAuBA,EAAqBzI,cAAgB1K,EAAOD,kBAAkB1Q,OACzG0mB,EAAkB5C,EAAuBA,EAAqBhI,YAAcnL,EAAOD,kBAAkB1Q,OAEvG2Q,EAAOgW,iBAAiB3mB,QAAU4mB,eAAaC,YAAYlE,WAC3D,oGAGJhS,EAAOmW,gBAAgBvU,YACnBkE,EAAO/S,EACP+S,EAAOvP,EACPkd,EAAwBpkB,OAAS,EAAIokB,EAAwB,IAAM,EACnEA,EAAwBpkB,OAAS,EAAIokB,EAAwB,IAAM,EACnEpY,EACAwY,EACAC,EACAgC,EACAC,EACAvZ,EACA+W,EACAC,EACAF,EACA,IA1OA8C,CAAUpW,EAAQ8F,EAAQD,EAAMmL,EAAwB3J,EAAYrH,EAAOhD,OAAO,GAC9EgD,EAAOD,kBAAmB/E,EAAQiD,MAAOjD,EAAQsE,iBAAkBU,EAAO/B,MAC1EsU,EAAcI,EAAalC,EAAeS,EAC1CuB,EAAcG,EAAaE,EAAeT,EAC1CrX,EAAS+V,EAAkBnB,KAGnC,GAAwB,SAApBmD,EACA,cErMR,SAAkBsD,EAA4B7L,EAAYF,EAAYG,EAAYzU,GAG9E,IAFA7C,IAAMmjB,EAAe,GAEZvX,EAAI,EAAGA,EAAIsX,EAAMhnB,OAAQ0P,IAI9B,IAHA5L,IAAM0S,EAAOwQ,EAAMtX,GACfwX,SAEKnnB,EAAI,EAAGA,EAAIyW,EAAKxW,OAAS,EAAGD,IAAK,CACtC6M,IAAIkQ,EAAKtG,EAAKzW,GACVonB,EAAK3Q,EAAKzW,EAAI,GAGd+c,EAAGpZ,EAAIyX,GAAMgM,EAAGzjB,EAAIyX,IAEb2B,EAAGpZ,EAAIyX,EACd2B,EAAK,IAAItB,QAAML,EAAI2B,EAAG5V,GAAKigB,EAAGjgB,EAAI4V,EAAG5V,KAAOiU,EAAK2B,EAAGpZ,IAAMyjB,EAAGzjB,EAAIoZ,EAAGpZ,KAAKiV,SAClEwO,EAAGzjB,EAAIyX,IACdgM,EAAK,IAAI3L,QAAML,EAAI2B,EAAG5V,GAAKigB,EAAGjgB,EAAI4V,EAAG5V,KAAOiU,EAAK2B,EAAGpZ,IAAMyjB,EAAGzjB,EAAIoZ,EAAGpZ,KAAKiV,UAGzEmE,EAAG5V,EAAI+T,GAAMkM,EAAGjgB,EAAI+T,IAEb6B,EAAG5V,EAAI+T,EACd6B,EAAK,IAAItB,QAAMsB,EAAGpZ,GAAKyjB,EAAGzjB,EAAIoZ,EAAGpZ,KAAOuX,EAAK6B,EAAG5V,IAAMigB,EAAGjgB,EAAI4V,EAAG5V,IAAK+T,GAAItC,SAClEwO,EAAGjgB,EAAI+T,IACdkM,EAAK,IAAI3L,QAAMsB,EAAGpZ,GAAKyjB,EAAGzjB,EAAIoZ,EAAGpZ,KAAOuX,EAAK6B,EAAG5V,IAAMigB,EAAGjgB,EAAI4V,EAAG5V,IAAK+T,GAAItC,UAGzEmE,EAAGpZ,GAAK0X,GAAM+L,EAAGzjB,GAAK0X,IAEf0B,EAAGpZ,GAAK0X,EACf0B,EAAK,IAAItB,QAAMJ,EAAI0B,EAAG5V,GAAKigB,EAAGjgB,EAAI4V,EAAG5V,KAAOkU,EAAK0B,EAAGpZ,IAAMyjB,EAAGzjB,EAAIoZ,EAAGpZ,KAAKiV,SAClEwO,EAAGzjB,GAAK0X,IACf+L,EAAK,IAAI3L,QAAMJ,EAAI0B,EAAG5V,GAAKigB,EAAGjgB,EAAI4V,EAAG5V,KAAOkU,EAAK0B,EAAGpZ,IAAMyjB,EAAGzjB,EAAIoZ,EAAGpZ,KAAKiV,UAGzEmE,EAAG5V,GAAKP,GAAMwgB,EAAGjgB,GAAKP,IAEfmW,EAAG5V,GAAKP,EACfmW,EAAK,IAAItB,QAAMsB,EAAGpZ,GAAKyjB,EAAGzjB,EAAIoZ,EAAGpZ,KAAOiD,EAAKmW,EAAG5V,IAAMigB,EAAGjgB,EAAI4V,EAAG5V,IAAKP,GAAIgS,SAClEwO,EAAGjgB,GAAKP,IACfwgB,EAAK,IAAI3L,QAAMsB,EAAGpZ,GAAKyjB,EAAGzjB,EAAIoZ,EAAGpZ,KAAOiD,EAAKmW,EAAG5V,IAAMigB,EAAGjgB,EAAI4V,EAAG5V,IAAKP,GAAIgS,UAGxEuO,GAAgBpK,EAAGzU,OAAO6e,EAAYA,EAAYlnB,OAAS,MAC5DknB,EAAc,CAACpK,GACfmK,EAAa3S,KAAK4S,IAGtBA,EAAY5S,KAAK6S,QAIzB,OAAOF,EFgJgBG,CAASzb,EAAQR,SAAU,EAAG,EAAGrD,SAAQA,0BAYxD,QAZO0O,aACSoC,EACZpC,EACA6M,EACAG,EACA7B,EAAuBU,UAAYV,EAAuB3N,WAC1DgE,EApCM,GAsCNmL,EACAxS,EAAOmI,YACPhR,0BAE0B,KAAnB2O,OACDmB,EAAa+J,EAAuB3N,WACrC4D,GAAeyP,EAAiB1W,EAAQiH,EAAW1D,KAAMyP,EAAoBlN,IAC9EmN,EAAkBpN,EAAMC,SAIjC,GAAwB,gBAApBiN,EAGP,cAAmB/X,EAAQR,yBAAU,KAA1BqL,OACP,GAAIA,EAAKxW,OAAS,EAAG,CACjB8D,IAAM2S,EAASyB,EACX1B,EACAgN,EACA7B,EAAuBU,UAAYV,EAAuB3N,WAC1DgE,EA1DE,GA4DFmL,GACA1M,GACAmN,EAAkBpN,EAAMC,UAIjC,GAAqB,YAAjB9K,EAAQzH,KACf,cAAsBojB,gBAAc3b,EAAQR,SAAU,mBAAI,KAA/CsS,OAED8J,EAAMC,EAA0B/J,EAAS,IAC/CmG,EAAkBnG,EAAQ,GAAI,IAAI/E,SAAO6O,EAAI7jB,EAAG6jB,EAAIrgB,EAAG,UAExD,GAAqB,eAAjByE,EAAQzH,KAEf,cAAmByH,EAAQR,yBAAU,KAA1BqL,OACPoN,EAAkBpN,EAAM,IAAIkC,SAAOlC,EAAK,GAAG9S,EAAG8S,EAAK,GAAGtP,EAAG,UAE1D,GAAqB,UAAjByE,EAAQzH,KACf,cAAqByH,EAAQR,yBACzB,wCAA4B,KAAjBsc,UACP7D,EAAkB,CAAC6D,IAAQ,IAAI/O,SAAO+O,GAAM/jB,EAAG+jB,GAAMvgB,EAAG,8BAMxEpD,IAAMuiB,EAAkB,MAExB,SAAS/B,EAAgB3T,EACA8F,EACAmB,EACA9G,EACAsQ,EACAzV,EACAkW,EACAkC,EACAgC,EACA3B,EACA1C,EACAnB,GACrBzc,IAAM4jB,ECxKH,SAAuBjR,EACPkR,EACA7W,EACA6T,EACAhZ,EACAic,GAUnB,IARA9jB,IACMugB,EAAavT,EAAMqP,OAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IAAMnI,KAAKC,GAAK,IAC/Eoe,EAAa/Q,EAAMqP,OAAOhX,IAAI,eAAeqY,SAAS7V,EAAS,IAAI0O,aAAK7B,UAFhE,GAEsEA,IAE9EqP,EAAmBF,EAAQE,iBAC3BC,EAAQ,GAGLzY,EAAI,EAAGA,EAAIwY,EAAiB7nB,OAAQqP,IAAK,CAC9CvL,IAAMikB,EAAkBF,EAAiBxY,GACnCsQ,EAAiBiI,EAAUG,EAAgBC,WAC3ChlB,EAAQ2c,GAAkBA,EAAeoI,EAAgB/kB,OAC/D,GAAKA,EAAL,CAEAc,IAAMmkB,EAAOjlB,EAAMilB,KACnB,GAAKA,EAAL,CAGAnkB,IACMokB,EAAaC,mBADE,EAGfC,EAAcplB,EAAMqlB,QAAQ7lB,QAAUulB,EAAgBvW,MAAQ,EAE9DwU,EAAcrB,EAChB,CAACoD,EAAgBrkB,EAAI0kB,EAAaL,EAAgB7gB,GAClD,CAAC,EAAG,GAEFohB,EAAgB3D,EAClB,CAAC,EAAG,GACJ,CAACoD,EAAgBrkB,EAAI0kB,EAAcvG,EAAW,GAAIkG,EAAgB7gB,EAAI2a,EAAW,IAE/E1G,GAAMnY,EAAMqlB,QAAQvlB,KAAOolB,GAAcH,EAAgBvW,MAAQ4W,EAAcE,EAAc,GAC7FrN,IAAOjY,EAAMqlB,QAAQplB,IAAMilB,GAAcH,EAAgBvW,MAAQ8W,EAAc,GAC/ElN,EAAKD,EAAK8M,EAAKM,EAAIR,EAAgBvW,MACnC7K,EAAKsU,EAAKgN,EAAKlK,EAAIgK,EAAgBvW,MAEnC+J,EAAK,IAAIC,QAAML,EAAIF,GACnBQ,EAAK,IAAID,QAAMJ,EAAIH,GACnBS,EAAM,IAAIF,QAAML,EAAIxU,GACpBgV,EAAK,IAAIH,QAAMJ,EAAIzU,GAEzB,GAAIge,GAAaoD,EAAgB1F,SAAU,CAQvCve,IAAM0kB,EAAS,IAAIhN,SAAO4M,EAAaA,GACjCK,GAAoBjlB,KAAKC,GAAK,EAC9BilB,EAAoB,IAAIlN,QAAM,EAAG,GACvCD,EAAGoN,cAAcF,EAAkBD,GAAQrL,KAAKuL,GAChDjN,EAAGkN,cAAcF,EAAkBD,GAAQrL,KAAKuL,GAChDhN,EAAGiN,cAAcF,EAAkBD,GAAQrL,KAAKuL,GAChD/M,EAAGgN,cAAcF,EAAkBD,GAAQrL,KAAKuL,IAGpD,GAAIrE,EAAY,CACZvgB,IAAM4hB,EAAMliB,KAAKkiB,IAAIrB,GACjBrd,EAAMxD,KAAKwD,IAAIqd,GACfsB,EAAS,CAAC3e,GAAM0e,EAAKA,EAAK1e,GAE9BuU,EAAGqK,SAASD,GACZlK,EAAGmK,SAASD,GACZjK,EAAGkK,SAASD,GACZhK,EAAGiK,SAASD,IAGhBmC,EAAMxT,KAAK,IAACiH,KAAIE,KAAIC,KAAIC,EAAIkK,IAAKoC,EAAMlC,YAAa4B,EAAQ5B,wBAAaC,OAG7E,OAAO8B,EDyFYc,CAAcnS,EAAQmB,EACjB9G,EAAOsQ,EAAezV,EAAS+V,GAEjDyE,EAAWxV,EAAO6P,aACpBA,EAAe,KAmCnB,OAjC8B,WAA1B2F,EAAS1F,cACTD,EAAe,CACX4F,mBAAmBtV,EAAMqP,OAAOhX,IAAI,aAAaqY,SAAS7V,EAAS,MAEtD,GAAK0a,GAClB1D,WAAYhS,EAAO2V,SAAS,kEAEC,cAA1BH,EAAS1F,gBAChBD,EAAe,CACX4F,mBAAmB7F,EAAMI,mBAAmB,GAAGa,SAAS7V,EAAS,IACjEya,mBAAmB7F,EAAMI,mBAAmB,GAAGa,SAAS7V,EAAS,MAEpD,GAAK0a,GAAmB7F,EAAa,GAAK6F,IACvD1D,WAAYhS,EAAO2V,SAAS,kEAIpC3V,EAAO4V,WACH5V,EAAOuD,KACPwT,EACAlH,EACAqB,EACAT,EACAzV,EACAoa,EACAtP,EACAsN,EAAUyC,eACVzC,EAAUrM,YAId0M,EAAwB9P,KAAK3D,EAAOuD,KAAK2U,kBAAkB7oB,OAAS,GAEzC,EAApB0nB,EAAW1nB,OAwHtB,SAASqnB,EAAiB1W,EAAauD,EAAc4U,EAAwBrS,GACzE3S,IAAMmc,EAActP,EAAOsP,YAC3B,GAAM/L,KAAQ+L,GAIV,IADAnc,IAAMilB,EAAe9I,EAAY/L,GACxB7E,EAAI0Z,EAAa/oB,OAAS,EAAGqP,GAAK,EAAGA,IAC1C,GAAIoH,EAAOM,KAAKgS,EAAa1Z,IAAMyZ,EAE/B,QAAO,OANf7I,EAAY/L,GAAQ,GAYxB,OADA+L,EAAY/L,GAAMI,KAAKmC,IAChB,EGlcX3S,IAgBqBklB,EAIjB3iB,SAAY4iB,GACRnlB,IAAM8jB,EAAY,GACZsB,EAAO,GAEb,QAAWC,KAASF,EAAQ,KAClB3mB,EAAS2mB,EAAOE,GAChBC,EAAiBxB,EAAUuB,GAAS,GAE1C,QAAW5mB,KAAMD,EAAQ,KACf+mB,EAAM/mB,GAAQC,GACpB,GAAK8mB,GAA4B,IAArBA,EAAI5mB,OAAOE,OAAqC,IAAtB0mB,EAAI5mB,OAAOI,OAAjD,KAEMymB,EAAM,GACL,IACA,IACAD,EAAI5mB,OAAOE,MAAQ,IACnB0mB,EAAI5mB,OAAOI,OAAS,GAE3BqmB,EAAK5U,KAAKgV,GACVF,EAAe7mB,GAAM,MAAO+mB,EAAKjB,QAASgB,EAAIhB,kBAIvCkB,UAAQL,GAAhBX,MAAGxK,MACJwE,EAAQ,IAAI7f,aAAW,CAACC,MAAO4lB,GAAK,EAAG1lB,OAAQkb,GAAK,IAE1D,QAAWoL,KAASF,EAAQ,KAClB3mB,EAAS2mB,EAAOE,GAEtB,QAAW5mB,KAAMD,EAAQ,KACf+mB,EAAM/mB,GAAQC,GACpB,GAAK8mB,GAA4B,IAArBA,EAAI5mB,OAAOE,OAAqC,IAAtB0mB,EAAI5mB,OAAOI,OAAjD,CACAiB,IAAMwlB,EAAM1B,EAAUuB,GAAO5mB,GAAI0lB,kBACtBuB,KAAKH,EAAI5mB,OAAQ8f,EAAO,GAAI,IAAM,GAAI,CAAC7e,EAAG4lB,EAAI5lB,EArDzD,EAqDsEwD,EAAGoiB,EAAIpiB,EArD7E,GAqD2FmiB,EAAI5mB,WAIvG7C,KAAK2iB,MAAQA,EACb3iB,KAAKgoB,UAAYA,IAIzBxd,WAAS,aAAc4e,GCzCvB,IAAMS,EAoBFpjB,SAAYxB,GACRjF,KAAK8M,OAAS,IAAI1E,mBAAiBnD,EAAO6H,OAAOxE,YAAarD,EAAO6H,OAAOzE,KAAMpD,EAAO6H,OAAO3E,UAAUZ,EAAGtC,EAAO6H,OAAO3E,UAAUrE,EAAGmB,EAAO6H,OAAO3E,UAAUb,GAChKtH,KAAKgJ,IAAM/D,EAAO+D,IAClBhJ,KAAKohB,KAAOnc,EAAOmc,KACnBphB,KAAKgjB,WAAa/d,EAAO+d,WACzBhjB,KAAK6R,SAAW5M,EAAO4M,SACvB7R,KAAKgF,OAASC,EAAOD,YAChBkU,YAAclZ,KAAK8M,OAAOgd,kBAC/B9pB,KAAKkgB,mBAAqBjb,EAAOib,wBAC5B6J,wBAA0B9kB,EAAO8kB,2BACjCC,qBAAuB/kB,EAAO+kB,qBAwJ3C,SAASC,EAAkBlc,EAAoCqT,GAG3D,IADAld,IAAMgmB,EAAa,IAAInY,uBAAqBqP,SACxBrT,kBAAQ,MAClBoc,YAAYD,KA1LTL,YAiCbO,eAAM7lB,EAAkB8lB,EAA6BC,EAAcrmB,cAC/DjE,KAAKuqB,OAAS,UACdvqB,KAAKuE,KAAOA,EAEZvE,KAAK8Q,kBAAoB,IAAI0Z,oBAC7BtmB,IAAM8J,EAAmB,IAAIpD,kBAAgBqD,OAAOrJ,KAAKL,EAAKwJ,QAAQG,QAEhEX,EAAe,IAAIX,eAAa5M,KAAK8M,QAC3CS,EAAasC,eAAiB,GAE9B3L,IAsDIQ,EACAob,EACA2K,EACAC,EAzDEtZ,EAA8B,GAE9BuZ,EAAU,cACZpd,mBACkB,uBACG,qBACF,IAGjBqd,EAAgBP,EAAWjQ,iBAAiBpa,KAAKgF,QACvD,QAAW6V,KAAiB+P,EAAe,KACjC3e,EAAc1H,EAAKwJ,OAAO8M,MAC3B5O,GAIuB,IAAxBA,EAAY4e,SACZ9H,WAAS,uBAAuB/iB,qBAAuB6a,sFAM3D,QAFMxK,EAAmBrC,EAAiBnD,OAAOgQ,GAC3C6G,EAAW,GACR1S,EAAQ,EAAGA,EAAQ/C,EAAY7L,OAAQ4O,IAAS,KAC/CjD,EAAUE,EAAYF,QAAQiD,KAC3B0F,KAAK,SAAE3I,QAASiD,mBAAOqB,KAGpC,cAAqBua,EAAc/P,mBAAgB,KAAxCiQ,OACD5Z,EAAQ4Z,EAAO,GAGrB,KAAI5Z,EAAM6Z,SAAW/qB,EAAKohB,KAAOxd,KAAK0Y,MAAMpL,EAAM6Z,eAC9C7Z,EAAM8Z,SAAWhrB,EAAKohB,MAAQlQ,EAAM8Z,SACxC,GAAyB,SAArB9Z,EAAMwJ,aAEQoQ,EAAQ9qB,EAAKohB,OAEhBhQ,EAAQF,EAAMvO,IAAMuO,EAAM+Z,aAAa,CAClDjc,MAAOzB,EAAasC,eAAezP,cAC3B0qB,EACR1J,KAAMphB,EAAKohB,KACX4B,WAAYhjB,EAAKgjB,WACjB9J,YAAalZ,EAAKkZ,YAClBpI,kBAAmB9Q,EAAK8Q,mCACxBT,EACA6a,SAAUlrB,EAAKgF,UAGZmmB,SAASzJ,EAAUiJ,GAC1Bpd,EAAasC,eAAe6E,KAAKoW,EAAOrQ,aAAK3K,UAAMA,EAAEnN,aASvD0mB,EAAS+B,YAAUT,EAAQU,2BAAoB3oB,UAAWuL,OAAOrJ,KAAKlC,GAAQ+X,IAAIpT,UACpF4G,OAAOrJ,KAAKykB,GAAQjpB,OACpBkqB,EAAMgB,KAAK,YAAa,CAACtiB,IAAKhJ,KAAKgJ,WAAKqgB,YAAUkC,EAAKpc,GAC9CzK,MACO6mB,IACGpc,EACXqc,EAAaC,KAAKzrB,SAIf,GAGfkE,IAAMwnB,EAAQzd,OAAOrJ,KAAK+lB,EAAQgB,kBAC9BD,EAAMtrB,OACNkqB,EAAMgB,KAAK,YAAa,OAACI,YAASH,EAAKpc,GAC9BzK,MACO6mB,IACEpc,EACVqc,EAAaC,KAAKzrB,SAIhB,GAGdkE,IAAM0nB,EAAW3d,OAAOrJ,KAAK+lB,EAAQkB,8BAgB5BL,OACD9mB,EACA,OAAOT,EAASS,GACb,GAAIob,GAAY2K,GAAWC,EAAY,KACpCoB,EAAa,IAAI1C,EAAWtJ,GAC5BzO,EAAa,IAAI0a,aAAWtB,EAASC,GAE3C,QAAWte,KAAOgF,EAAS,KACjBL,EAASK,EAAQhF,GACnB2E,aAAkBiW,kBACAjW,EAAOhD,YAAaqT,QAClBrQ,EAAQ+O,EAAUgM,EAAW9D,UAAWyC,EAASpZ,EAAW2a,mBAAoB9L,qBAC7FnP,EAAOkb,aACblb,aAAkBmb,cAClBnb,aAAkBob,cAClBpb,aAAkBqb,2BACDrb,EAAOhD,YAAaqT,QAC/BiL,YAAY1B,EAAStZ,EAAWib,oBAI/CtsB,KAAKuqB,OAAS,SACL,KAAM,CACXnZ,QAASoJ,SAAOpJ,GAAS9C,gBAAO1E,WAAMA,EAAE2iB,yBACxChf,EACAuD,kBAAmB9Q,KAAK8Q,kBACxB0b,gBAAiBV,EAAWnJ,iBAC5BtR,WAEUrR,KAAKgqB,mBAAqBlK,EAAW,aACtC9f,KAAKgqB,mBAAqBS,EAAU,oBAC7BzqB,KAAKgqB,mBAAqB8B,EAAW9D,UAAY,SA9CzE4D,EAASxrB,OACTkqB,EAAMgB,KAAK,YAAa,CAACI,MAAOE,YAAYL,EAAKpc,GACxCzK,MACO6mB,IACKpc,EACbqc,EAAaC,KAAKzrB,SAIb,GAIjBwrB,EAAaC,KAAKzrB,QCrK1BkE,IAAMuoB,EAA2C,oBAAhBC,YAC3BC,EAAU,CAEhBA,0BAA4BC,GACxB,UAAIH,GAAqBC,aAAeA,YAAYG,mBACzCH,YAAYG,iBAAiBD,IAK5CD,cAAgBG,GACZ,UAAIL,GAAqBC,aAAeA,YAAYK,OACzCL,YAAYK,KAAKD,IAKhCH,iBAAmBG,EAAcE,EAAmBC,GAChD,UAAIR,GAAqBC,aAAeA,YAAYQ,UACzCR,YAAYQ,QAAQJ,EAAME,EAAWC,IAKpDN,oBAAsBG,GAClB,UAAIL,GAAqBC,aAAeA,YAAYS,aACzCT,YAAYS,WAAWL,IAKtCH,uBAAyBG,GACrB,UAAIL,GAAqBC,aAAeA,YAAYU,gBACzCV,YAAYU,cAAcN,KAWnCO,EAGF5mB,SAAa6mB,QACJC,OAAS,CACVpY,MAAO,GAASyX,IAAK,SAAS/K,KAAK,KACnC2L,IAAK,GAASZ,IAAK,OAAO/K,KAAK,KAC/BqL,QAASI,EAAQV,IAAIrmB,cAGjBwmB,KAAK/sB,KAAKutB,OAAOpY,SChBjC,SAASsY,EAAexoB,EAA8BhB,GAClDC,IAAMopB,EAAUI,iBAAezoB,EAAOqoB,iBAAU/B,EAAahnB,EAAoB4O,EAAuBK,GAChG+X,EACAtnB,EAASsnB,GACFhnB,GACPN,EAAS,KAAM,CACX0pB,WAAY,IAAIC,MAAG9f,WAAW,IAAI+f,WAAStpB,IAC3CupB,QAASvpB,eACT4O,UACAK,OAIZ,kBACI8Z,EAAQS,SACR9pB,MDTUopB,YAadW,oBACYjB,KAAK/sB,KAAKutB,OAAOC,KACzBxgB,IAAIihB,EAAqBtB,EAAQE,iBAAiB7sB,KAAKutB,OAAOL,gBAG5B,IAA9Be,EAAmB7tB,WACX8sB,QAAQltB,KAAKutB,OAAOL,QAASltB,KAAKutB,OAAOpY,MAAOnV,KAAKutB,OAAOC,KACpES,EAAqBtB,EAAQE,iBAAiB7sB,KAAKutB,OAAOL,WAGlDC,WAAWntB,KAAKutB,OAAOpY,SACvBgY,WAAWntB,KAAKutB,OAAOC,OACvBJ,cAAcptB,KAAKutB,OAAOL,UAG/Be,GAIftB,EAAQU,YAAcA,ECVtB,IAAMa,EAaFznB,SAAY6jB,EAAcD,EAA6B8D,GACnDnuB,KAAKsqB,MAAQA,EACbtqB,KAAKqqB,WAAaA,EAClBrqB,KAAKmuB,eAAiBA,GAAkBV,EACxCztB,KAAKouB,QAAU,GACfpuB,KAAKquB,OAAS,KAlB+BH,YA0BjDI,kBAASrpB,EAA8BhB,cAC7B+E,EAAM/D,EAAO+D,IAEdhJ,KAAKouB,UACNpuB,KAAKouB,QAAU,QAEbG,KAAQtpB,GAAUA,EAAOqoB,SAAWroB,EAAOqoB,QAAQvD,wBACrD,IAAI2C,EAAYW,YAAYpoB,EAAOqoB,SAEjCkB,EAAaxuB,KAAKouB,QAAQplB,GAAO,IAAI6gB,EAAW5kB,GACtDupB,EAAWC,MAAQzuB,KAAKmuB,eAAelpB,WAASsmB,EAAKmD,GAGjD,UAFO1uB,EAAKouB,QAAQplB,GAEhBuiB,IAAQmD,EAGR,OAFAF,EAAWjE,OAAS,SACf8D,OAAOrlB,GAAOwlB,EACZvqB,EAASsnB,GAGpBrnB,IAAM0M,EAAc8d,EAASZ,QACvB3a,EAAe,GACjBub,EAASlb,UAASL,EAAaK,QAAUkb,EAASlb,SAClDkb,EAASvb,eAAcA,EAAaA,aAAeub,EAASvb,cAEhEjP,IAAMyqB,EAAiB,MACnBJ,EAAM,KACAN,EAAqBM,EAAKP,SAG5BC,IACAU,EAAeA,eAAiBtY,KAAK+T,MAAM/T,KAAKD,UAAU6X,MAGlEO,EAAWb,WAAae,EAASf,aACtBvD,MAAMsE,EAASf,WAAY3tB,EAAKqqB,WAAYrqB,EAAKsqB,eAAQiB,EAAKpc,GACrE,GAAIoc,IAAQpc,EAAQ,OAAOlL,EAASsnB,KAG3B,KAAMzlB,SAAO,CAAC8K,YAAaA,EAAYge,MAAM,IAAKzf,EAAQgE,EAAcwb,SAGhFN,OAASruB,EAAKquB,QAAU,KACxBA,OAAOrlB,GAAOwlB,OApEsBN,YA2EjDW,oBAAW5pB,EAA8BhB,GACrCC,IAAMmqB,EAASruB,KAAKquB,OAChBrlB,EAAM/D,EAAO+D,IACb8lB,EAAW9uB,KACf,GAAIquB,GAAUA,EAAOrlB,GAAM,KACjBwlB,EAAaH,EAAOrlB,GAC1BwlB,EAAWtO,mBAAqBjb,EAAOib,uBAEjChb,WAAQqmB,EAAKhnB,GACfL,IAAM6qB,EAAiBP,EAAWO,eAC9BA,WACOP,EAAWO,eAClBP,EAAWpE,MAAMoE,EAAWb,WAAYmB,EAASzE,WAAYyE,EAASxE,MAAOyE,IAEjF9qB,EAASsnB,EAAKhnB,KAGQ,YAAtBiqB,EAAWjE,OACXiE,EAAWO,eAAiB7pB,EACC,SAAtBspB,EAAWjE,SAEdiE,EAAWb,WACXa,EAAWpE,MAAMoE,EAAWb,WAAY3tB,KAAKqqB,WAAYrqB,KAAKsqB,MAAOplB,WAjGpCgpB,YA+GjDc,mBAAU/pB,EAAwBhB,GAC9BC,IAAMkqB,EAAUpuB,KAAKouB,QACjBplB,EAAM/D,EAAO+D,IACbolB,GAAWA,EAAQplB,IAAQolB,EAAQplB,GAAKylB,QACxCL,EAAQplB,GAAKylB,eACNL,EAAQplB,UApH0BklB,YA+HjDe,oBAAWhqB,EAAwBhB,GAC/BC,IAAMmqB,EAASruB,KAAKquB,OAChBrlB,EAAM/D,EAAO+D,IACbqlB,GAAUA,EAAOrlB,WACVqlB,EAAOrlB,SC/L1B,IAAMkmB,EAIFzoB,WACIzG,KAAKquB,OAAS,KALUa,YAQ5BZ,kBAASrpB,EAAiChB,OAC/B+E,QAAKG,aAAUgmB,iBAChBC,EAAM,IAAI3lB,UAAQT,EAAKmmB,EAAchmB,QAEtCklB,OAASruB,KAAKquB,QAAU,QACxBA,OAAOrlB,GAAOomB,EACnBnrB,EAAS,KAAMmrB,KAdSF,YAiB5BD,oBAAWhqB,GACPf,IAAMmqB,EAASruB,KAAKquB,OAChBrlB,EAAM/D,EAAO+D,IACbqlB,GAAUA,EAAOrlB,WACVqlB,EAAOrlB,KCjC1BkW,cAAwB,mBACI,EAAE,2BACA,cC0B9B,SAASmQ,EAAYC,GACjB,IAAIxR,EAAO,EACX,GAAIwR,GAAUA,EAAOlvB,OAAS,EAAG,CAC7B0d,GAAQla,KAAK2R,IAAIga,EAASD,EAAO,KACjC,IAAK,IAAInvB,EAAI,EAAGA,EAAImvB,EAAOlvB,OAAQD,IAC/B2d,GAAQla,KAAK2R,IAAIga,EAASD,EAAOnvB,MAGzC,OAAO2d,EAkBX,SAASyR,EAASD,GACd,IAAI/H,EAAIiI,EAAQC,EAAYC,EAAaC,EAAYxvB,EACrD2d,EAAO,EACP8R,EAAeN,EAAOlvB,OAEtB,GAAIwvB,EAAe,EAAG,CAClB,IAAKzvB,EAAI,EAAGA,EAAIyvB,EAAczvB,IACtBA,IAAMyvB,EAAe,GACrBH,EAAaG,EAAe,EAC5BF,EAAcE,EAAc,EAC5BD,EAAa,GACNxvB,IAAMyvB,EAAe,GAC5BH,EAAaG,EAAe,EAC5BF,EAAc,EACdC,EAAa,IAEbF,EAAatvB,EACbuvB,EAAcvvB,EAAE,EAChBwvB,EAAaxvB,EAAE,GAEnBonB,EAAK+H,EAAOG,GACZD,EAAKF,EAAOI,GAEZ5R,IAAU+R,EADLP,EAAOK,GACK,IAAME,EAAItI,EAAG,KAAQ3jB,KAAKkiB,IAAK+J,EAAIL,EAAG,KAG3D1R,EAAOA,EAAOgS,EAAMC,OAASD,EAAMC,OAAS,GAGhD,OAAOjS,EAGX,SAAS+R,EAAIG,GACT,OAAOA,EAAIpsB,KAAKC,GAAK,oBAlFzB,SAAS0H,EAASykB,GACd,IAAc7vB,EAAV2d,EAAO,EACX,OAAQkS,EAAE1rB,MACN,IAAK,UACD,OAAO+qB,EAAYW,EAAEC,aACzB,IAAK,eACD,IAAK9vB,EAAI,EAAGA,EAAI6vB,EAAEC,YAAY7vB,OAAQD,IAClC2d,GAAQuR,EAAYW,EAAEC,YAAY9vB,IAEtC,OAAO2d,EACX,IAAK,QACL,IAAK,aACL,IAAK,aACL,IAAK,kBACD,OAAO,EACX,IAAK,qBACD,IAAK3d,EAAI,EAAGA,EAAI6vB,EAAEE,WAAW9vB,OAAQD,IACjC2d,GAAQvS,EAASykB,EAAEE,WAAW/vB,IAElC,OAAO2d,SArBGyR,KCCtB,SAASY,EAAOC,EAAIC,GAChB,OAASD,GAAMA,EAAG9rB,MAAS,MACvB,IAAK,oBAED,OADA8rB,EAAG1O,SAAW0O,EAAG1O,SAASjH,IAAI6V,EAAWH,EAAQE,IAC1CD,EACX,IAAK,qBAED,OADAA,EAAGF,WAAaE,EAAGF,WAAWzV,IAAI6V,EAAWH,EAAQE,IAC9CD,EACX,IAAK,UAED,OADAA,EAAG7kB,SAAW4kB,EAAOC,EAAG7kB,SAAU8kB,GAC3BD,EACX,IAAK,UACL,IAAK,eACD,OAUZ,SAAiBJ,EAAGK,GACD,YAAXL,EAAE1rB,KACF0rB,EAAEC,YAAcM,EAAaP,EAAEC,YAAaI,GAC1B,iBAAXL,EAAE1rB,OACT0rB,EAAEC,YAAcD,EAAEC,YAAYxV,IAAI6V,EAAWC,EAAcF,KAE/D,OAAOL,EAhBQQ,CAAQJ,EAAIC,GACvB,QACI,OAAOD,IAInB,SAASE,EAAW5X,EAAG9O,GACnB,OAAO,SAASomB,GAAK,OAAOtX,EAAEsX,EAAGpmB,IAYrC,SAAS2mB,EAAaP,EAAGK,GACrBA,IAAUA,EACVL,EAAE,GAAKS,EAAKT,EAAE,GAAIK,GAClB,IAAK,IAAIlwB,EAAI,EAAGA,EAAI6vB,EAAE5vB,OAAQD,IAC1B6vB,EAAE7vB,GAAKswB,EAAKT,EAAE7vB,IAAKkwB,GAEvB,OAAOL,EAGX,SAASS,EAAKT,EAAGU,GACb,OAGJ,SAAYV,GACR,OAAOW,EAAYpS,KAAKyR,IAAM,EAJvBY,CAAGZ,KAAOU,EAAMV,EAAIA,EAAEa,UCzCjC3sB,IAAM4sB,EAAYC,MAAIC,kBAAkBC,UAAUH,UAiB5CI,EAQFzqB,SAAYsF,GACR/L,KAAKmxB,SAAWplB,EAEhB/L,KAAKoxB,OAASlpB,SACdlI,KAAKsE,KAAOyH,EAAQzH,KACpBtE,KAAKoL,WAAaW,EAAQslB,KAQtB,OAAQtlB,IAAYrF,MAAMqF,EAAQpJ,MAClC3C,KAAK2C,GAAK2uB,SAASvlB,EAAQpJ,GAAI,OAtBOuuB,YA0B9C7hB,2BAC+B,IAAvBrP,KAAKmxB,SAAS7sB,KAAY,CAE1B,IADAJ,IAAMqH,EAAW,cACQ4lB,SAAS5lB,yBAAU,KAAjCsc,OACPtc,EAASmJ,KAAK,CAAC,IAAIkH,QAAMiM,EAAM,GAAIA,EAAM,cAEtCtc,EAGP,IADArH,IAAMqH,EAAW,cACO4lB,SAAS5lB,yBAAU,SACjCgmB,EAAU,8BACU,KAAf1J,OACP0J,EAAQ7c,KAAK,IAAIkH,QAAMiM,EAAM,GAAIA,EAAM,MAE3Ctc,EAASmJ,KAAK6c,WAEXhmB,GA1C+B2lB,YA8C9CJ,mBAAUhtB,EAAWwD,EAAWC,GAC5B,OAAOupB,EAAUrF,KAAKzrB,KAAM8D,EAAGwD,EAAGC,IAI1C,IAAMiqB,EAOF/qB,SAAYib,QACH3T,OAAS,CAAE+D,kBAAqB9R,MACrCA,KAAK8sB,KAAO,oBACZ9sB,KAAKoxB,OAASlpB,SACdlI,KAAKI,OAASshB,EAASthB,OACvBJ,KAAKyxB,UAAY/P,IAZmC8P,YAexDzlB,iBAAQ5L,UACG,IAAI+wB,EAAelxB,KAAKyxB,UAAUtxB,KCtFjD,IAAI6wB,EAAoBU,aAA+BV,oBAEtCQ,EAGjB,SAASA,EAAgB9P,EAAUiJ,GACjC3qB,KAAK2qB,QAAUA,GAAW,GAC1B3qB,KAAK0hB,SAAWA,EAChB1hB,KAAKI,OAASshB,EAASthB,QAOzB,SAAS8wB,EAAgBnlB,EAASqlB,GAChCpxB,KAAK2C,GAA2B,iBAAfoJ,EAAQpJ,GAAkBoJ,EAAQpJ,QAAK0I,EACxDrL,KAAKsE,KAAOyH,EAAQzH,KACpBtE,KAAK2xB,YAA+B,IAAjB5lB,EAAQzH,KAAa,CAACyH,EAAQR,UAAYQ,EAAQR,SACrEvL,KAAKoL,WAAaW,EAAQslB,KAC1BrxB,KAAKoxB,OAASA,GAAU,MAT1BI,EAAeP,UAAUllB,QAAU,SAAU5L,GAC3C,OAAO,IAAI+wB,EAAelxB,KAAK0hB,SAASvhB,GAAIH,KAAK2qB,QAAQyG,SAW3DF,EAAeD,UAAU5hB,aAAe,eAClCuiB,EAAQ5xB,KAAK2xB,YACjB3xB,KAAKuL,SAAW,GAEhB,IAAK,IAAIpL,EAAI,EAAGA,EAAIyxB,EAAMxxB,OAAQD,IAAK,CAGrC,IAFA,IAAIoe,EAAOqT,EAAMzxB,GACboxB,EAAU,GACLnoB,EAAI,EAAGA,EAAImV,EAAKne,OAAQgJ,IAC/BmoB,EAAQ7c,KAAK,IAAIkH,UAAM2C,EAAKnV,GAAG,GAAImV,EAAKnV,GAAG,UAExCmC,SAASmJ,KAAK6c,IAErB,OAAOvxB,KAAKuL,UAGd2lB,EAAeD,UAAUvjB,KAAO,WACzB1N,KAAKuL,UAAUvL,KAAKqP,eAQzB,IANA,IAAIuiB,EAAQ5xB,KAAKuL,SACbgQ,EAAKtO,EAAAA,EACLuO,GAAMvO,EAAAA,EACNoO,EAAKpO,EAAAA,EACLlG,GAAMkG,EAAAA,EAED9M,EAAI,EAAGA,EAAIyxB,EAAMxxB,OAAQD,IAGhC,IAFA,IAAIoe,EAAOqT,EAAMzxB,GAERiJ,EAAI,EAAGA,EAAImV,EAAKne,OAAQgJ,IAAK,CACpC,IAAIpB,EAAQuW,EAAKnV,GAEjBmS,EAAK3X,KAAKqC,IAAIsV,EAAIvT,EAAMlE,GACxB0X,EAAK5X,KAAKsC,IAAIsV,EAAIxT,EAAMlE,GACxBuX,EAAKzX,KAAKqC,IAAIoV,EAAIrT,EAAMV,GACxBP,EAAKnD,KAAKsC,IAAIa,EAAIiB,EAAMV,IAI5B,OAAO,CAACiU,EAAIF,EAAIG,EAAIzU,IAGtBmqB,EAAeD,UAAUH,UAAYE,EAAkBC,UAAUH,UC/DjE5R,MAAiB2S,KACiBA,KAyBlC,SAAwB9jB,EAAQ4c,GAC9BA,EAAUA,GAAW,GACrB,IAAI7a,EAAI,GACR,QAASL,KAAK1B,EACZ+B,EAAEL,GAAK,IAAI+hB,EAAezjB,EAAO0B,GAAGiS,SAAUiJ,GAC9C7a,EAAEL,GAAGqd,KAAOrd,EACZK,EAAEL,GAAGob,QAAUF,EAAQE,QACvB/a,EAAEL,GAAG2hB,OAASzG,EAAQyG,OAExB,OAAOS,GAAiB,CAAC9jB,OAAQ+B,QAhCH0hB,EAQhC,SAASK,GAAkBC,GACzB,IAAIC,EAAM,IAAI5vB,MAEd,OAwBF,SAAoB2vB,EAAMlyB,GACxB,QAASwM,KAAO0lB,EAAK/jB,OACnBnO,EAAIoB,aAAa,EAAGgxB,GAAYF,EAAK/jB,OAAO3B,KA3B9C6lB,CAAUH,EAAMC,GACTA,EAAI/D,SA8Bb,SAASgE,GAAY9gB,EAAOtR,GAK1B,IAAIO,EAJJP,EAAIyC,iBAAiB,GAAI6O,EAAM2Z,SAAW,GAC1CjrB,EAAIsyB,iBAAiB,EAAGhhB,EAAM4b,MAAQ,IACtCltB,EAAIyC,iBAAiB,EAAG6O,EAAMkgB,QAAU,MAGxC,IAAIlf,EAAU,CACZtN,KAAM,GACN4V,OAAQ,GACR2X,SAAU,GACVC,WAAY,IAGd,IAAKjyB,EAAI,EAAGA,EAAI+Q,EAAM9Q,OAAQD,IAC5B+R,EAAQnG,QAAUmF,EAAMnF,QAAQ5L,GAChCP,EAAIoB,aAAa,EAAGqxB,GAAcngB,GAGpC,IAAItN,EAAOsN,EAAQtN,KACnB,IAAKzE,EAAI,EAAGA,EAAIyE,EAAKxE,OAAQD,IAC3BP,EAAIsyB,iBAAiB,EAAGttB,EAAKzE,IAG/B,IAAIqa,EAAStI,EAAQsI,OACrB,IAAKra,EAAI,EAAGA,EAAIqa,EAAOpa,OAAQD;;ACqDM,MAAQ,iBAAuB,UACxD,CAAC,oBAA4B,EAAG,qBAA+B,UAAc,EAAG,UAAc,GAAI,SAAW,eAAoB,4BACzH,eAAqB,wBAAgC,kBAAwB,MAAQ,SAClG,CAAC,MAAQ,QAAW,UAAc,OAAU,EAAG,MAAS,UAAe,eAAqB,UAAc,kBAAwB,cAAmB,OAAS,WAAe,IAClLmyB,EAAK,KAAM,UAAc,OAAU,kBAAwB,kBAAwB,uCACnFC,UAAe,MAAQ,MAAQ,KAAO,QAAW,OAAU,QAAW,wBAAiC,4BAAwC,QAC/IC,EAAK,OAAS,QAAW,qBACnB,SAAY,gCAA8C,eAC3D,kCACA,IAAK,QAAW,gBAAsB,iBAAuB,QAAW,GAAI,MAAQ,gBACvE,gCACJ,+BACdC,GAAM,sBAA8B,WAAa,KAAO,EAAG,EAAG,WACzD,CAAC,GAAI,CAAC,KAAO,mBAA0B,GAAI,KAAO,eAAoB,EAAG,KAAO,aAC/E,CAAC,GAAI,CAAC,EAAG,YACfC,KAAK,CAAC,GAAI,CAAC,uCAAqD,GAAI,OAAS,mBACxE,sBAA6B,OAAU,WAAe,SAAY,KAAO,EAAG,IACjF1C,EAAK,CAAC,aAAiB,IACvB2C,WAAc,aAAkB,UAAc,EAAG,gBACvC,CAAC,uBAA+B,SAAY,8BAA2C,EAAG,EAAG,uBAClG,CAAC,0BAAoC,QAAW,MAAQ,6CAA+D,EAAG,oBACxG,gBAAsB,QAAW,EAAG,IAAM,iBAAyB,oBAChF,CAAC,GAAI,YAAgB,QAAW,GAAI,GAAI,WAAe,sBAAgC,EAAG,EAAG,EAAG,EAAG,QAAW,EAAG,GAAI,IAC/HC,+BAA4C,GAAI,QAAW,UAAc,WAAgB,MAAS,SAAa,OAAU,SACpH,IAAK,CAAC,MAAQ,UAAc,UAAc,GAAI,IAAM,KAAO,wBACrC,YAAgB,SAAY,EAAG,SAAY,EAAG,MAAQ,GAAI,IAAI,GAAI,QAAW,UAAc,EAAG,EAAG,EAAG,IAAM,EAAG,EAAG,MAAS,UAAc,aACxJ,CAAC,EAAG,QAAW,KAAO,UAAc,EAAG,GAAI,GAAI,YAAgB,GAAI,GAAI,SACxE,CAAC,UAAc,EAAG,UAAc,OAAS,SAAa,gBAC7C,EAAG,GAAI,EAAG,GAAI,EAAG,gBAAsB,QAAW,UAAc,gBACpE,KAAO,MAAQ,UAAc,GAAI,KAAO,EAAG,WACpD,CAAC,QAAW,EAAG,IACpBC,EAAK,OAAS,GAAI,KAAO,GAAI,IAAM,QAAW,EAAG,GAAI,SAAY,GAAI,MAAQ,GAAI,cAAmB,mDAC/E,GAAI,YAAiB,WAAe,SAAY,GAAI,GAAI,GAAI,WACvE,CAAC,EAAG,UAAc,WAAgB,EAAG,EAAG,IAAM,EAAG,EAAG,IAAI,EAAG,KAAO,GAAI,YAAiB,kBAAwB,EAAG,0BAC9F,EAAG,EAAG,QAAW,EAAG,IAAI,MAAQ,GAAI,SAAY,QAAW,eAAqB,IAAM,cAC/G,CAAC,UAAa,IAAK,IAAI,GAAI,QAAW,iBAAuB,OAAU,GAAI,EAAG,EAAG,MAAS,oBAA6B,OAC5H/oB,EAAK,CAAC,IAAI,MAAQ,EAAG,GAAI,IAAI,EAAG,gBAAuB,WACvDgpB,EAAK,CAAC,GAAI,CAAC,MAAQ,SAAY,GAAI,EAAG,aAAkB,EAAG,EAAG,EAAG,iBAAwB,GAAI,EAAG,GAAI,iBAAyB,IAC7Hla,EAAK,CAAC,UAAY,EAAG,qBAA8B,YACnDma,EAAK,CAAC,GAAI,MAAQ,IAAM,IAAM,IAAM,UAAc,GAAI,GAAI,GAAI,qBACpD,CAAC,EAAG,GAAI,EAAG,oBACrBpK,EAAK,CAAC,GAAI,CAAC,OAAU,IAAI,KAAO,WAAe,GAAI,iBAAuB,EAAG,gBACvE,GAAI,CAAC,QAAW,oBACtBrhB,OAAW,EAAG,GAAI,GAAG,GAAI,aAAkB,YAAiB,QAAW,iBACpD,QAAW,EAAG,EAAG,GAAI,mBAA0B,YACxD,CAAC,OAAU,oBAA4B,QAAW,EAAG,GAAI,GAAG,IAAI,EAAG,WAAe,UAAc,GAAI,KAAO,EAAG,0BAAqC,QAAY,EAAG,SAAa,EAAG,QAAW,GAAI,OAAU,MAAS,EAAG,QAAY,EAAG,KAAO,GAAI,UAAc,EAAG,WACvQ,GAAI,CAAC,EAAG,UACb0rB,IAAK,oBAA2B,EAAG,KAAO,KAAO,GAAI,qBAA6B,GAAI,EAAG,EAAG,GAAI,UAAc,KAAO,KAAO,EAAG,gBAAsB,QAAY,EAAG,EAAG,EAAG,EAAG,SAAa,EAAG,GAAI,KAAO,MAAQ,MAAS,EAAG,EAAG,QAAY,EAAG,KAAO,EAAG,aAAkB,EAAG,WACxQ,CAAC,GAAI,CAAC,EAAG,WAAgB,UAAc,GAAI,WAAe,UAAc,EAAG,cAAmB,IAAM,QAAW,cAAmB,EAAG,KAAO,UAAc,mBCtI7JC,gCCQyB,kBAAfC,WAAZ,CAGAhvB,SAAgCivB,WACdziB,EAAQ0iB,0CAEN,+BAChBC,GAAiB3iB,IAAsBQ,OACnCA,EAAMoiB,MAAM/pB,wEAEK,4BACjB2H,EAAMqP,qCACAA,WAAW,uBACJgT,8CAI0B,IAC3CF,YAAsD,EAClDniB,EAAMoiB,4BACNpiB,EAAMoiB,UAAU,yBAChBpiB,aAAiB,6BACjBA,uCACMqP,WAAW,0BAKrBiT,0BCjCR,mBACIC,YAAgE,UACfviB,EAAOoe,ODgCjC5e,IAAsBQ,uBE5D5BR,SACjB,IAA2B,kCAErBgjB,cAA0B,kBAC1BC,EAAcziB,EAAMoiB,UAAU,uBAC9BM,UAA4BrqB,IAAI,yBAEtC,GAA8B,IAA1BmqB,EAAQzQ,eAAsD,IAA9B0Q,EAAY1Q,mBAAuB2Q,cAAyB,WAI1F1hB,EAAUxB,EAAQwB,YACL2hB,GAEbC,EAAYpjB,uBAA6B,KAAaqjB,UAGtDC,EAAcC,IAAYd,WACdziB,2BAETvQ,IAAOA,EAAImvB,EAAOlvB,OAAQD,IAAK,CACpC+D,QAAqB/D,GAEf2xB,EAAO0B,UAAoBxrB,GAC3B+I,cAA2CG,GACjD,GAAKH,EAAL,CAEA7M,QAAoCgwB,0BAA0BhjB,EAAMvO,iBACjC,aAE3BswB,MAAK/gB,EAAS2hB,iCACEnjB,MAAsBQ,KAAcvO,yBAC7BoO,EAAOojB,cAAoBliB,SACtDf,EAAMoiB,uBAA+Bc,iCC1B7C,OAAIljB,QAAY3H,0DAKN2I,EAAUxB,EAAQwB,UACbA,EAAQ2hB,GAEbC,EAAYpjB,uBAA6B,EAAG2jB,oCAKlB,CAACR,QAAWS,KAAMC,sBAAoB,uBAsCrDriB,EAASxB,EAASQ,WACpB2iB,KACXW,kBAAkBX,EAAGY,qBAGZnrB,IAAI,CAAC,YAAsB,qBAElC4H,gBAELwjB,MCsPD10B,cC3OgB20B,kBAA6BhK,gBAEpCiK,WACbC,2BACY,KACR,WAGN,6BAIoBC,mCACdA,cAAkBA,iBACdA,aAAoBC,qBAIzBA,EAAID,YAAc,GAAOC,EAAID,kCAEhCC,cAAkB,MAKXD,iBAAyBA,sBAG3BC,EAAID,cACPC,EAAID,YAAc,IAItB90B,KAAKurB,MACLvrB,SAAc,QACTg1B,SACLh1B,YAAc,iBAEIi1B,GAClBj1B,KAAKk1B,KAAKC,UAAY,MAElB5K,EAAU6K,4BAERN,YAGN,GAAIvK,IAAWjqB,GAAE+0B,KACf,UAAU71B,SAAU+qB,IAGtBvqB,gBAAkBs1B,GAElBF,GAAaG,iBAAiBv1B,UAAWA,aAwO3C,YAAiBwG,KACf,IAAIgvB,EAAW,IAAIb,GAAQhK,GAK3B,GAHA6K,EAAS9gB,KAAKlO,GAAO,KAGR+kB,UAAaiK,EAASC,sBAE5BD,EAASrmB,OAjNlBwlB,GAAQ1D,UAAUvc,gBAAuBghB,UAI3BC,MACaC,EACrBC,GALAX,OAAYA,oBACaL,UACzBiB,EAAa91B,KAAK2qB,2BASlB3qB,WAAc,SAClB21B,QAAoBD,WAAkCp1B,YAAaA,GAAEy1B,4BAG1DxxB,EAET2wB,EAAK1uB,SAA8BjC,4BAC1BgC,mBACI,kBAEb2uB,QAAa3wB,iCAIYnE,iBAGrB80B,2BACgBN,GAAMoB,KAAKnB,kBAExBM,gBAGEC,sEAIIU,yCAEcA,OACZG,gBAKb1L,oCAAsDsL,6BAIxBK,iBAEd,GAGd3L,OAAa4L,kBAA2B71B,GAAE+0B,KAG5C,kBAFW9K,sDAM4BjqB,GAAE61B,qBAAsBC,iBAA+BC,UAAYV,wBAEhF,gBAAfhL,mBAEiC9V,OAAQqgB,EAAKoB,UAErDC,EAAOrB,EAAKoB,SAAWE,EACvBZ,EAAUa,GAAmBvB,EAAKrgB,OAAQ2hB,GAG1CtB,WAAgBqB,EAChBrB,EAAKC,WAAYN,EAAY0B,EACzBA,MAAcG,SAASxB,EAAKrgB,OAAQqgB,EAAKrgB,OAAQ2hB,EAAeD,UAE/DI,OAAOf,SAGPe,OAAO/B,GAAMgC,YAAe/hB,QAAQqgB,eAYzB,IAAlBA,EAAKkB,UAAqC,IAAnBlB,EAAKC,yBAIxBD,EAAKkB,gBAAgBlB,EAAKC,YAAoB5K,IAAWjqB,GAAE61B,cAOrE,OALI5L,IAAWjqB,GAAE61B,eACfR,EAAQr1B,GAAE+1B,UAIRV,IAAUr1B,GAAE+1B,UACd9L,EAAS6K,GAAayB,WAAW72B,KAAKk1B,MACtCl1B,KAAK82B,OAAMvM,GACXvqB,KAAKg1B,OAAQ,EACNzK,OAAa8K,MAIlBM,OAAYoB,eACd/2B,KAAK82B,MAAMx2B,IAAE+0B,kBACI,UAiBbpE,0BAA6B+F,eACvBtiB,KAAKsiB,gCAciBzM,4BAG5BvqB,KAAK2qB,gBAGFxb,wBAA0B,IAE/BnP,2CAGJA,YAAc,cAEdA,KAAKy1B,IAAMz1B,KAAKk1B,KAAKO,KCnUvB,oBDmZkBd,WACAsC,uBAlBEzwB,KAGlB,SAFUmkB,YACI,EACPsM,KAAetM,WAiBNsM,mBCvXhB,MAAWC,IAAQC,KACJC,EAAK,KACEA,eACbC,KAAkC,iBAOvBF,OACpB,IAAIG,EACAF,KAAeD,GACfE,EAAWD,KACXG,gBARN,SAAsBJ,iBACXE,EAAWE,KAA4BA,EAS9BC,CAAYL,IAAeI,IAEzCE,EAAU,EAGV52B,EAAM02B,IACNF,MAGKl3B,IAAOA,OAAc,EAC5Bm3B,EACGI,KAAcr3B,gBAAkB,GAChCq3B,KAAcr3B,WAAWF,EAAI,KAAO,QACtBE,WAAWF,SAC1Bu3B,gBAAyBv3B,EAAI,IAC/BgB,OAAkBm2B,MAAa,MAC3BG,MAAcH,SAClBn2B,OAAuB,UAGrBo2B,IACFD,KACaH,kBAAsB,KACtBA,iCACIG,OAGfC,KACFD,EACGI,2BACUP,EAAI92B,YAAWF,EAAI,YACfE,oBACjBc,EAAIs2B,QAAqB,MACzBt2B,2BA0BJ,SAAwBw2B,GAQtB,UANI92B,IAAYT,OACZw3B,EAAa/2B,EAAM,EACnBg3B,EAAQ,KAIC,MAAgBD,EAAYz3B,IAAUA,IAH9B,aAIR23B,eACwBC,IAAe53B,EAL/B,QAUF,IAAfy3B,GACFN,EAAMK,EAAM92B,OACN6T,KACJsjB,GAAOV,GAAO,SACC,EAAK,WAGE,aACXz2B,EAAM,IAAM,GAAK82B,OAC9BE,EAAMnjB,KACJsjB,MAAc,IACdA,MAAe,EAAK,UACL,EAAK,IACpB,MAIJ,OAAOH,EAAMhW,KAAK,QA/IP,GACT6V,SAC4B,oBAAfzB,qGAGJ,EAAGp1B,MAAWT,eAAmBD,GAC5C63B,GAAO73B,IAAK83B,GAAK93B,0BACeA,GAQlC,eACE,MAAUg3B,EAAI/2B,OAEd,GAAIS,EAAM,EAAI,EACZ,MAAM,IAAIrB,MAAM,mDAKlB,KAAI63B,EAAWF,EAAIlnB,oBACD,IAAdonB,IAAiBA,EAAWx2B,MAEVw2B,QAElB,EAAKA,EAAW,GAqEtB,SAASS,GAAaH,IAAcnK,IAGlC,SAFI8J,EARoBY,IASX,OACO/3B,EAAIqtB,KAAU,OAEtBrtB,KAAM,cACZw3B,IAAU,IAAM,EAAK,YACtBA,IAAU,IACb9iB,EAAOH,KAdFsjB,IADiBE,EAeMZ,IAdT,OACnBU,GAAOE,GAAO,OACdF,GAAOE,GAAO,EAAI,OACL,GAANA,IAaT,SAAcrW,KAAK,IAhGrB6V,GAAU,IAAIr3B,WAAW,cACXA,eAAiB,8GCZbsqB,IAAqBwN,GAC/Bn4B,iCACeo4B,eAAqBC,yIAIpCn0B,IAAMo0B,eAA+B1J,OAAO,GAAG,GACzC5pB,EAAShF,KACf,yBAAsBu4B,KACf,WAAYA,iBACQ,WAAmBC,sBACxBC,2CAC4BC,6CAC9BhI,EAAIiI,aAAa,qBAAsB,4EAKjBC,aAAaC,wBAEvCL,EAAO,iCAEP,YACJ,OAAO,IAAIM,iBAAkBC,EAASP,GAClCQ,UAAkBV,EAAQ,KAAaE,KACxCS,MAAM,qBACEj0B,EAAOk0B,iBAAiBC,WAEpCC,KAAK,eACAn0B,EAAS,SAMb,MALuB,0GAKUA,KAG9B6zB,yBAAyB,sJAIJ,uKAKvBK,EAAYb,YACzBe,YAAY,yDACDP,QAAQ,SAAUC,EAASP,mFAEUA,KAC7CY,iBACC,OAAO,IAAIN,wBACIQ,WAA0BP,EAASP,qBAE9Ca,YAAY,wEAODv1B,EAAGwD,WACd8xB,cAAcG,KACfC,YAAY,cACPC,iKAEuBC,EAAIC,MAAK/a,8BACPqY,WAAiB2C,yBAClBC,iBAAuB/L,eAE9BtuB,sBAA4B,qCAIxCkF,aAER,cACI6mB,kBAIjB+C,uBACIpqB,6BAC0BqD,oBAAwBQ,kCAEnC9B,sBAA6B+B,EAAMT,UAE5CD,EAAI1D,SAAS,WAEnB5D,6BAEkBurB,KACd,GAAIA,cAGJ,QAAmBlgB,eACD,UAAU,sBAIxBiiB,aAAgB,6CACXwE,EAAK9oB,aACG8D,OACbsU,OAAY7Z,EACZsK,cAAeA,SAAWqH,gCAG1B8J,WAAY8W,OAAOC,mBAAoB,EACvC7gB,YAAaA,qBACOlZ,KAAKya,IAAIyF,oBAG5B4R,YAAgC,YAAfA,QAEI,YAAfA,yBAEe7tB,6CAE+BjE,QAAYg6B,UALjElI,EAAKkI,yBAA2B1O,gBAAiBrmB,SAAkBjF,2BAS/D8xB,cAGAvG,EACA,OAAOtnB,EAASsnB,QAGX9Q,IAAIwf,sBAAsBnI,gBAAmBvtB,oBAClCA,EAAMvE,KAAKya,eAEtB,QAEAsU,iBACL/uB,KAAKsuB,aAAoBS,gBACzB+C,EAAK/C,eAAiB,cA/CG/uB,WA9FjBk6B,GC0BtBC,wCACiBhpB,SAA8BA,yBAtBnCyb,EAuBMjC,YAvBMmO,mBAAkBN,OACtC4B,MAAUN,SAAOO,wBACnBC,KAAK,SAAY,KACjBC,kBAAiB,8BACrBH,EAAII,iBAAW5H,UAAM4F,EAAO5F,IAC5BwH,oBACIl2B,MAAsD,OAAnCu2B,oBAAoB,iBAC7BlQ,QAAU,OAAWA,OAAS,SAAmB6P,sBAEtChQ,MAAMgQ,aACrB,WACS7O,sBAGUmP,WAAYN,YAGzCA,cAMmChB,wBAAgBtzB,cAAoB,aAE5DgzB,gBAAgBnO,yBAK3BzmB,MAAcymB,qBAER0N,4DAA+D,cAAe,2CAE3CjpB,wCACMurB,cAC5BtC,EAAO,aACtBlnB,eAA6BA,EAAMzO,QAEhCioB,0FAG6BmO,oBACpC50B,0BAAgD,YAE5C6J,OAAQ,KAEN6sB,WAAyB,YAAqBC,IAC9CpgB,EAAM,6CACeqgB,wBAAyBC,iCAgB3C3B,MAbQjoB,IAaoBA,uCAZnB6pB,sBAAcC,UAAexgB,YAAcwgB,EAAY9pB,EAAM6pB,QAAQC,MAChFxgB,mBAGStJ,6BAChBA,EAAMpD,qBAAYmD,qBAAuBA,KAClCuJ,kBAPUtJ;;AC7DrB,EAAE;;;;;;;;"}